import {
  MotionContext,
  Presence,
  SharedLayoutContext,
  createBatcher,
  elementDragControls,
  getValueTransition,
  isMotionValue,
  motionValue,
  snapshotViewportBox,
  startAnimation,
  transformAxes
} from "./chunk-RCLFU7KR.js";
import {
  setDomContext
} from "./chunk-OTU5X46N.js";
import "./chunk-STGXCCFQ.js";
import {
  circOut,
  linear,
  mix,
  mixColor,
  progress
} from "./chunk-76WLFTWD.js";
import "./chunk-NXTUI3FV.js";
import {
  es_default,
  getFrameData
} from "./chunk-F3MIBQYA.js";
import "./chunk-DPJLTTUP.js";
import {
  writable
} from "./chunk-F4TPOVUK.js";
import "./chunk-X7HCJ7ZS.js";
import {
  SvelteComponentDev,
  create_slot,
  dispatch_dev,
  getContext,
  get_all_dirty_from_scope,
  get_slot_changes,
  get_store_value,
  init,
  onMount,
  safe_not_equal,
  setContext,
  tick,
  transition_in,
  transition_out,
  update_slot_base,
  validate_slots
} from "./chunk-POX46NQO.js";
import "./chunk-NRUTNXHJ.js";
import "./chunk-2NWPA7HM.js";
import "./chunk-WTEL7FPM.js";

// node_modules/svelte-motion/src/animation/animate.js
function animate(from, to, transition) {
  if (transition === void 0) {
    transition = {};
  }
  var value = isMotionValue(from) ? from : motionValue(from);
  startAnimation("", value, to, transition);
  return {
    stop: function() {
      return value.stop();
    }
  };
}

// node_modules/svelte-motion/src/components/AnimateSharedLayout/utils/crossfader.js
function createCrossfader() {
  var progress2 = motionValue(1);
  var options = {
    lead: void 0,
    follow: void 0,
    crossfadeOpacity: false,
    preserveFollowOpacity: false
  };
  var prevOptions = Object.assign({}, options);
  var leadState = {};
  var followState = {};
  var isActive = false;
  var finalCrossfadeFrame = null;
  var prevUpdate = 0;
  function startCrossfadeAnimation(target, transition) {
    var lead = options.lead, follow = options.follow;
    isActive = true;
    finalCrossfadeFrame = null;
    var hasUpdated = false;
    var onUpdate = function() {
      hasUpdated = true;
      lead && lead.scheduleRender();
      follow && follow.scheduleRender();
    };
    var onComplete = function() {
      isActive = false;
      finalCrossfadeFrame = getFrameData().timestamp;
    };
    transition = transition && getValueTransition(transition, "crossfade");
    return animate(progress2, target, Object.assign(Object.assign({}, transition), { onUpdate, onComplete: function() {
      if (!hasUpdated) {
        progress2.set(target);
        es_default.read(onComplete);
      } else {
        onComplete();
      }
      onUpdate();
    } }));
  }
  function updateCrossfade() {
    var _a, _b;
    var timestamp = getFrameData().timestamp;
    var lead = options.lead, follow = options.follow;
    if (timestamp === prevUpdate || !lead)
      return;
    prevUpdate = timestamp;
    var latestLeadValues = lead.getLatestValues();
    Object.assign(leadState, latestLeadValues);
    var latestFollowValues = follow ? follow.getLatestValues() : options.prevValues;
    Object.assign(followState, latestFollowValues);
    var p = progress2.get();
    var leadTargetOpacity = (_a = latestLeadValues.opacity) !== null && _a !== void 0 ? _a : 1;
    var followTargetOpacity = (_b = latestFollowValues === null || latestFollowValues === void 0 ? void 0 : latestFollowValues.opacity) !== null && _b !== void 0 ? _b : 1;
    if (options.crossfadeOpacity && follow) {
      leadState.opacity = mix(
        /**
         * If the follow child has been completely hidden we animate
         * this opacity from its previous opacity, but otherwise from completely transparent.
         */
        follow.isVisible !== false ? 0 : followTargetOpacity,
        leadTargetOpacity,
        easeCrossfadeIn(p)
      );
      followState.opacity = options.preserveFollowOpacity ? followTargetOpacity : mix(followTargetOpacity, 0, easeCrossfadeOut(p));
    } else if (!follow) {
      leadState.opacity = mix(followTargetOpacity, leadTargetOpacity, p);
    }
    mixValues(leadState, followState, latestLeadValues, latestFollowValues || {}, Boolean(follow), p);
  }
  return {
    isActive: function() {
      return leadState && (isActive || getFrameData().timestamp === finalCrossfadeFrame);
    },
    fromLead: function(transition) {
      return startCrossfadeAnimation(0, transition);
    },
    toLead: function(transition) {
      var initialProgress = 0;
      if (!options.prevValues && !options.follow) {
        initialProgress = 1;
      } else if (prevOptions.lead === options.follow && prevOptions.follow === options.lead) {
        initialProgress = 1 - progress2.get();
      }
      progress2.set(initialProgress);
      return startCrossfadeAnimation(1, transition);
    },
    reset: function() {
      return progress2.set(1);
    },
    stop: function() {
      return progress2.stop();
    },
    getCrossfadeState: function(element) {
      updateCrossfade();
      if (element === options.lead) {
        return leadState;
      } else if (element === options.follow) {
        return followState;
      }
    },
    setOptions: function(newOptions) {
      prevOptions = options;
      options = newOptions;
      leadState = {};
      followState = {};
    },
    getLatestValues: function() {
      return leadState;
    }
  };
}
var easeCrossfadeIn = compress(0, 0.5, circOut);
var easeCrossfadeOut = compress(0.5, 0.95, linear);
function compress(min, max, easing) {
  return function(p) {
    if (p < min)
      return 0;
    if (p > max)
      return 1;
    return easing(progress(min, max, p));
  };
}
var borders = ["TopLeft", "TopRight", "BottomLeft", "BottomRight"];
var numBorders = borders.length;
function mixValues(leadState, followState, latestLeadValues, latestFollowValues, hasFollowElement, p) {
  for (var i = 0; i < numBorders; i++) {
    var borderLabel = "border" + borders[i] + "Radius";
    var followRadius = getRadius(latestFollowValues, borderLabel);
    var leadRadius = getRadius(latestLeadValues, borderLabel);
    if (followRadius === void 0 && leadRadius === void 0)
      continue;
    followRadius || (followRadius = 0);
    leadRadius || (leadRadius = 0);
    if (typeof followRadius === "number" && typeof leadRadius === "number") {
      var radius = Math.max(mix(followRadius, leadRadius, p), 0);
      leadState[borderLabel] = followState[borderLabel] = radius;
    }
  }
  if (latestFollowValues.rotate || latestLeadValues.rotate) {
    var rotate = mix(latestFollowValues.rotate || 0, latestLeadValues.rotate || 0, p);
    leadState.rotate = followState.rotate = rotate;
  }
  if (!hasFollowElement && latestLeadValues.backgroundColor && latestFollowValues.backgroundColor) {
    leadState.backgroundColor = followState.backgroundColor = mixColor(latestFollowValues.backgroundColor, latestLeadValues.backgroundColor)(p);
  }
}
function getRadius(values, radiusName) {
  var _a;
  return (_a = values[radiusName]) !== null && _a !== void 0 ? _a : values.borderRadius;
}

// node_modules/svelte-motion/src/components/AnimateSharedLayout/utils/stack.js
function layoutStack() {
  var stack = /* @__PURE__ */ new Set();
  var state = { leadIsExiting: false };
  var prevState = Object.assign({}, state);
  var prevValues;
  var prevViewportBox;
  var prevDragCursor;
  var crossfader = createCrossfader();
  var needsCrossfadeAnimation = false;
  function getFollowViewportBox() {
    return state.follow ? state.follow.prevViewportBox : prevViewportBox;
  }
  function getFollowLayout() {
    var _a;
    return (_a = state.follow) === null || _a === void 0 ? void 0 : _a.getLayoutState().layout;
  }
  return {
    add: function(element) {
      element.setCrossfader(crossfader);
      stack.add(element);
      if (prevDragCursor)
        element.prevDragCursor = prevDragCursor;
      if (!state.lead)
        state.lead = element;
    },
    remove: function(element) {
      stack.delete(element);
    },
    getLead: function() {
      return state.lead;
    },
    updateSnapshot: function() {
      if (!state.lead)
        return;
      prevValues = crossfader.isActive() ? crossfader.getLatestValues() : state.lead.getLatestValues();
      prevViewportBox = state.lead.prevViewportBox;
      var dragControls = elementDragControls.get(state.lead);
      if (dragControls && dragControls.isDragging) {
        prevDragCursor = dragControls.cursorProgress;
      }
    },
    clearSnapshot: function() {
      prevDragCursor = prevViewportBox = void 0;
    },
    updateLeadAndFollow: function() {
      var _a;
      prevState = Object.assign({}, state);
      var lead;
      var follow;
      var order = Array.from(stack);
      for (var i = order.length; i--; i >= 0) {
        var element = order[i];
        if (lead)
          follow !== null && follow !== void 0 ? follow : follow = element;
        lead !== null && lead !== void 0 ? lead : lead = element;
        if (lead && follow)
          break;
      }
      state.lead = lead;
      state.follow = follow;
      state.leadIsExiting = ((_a = state.lead) === null || _a === void 0 ? void 0 : _a.presence) === Presence.Exiting;
      crossfader.setOptions({
        lead,
        follow,
        prevValues,
        crossfadeOpacity: (follow === null || follow === void 0 ? void 0 : follow.isPresenceRoot) || (lead === null || lead === void 0 ? void 0 : lead.isPresenceRoot)
      });
      if (
        // Don't crossfade if we've just animated back from lead and switched the
        // old follow to the new lead.
        state.lead !== prevState.follow && (prevState.lead !== state.lead || prevState.leadIsExiting !== state.leadIsExiting)
      ) {
        needsCrossfadeAnimation = true;
      }
    },
    animate: function(child, shouldCrossfade) {
      var _a;
      if (shouldCrossfade === void 0) {
        shouldCrossfade = false;
      }
      if (child === state.lead) {
        if (shouldCrossfade) {
          child.pointTo(state.lead);
        } else {
          child.setVisibility(true);
        }
        var config = {};
        var prevParent = (_a = state.follow) === null || _a === void 0 ? void 0 : _a.getProjectionParent();
        if (prevParent) {
          config.prevParent = prevParent;
        }
        if (child.presence === Presence.Entering) {
          config.originBox = getFollowViewportBox();
        } else if (child.presence === Presence.Exiting) {
          config.targetBox = getFollowLayout();
        }
        if (needsCrossfadeAnimation) {
          needsCrossfadeAnimation = false;
          var transition = child.getDefaultTransition();
          child.presence === Presence.Entering ? crossfader.toLead(transition) : crossfader.fromLead(transition);
        }
        child.notifyLayoutReady(config);
      } else {
        if (shouldCrossfade) {
          state.lead && child.pointTo(state.lead);
        } else {
          child.setVisibility(false);
        }
      }
    }
  };
}

// node_modules/svelte-motion/src/components/AnimateSharedLayout/utils/rotate.js
function resetRotate(child) {
  var hasRotate = false;
  var resetValues = {};
  for (var i = 0; i < transformAxes.length; i++) {
    var axis = transformAxes[i];
    var key = "rotate" + axis;
    if (!child.hasValue(key) || child.getStaticValue(key) === 0)
      continue;
    hasRotate = true;
    resetValues[key] = child.getStaticValue(key);
    child.setStaticValue(key, 0);
  }
  if (!hasRotate)
    return;
  child.syncRender();
  for (var key in resetValues) {
    child.setStaticValue(key, resetValues[key]);
  }
  child.scheduleRender();
}

// node_modules/svelte-motion/src/components/AnimateSharedLayout/AnimateSharedLayout.svelte
function create_fragment(ctx) {
  let current;
  const default_slot_template = (
    /*#slots*/
    ctx[4].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[3],
    null
  );
  const block = {
    c: function create() {
      if (default_slot)
        default_slot.c();
    },
    l: function claim(nodes) {
      if (default_slot)
        default_slot.l(nodes);
    },
    m: function mount(target, anchor) {
      if (default_slot) {
        default_slot.m(target, anchor);
      }
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope*/
        8)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[3],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[3]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[3],
              dirty,
              null
            ),
            null
          );
        }
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(default_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (default_slot)
        default_slot.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("AnimateSharedLayout", slots, ["default"]);
  let { type = void 0, isCustom = false } = $$props;
  const context = getContext(MotionContext) || MotionContext(isCustom);
  let hasMounted = false;
  let children = /* @__PURE__ */ new Set();
  let stacks = /* @__PURE__ */ new Map();
  let updateScheduled = false;
  let renderScheduled = false;
  let forced = false;
  let syncContext = {
    ...createBatcher(),
    syncUpdate: (force) => scheduleUpdate(force),
    forceUpdate: () => {
      scheduleUpdate();
      forced = true;
    },
    register: (child) => addChild(child),
    remove: (child) => {
      removeChild(child);
    }
  };
  const startLayoutAnimation = () => {
    $$invalidate(2, renderScheduled = updateScheduled = false);
    children.forEach((child) => {
      if (!child.isPresent) {
        child.presence = Presence.Exiting;
      } else if (child.presence !== Presence.Entering) {
        child.presence = child.presence === Presence.Exiting ? Presence.Entering : Presence.Present;
      }
    });
    updateStacks();
    const handler = {
      measureLayout: (child) => child.updateLayoutMeasurement(),
      layoutReady: (child) => {
        if (child.getLayoutId() !== void 0) {
          const stack = getStack(child);
          stack.animate(child, type === "crossfade");
        } else {
          child.notifyLayoutReady();
        }
      },
      parent: get_store_value(context).visualElement
    };
    children.forEach((child) => syncContext.add(child));
    syncContext.flush(handler);
    stacks.forEach((stack) => stack.clearSnapshot());
  };
  const updateStacks = () => {
    stacks.forEach((stack) => stack.updateLeadAndFollow());
  };
  const scheduleUpdate = (force = false) => {
    if (!(force || !updateScheduled))
      return;
    updateScheduled = true;
    children.forEach((child) => resetRotate(child));
    children.forEach((child) => snapshotViewportBox(child));
    stacks.forEach((stack) => stack.updateSnapshot());
    if (force || !renderScheduled) {
      $$invalidate(2, renderScheduled = true);
      forced = true;
    }
  };
  const addChild = (child) => {
    children.add(child);
    addToStack(child);
    child.presence = hasMounted ? Presence.Entering : Presence.Present;
  };
  const removeChild = (child) => {
    scheduleUpdate();
    children.delete(child);
    removeFromStack(child);
  };
  const addToStack = (child) => {
    const stack = getStack(child);
    stack == null ? void 0 : stack.add(child);
  };
  const removeFromStack = (child) => {
    const stack = getStack(child);
    stack == null ? void 0 : stack.remove(child);
  };
  const getStack = (child) => {
    const id = child.getLayoutId();
    if (id === void 0)
      return;
    !stacks.has(id) && stacks.set(id, layoutStack());
    return stacks.get(id);
  };
  let sc = writable(syncContext);
  const setSyncContext = () => {
    syncContext = { ...syncContext };
    sc.set(syncContext);
  };
  setContext(SharedLayoutContext, sc);
  setDomContext("SharedLayout", isCustom, sc);
  onMount(() => {
    hasMounted = true;
  });
  const writable_props = ["type", "isCustom"];
  Object.keys($$props).forEach((key) => {
    if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$" && key !== "slot")
      console.warn(`<AnimateSharedLayout> was created with unknown prop '${key}'`);
  });
  $$self.$$set = ($$props2) => {
    if ("type" in $$props2)
      $$invalidate(0, type = $$props2.type);
    if ("isCustom" in $$props2)
      $$invalidate(1, isCustom = $$props2.isCustom);
    if ("$$scope" in $$props2)
      $$invalidate(3, $$scope = $$props2.$$scope);
  };
  $$self.$capture_state = () => ({
    Presence,
    createBatcher,
    SharedLayoutContext,
    layoutStack,
    resetRotate,
    getContext,
    onMount,
    setContext,
    tick,
    get: get_store_value,
    writable,
    MotionContext,
    snapshotViewportBox,
    setDomContext,
    type,
    isCustom,
    context,
    hasMounted,
    children,
    stacks,
    updateScheduled,
    renderScheduled,
    forced,
    syncContext,
    startLayoutAnimation,
    updateStacks,
    scheduleUpdate,
    addChild,
    removeChild,
    addToStack,
    removeFromStack,
    getStack,
    sc,
    setSyncContext
  });
  $$self.$inject_state = ($$props2) => {
    if ("type" in $$props2)
      $$invalidate(0, type = $$props2.type);
    if ("isCustom" in $$props2)
      $$invalidate(1, isCustom = $$props2.isCustom);
    if ("hasMounted" in $$props2)
      hasMounted = $$props2.hasMounted;
    if ("children" in $$props2)
      children = $$props2.children;
    if ("stacks" in $$props2)
      stacks = $$props2.stacks;
    if ("updateScheduled" in $$props2)
      updateScheduled = $$props2.updateScheduled;
    if ("renderScheduled" in $$props2)
      $$invalidate(2, renderScheduled = $$props2.renderScheduled);
    if ("forced" in $$props2)
      forced = $$props2.forced;
    if ("syncContext" in $$props2)
      syncContext = $$props2.syncContext;
    if ("sc" in $$props2)
      sc = $$props2.sc;
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$self.$$.update = () => {
    if ($$self.$$.dirty & /*renderScheduled*/
    4) {
      $:
        if (renderScheduled) {
          tick().then(() => {
            startLayoutAnimation();
          });
        }
    }
  };
  return [type, isCustom, renderScheduled, $$scope, slots];
}
var AnimateSharedLayout = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance, create_fragment, safe_not_equal, { type: 0, isCustom: 1 });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "AnimateSharedLayout",
      options,
      id: create_fragment.name
    });
  }
  get type() {
    throw new Error("<AnimateSharedLayout>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set type(value) {
    throw new Error("<AnimateSharedLayout>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get isCustom() {
    throw new Error("<AnimateSharedLayout>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set isCustom(value) {
    throw new Error("<AnimateSharedLayout>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var AnimateSharedLayout_default = AnimateSharedLayout;
export {
  AnimateSharedLayout_default as default
};
//# sourceMappingURL=svelte-motion_src_components_AnimateSharedLayout_AnimateSharedLayout__svelte.js.map
