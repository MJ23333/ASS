{
  "version": 3,
  "sources": ["../../svelte-motion/src/context/MotionContext/MotionContext.svelte", "../../svelte-motion/src/components/AnimateSharedLayout/types.js", "../../svelte-motion/src/utils/noop.js", "../../svelte-motion/src/utils/geometry/index.js", "../../svelte-motion/src/render/utils/compare-by-depth.js", "../../svelte-motion/src/render/dom/projection/utils.js", "../../svelte-motion/src/render/dom/utils/batch-layout.js", "../../svelte-motion/src/components/AnimateSharedLayout/utils/batcher.js", "../../svelte-motion/src/context/SharedLayoutContext.js", "../../svelte-motion/src/render/html/utils/transform.js", "../../svelte-motion/src/utils/is-ref-object.js", "../../svelte-motion/src/utils/fix-process-env.js", "../../svelte-motion/src/gestures/utils/event-type.js", "../../svelte-motion/src/events/event-info.js", "../../svelte-motion/src/utils/time-conversion.js", "../../svelte-motion/src/utils/is-browser.js", "../../svelte-motion/src/events/utils.js", "../../svelte-motion/src/events/UseDomEvent.svelte", "../../svelte-motion/src/events/UsePointerEvent.svelte", "../../svelte-motion/src/gestures/PanSession.js", "../../svelte-motion/src/gestures/drag/utils/lock.js", "../../svelte-motion/src/utils/each-axis.js", "../../svelte-motion/src/gestures/drag/utils/constraints.js", "../../svelte-motion/src/render/dom/projection/measure.js", "../../svelte-motion/src/utils/geometry/delta-calc.js", "../../svelte-motion/src/animation/utils/easing.js", "../../svelte-motion/src/animation/utils/is-animatable.js", "../../svelte-motion/src/animation/utils/is-keyframes-target.js", "../../svelte-motion/src/animation/utils/default-transitions.js", "../../svelte-motion/src/render/dom/value-types/type-int.js", "../../svelte-motion/src/render/dom/value-types/number.js", "../../svelte-motion/src/render/dom/value-types/defaults.js", "../../svelte-motion/src/render/dom/value-types/animatable-none.js", "../../svelte-motion/src/animation/utils/transitions.js", "../../svelte-motion/src/render/utils/types.js", "../../svelte-motion/src/motion/features/layout/utils.js", "../../svelte-motion/src/render/utils/is-draggable.js", "../../svelte-motion/src/utils/geometry/delta-apply.js", "../../svelte-motion/src/render/dom/projection/convert-to-relative.js", "../../svelte-motion/src/gestures/drag/VisualElementDragControls.js", "../../svelte-motion/src/value/utils/is-motion-value.js", "../../svelte-motion/src/utils/array.js", "../../svelte-motion/src/utils/subscription-manager.js", "../../svelte-motion/src/value/index.js"],
  "sourcesContent": [null, "/** \nbased on framer-motion@4.0.3,\nCopyright (c) 2018 Framer B.V.\n*/\n\n/**\n * @public\n */\nvar Presence;\n(function (Presence) {\n    Presence[Presence[\"Entering\"] = 0] = \"Entering\";\n    Presence[Presence[\"Present\"] = 1] = \"Present\";\n    Presence[Presence[\"Exiting\"] = 2] = \"Exiting\";\n})(Presence || (Presence = {}));\n/**\n * @public\n */\nvar VisibilityAction;\n(function (VisibilityAction) {\n    VisibilityAction[VisibilityAction[\"Hide\"] = 0] = \"Hide\";\n    VisibilityAction[VisibilityAction[\"Show\"] = 1] = \"Show\";\n})(VisibilityAction || (VisibilityAction = {}));\n\nexport { Presence, VisibilityAction };\n", "/** \nbased on framer-motion@4.0.3,\nCopyright (c) 2018 Framer B.V.\n*/\nfunction noop(any) {\n    return any;\n}\n\nexport { noop };\n", "/** \nbased on framer-motion@4.1.15,\nCopyright (c) 2018 Framer B.V.\n*/\nimport { noop } from '../noop.js';\n\n/**\n * Bounding boxes tend to be defined as top, left, right, bottom. For various operations\n * it's easier to consider each axis individually. This function returns a bounding box\n * as a map of single-axis min/max values.\n */\nfunction convertBoundingBoxToAxisBox(_a) {\n    var top = _a.top, left = _a.left, right = _a.right, bottom = _a.bottom;\n    return {\n        x: { min: left, max: right },\n        y: { min: top, max: bottom },\n    };\n}\nfunction convertAxisBoxToBoundingBox(_a) {\n    var x = _a.x, y = _a.y;\n    return {\n        top: y.min,\n        bottom: y.max,\n        left: x.min,\n        right: x.max,\n    };\n}\n/**\n * Applies a TransformPoint function to a bounding box. TransformPoint is usually a function\n * provided by Framer to allow measured points to be corrected for device scaling. This is used\n * when measuring DOM elements and DOM event points.\n */\nfunction transformBoundingBox(_a, transformPoint) {\n    var top = _a.top, left = _a.left, bottom = _a.bottom, right = _a.right;\n    if (transformPoint === void 0) { transformPoint = noop; }\n    var topLeft = transformPoint({ x: left, y: top });\n    var bottomRight = transformPoint({ x: right, y: bottom });\n    return {\n        top: topLeft.y,\n        left: topLeft.x,\n        bottom: bottomRight.y,\n        right: bottomRight.x,\n    };\n}\n/**\n * Create an empty axis box of zero size\n */\nfunction axisBox() {\n    return { x: { min: 0, max: 1 }, y: { min: 0, max: 1 } };\n}\nfunction copyAxisBox(box) {\n    return {\n        x: Object.assign({}, box.x),\n        y: Object.assign({}, box.y),\n    };\n}\n/**\n * Create an empty box delta\n */\nvar zeroDelta = {\n    translate: 0,\n    scale: 1,\n    origin: 0,\n    originPoint: 0,\n};\nfunction delta() {\n    return {\n        x: Object.assign({}, zeroDelta),\n        y: Object.assign({}, zeroDelta),\n    };\n}\n\nexport { axisBox, convertAxisBoxToBoundingBox, convertBoundingBoxToAxisBox, copyAxisBox, delta, transformBoundingBox };\n", "/** \nbased on framer-motion@4.0.3,\nCopyright (c) 2018 Framer B.V.\n*/\nvar compareByDepth = function (a, b) {\n    return a.depth - b.depth;\n};\n\nexport { compareByDepth };\n", "/** \nbased on framer-motion@4.1.11,\nCopyright (c) 2018 Framer B.V.\n*/\n\nimport sync from 'framesync';\nimport { copyAxisBox } from '../../../utils/geometry/index.js';\nimport { compareByDepth } from '../../utils/compare-by-depth.js';\n\nfunction isProjecting(visualElement) {\n    var isEnabled = visualElement.projection.isEnabled;\n    return isEnabled || visualElement.shouldResetTransform();\n}\nfunction collectProjectingAncestors(visualElement, ancestors) {\n    if (ancestors === void 0) { ancestors = []; }\n    var parent = visualElement.parent;\n    if (parent)\n        collectProjectingAncestors(parent, ancestors);\n    if (isProjecting(visualElement))\n        ancestors.push(visualElement);\n    return ancestors;\n}\nfunction collectProjectingChildren(visualElement) {\n    var children = [];\n    var addChild = function (child) {\n        if (isProjecting(child))\n            children.push(child);\n        child.children.forEach(addChild);\n    };\n    visualElement.children.forEach(addChild);\n    return children.sort(compareByDepth);\n}\n/**\n * Update the layoutState by measuring the DOM layout. This\n * should be called after resetting any layout-affecting transforms.\n */\nfunction updateLayoutMeasurement(visualElement) {\n    if (visualElement.shouldResetTransform())\n        return;\n    var layoutState = visualElement.getLayoutState();\n    visualElement.notifyBeforeLayoutMeasure(layoutState.layout);\n    layoutState.isHydrated = true;\n    layoutState.layout = visualElement.measureViewportBox();\n    layoutState.layoutCorrected = copyAxisBox(layoutState.layout);\n    visualElement.notifyLayoutMeasure(layoutState.layout, visualElement.prevViewportBox || layoutState.layout);\n    sync.update(function () { return visualElement.rebaseProjectionTarget(); });\n}\n/**\n * Record the viewport box as it was before an expected mutation/re-render\n */\nfunction snapshotViewportBox(visualElement,nc) {\n    if (visualElement.shouldResetTransform())\n        return;\n    if (!nc) visualElement.prevViewportBox = visualElement.measureViewportBox(false);\n    /**\n     * Update targetBox to match the prevViewportBox. This is just to ensure\n     * that targetBox is affected by scroll in the same way as the measured box\n     */\n    visualElement.rebaseProjectionTarget(false, visualElement.prevViewportBox);\n}\n\nexport { collectProjectingAncestors, collectProjectingChildren, snapshotViewportBox, updateLayoutMeasurement };\n", "/** \nbased on framer-motion@4.1.15,\nCopyright (c) 2018 Framer B.V.\n*/\nimport sync from 'framesync';\n\nvar unresolvedJobs = new Set();\nvar layoutState = {\n    isMeasuringLayout: false,\n};\nfunction pushJob(stack, job, pointer) {\n    if (!stack[pointer])\n        stack[pointer] = [];\n    stack[pointer].push(job);\n}\nfunction batchLayout(callback) {\n    unresolvedJobs.add(callback);\n    return function () { return unresolvedJobs.delete(callback); };\n}\nfunction flushLayout() {\n    if (!unresolvedJobs.size)\n        return;\n    var pointer = 0;\n    var reads = [[]];\n    var writes = [];\n    var setRead = function (job) { return pushJob(reads, job, pointer); };\n    var setWrite = function (job) {\n        pushJob(writes, job, pointer);\n        pointer++;\n    };\n    /**\n     * Resolve jobs into their array stacks\n     */\n    unresolvedJobs.forEach(function (callback) {\n        callback(setRead, setWrite);\n        pointer = 0;\n    });\n    unresolvedJobs.clear();\n    /**\n     * Mark that we're currently measuring layouts. This allows us to, for instance, ignore\n     * hover events that might be triggered as a result of resetting transforms.\n     *\n     * The postRender/setTimeout combo seems like an odd bit of scheduling but what it's saying\n     * is *after* the next render, wait 10ms before re-enabling hover events. Waiting until the\n     * next frame completely will result in missed, valid hover events. But events seem to\n     * be fired async from their actual action, so setting this to false too soon can still\n     * trigger events from layout measurements.\n     *\n     * Note: If we figure out a way of measuring layout while transforms remain applied, this can be removed.\n     * I have attempted unregistering event listeners and setting CSS to pointer-events: none\n     * but neither seem to work as expected.\n     */\n    layoutState.isMeasuringLayout = true;\n    sync.postRender(function () {\n        setTimeout(function () { return (layoutState.isMeasuringLayout = false); }, 10);\n    });\n    /**\n     * Execute jobs\n     */\n    var numStacks = writes.length;\n    for (var i = 0; i <= numStacks; i++) {\n        reads[i] && reads[i].forEach(executeJob);\n        writes[i] && writes[i].forEach(executeJob);\n    }\n}\nvar executeJob = function (job) { return job(); };\n\nexport { batchLayout, flushLayout, layoutState };\n", "/** \nbased on framer-motion@4.1.15,\nCopyright (c) 2018 Framer B.V.\n*/\n\nimport { __spreadArray, __read } from 'tslib';\nimport sync, { flushSync } from 'framesync';\nimport { collectProjectingAncestors, updateLayoutMeasurement } from '../../../render/dom/projection/utils.js';\nimport { batchLayout, flushLayout } from '../../../render/dom/utils/batch-layout.js';\nimport { compareByDepth } from '../../../render/utils/compare-by-depth.js';\nimport { Presence } from '../types.js';\n\n/**\n * Default handlers for batching VisualElements\n */\nvar defaultHandler = {\n    layoutReady: function (child) { return child.notifyLayoutReady(); },\n};\n/**\n * Create a batcher to process VisualElements\n */\nfunction createBatcher() {\n    var queue = new Set();\n    return {\n        add: function (child) { return queue.add(child); },\n        flush: function (_a) {\n            var _b = _a === void 0 ? defaultHandler : _a, layoutReady = _b.layoutReady, parent = _b.parent;\n            batchLayout(function (read, write) {\n                var order = Array.from(queue).sort(compareByDepth);\n                var ancestors = parent\n                    ? collectProjectingAncestors(parent)\n                    : [];\n                write(function () {\n                    var allElements = __spreadArray(__spreadArray([], __read(ancestors)), __read(order));\n                    allElements.forEach(function (element) { return element.resetTransform(); });\n                });\n                read(function () {\n                    order.forEach(updateLayoutMeasurement);\n                });\n                write(function () {\n                    ancestors.forEach(function (element) { return element.restoreTransform(); });\n                    order.forEach(layoutReady);\n                });\n                read(function () {\n                    /**\n                     * After all children have started animating, ensure any Entering components are set to Present.\n                     * If we add deferred animations (set up all animations and then start them in two loops) this\n                     * could be moved to the start loop. But it needs to happen after all the animations configs\n                     * are generated in AnimateSharedLayout as this relies on presence data\n                     */\n                    order.forEach(function (child) {\n                        if (child.isPresent)\n                            child.presence = Presence.Present;\n                    });\n                });\n                write(function () {\n                    /**\n                     * Starting these animations will have queued jobs on the frame loop. In some situations,\n                     * like when removing an element, these will be processed too late after the DOM is manipulated,\n                     * leaving a flash of incorrectly-projected content. By manually flushing these jobs\n                     * we ensure there's no flash.\n                     */\n                    flushSync.preRender();\n                    flushSync.render();\n                });\n                read(function () {\n                    /**\n                     * Schedule a callback at the end of the following frame to assign the latest projection\n                     * box to the prevViewportBox snapshot. Once global batching is in place this could be run\n                     * synchronously. But for now it ensures that if any nested `AnimateSharedLayout` top-level\n                     * child attempts to calculate its previous relative position against a prevViewportBox\n                     * it will be against its latest projection box instead, as the snapshot is useless beyond this\n                     * render.\n                     */\n                    sync.postRender(function () {\n                        return order.forEach(assignProjectionToSnapshot);\n                    });\n                    queue.clear();\n                });\n            });\n            // TODO: Need to find a layout-synchronous way of flushing this\n            flushLayout();\n        },\n    };\n}\nfunction assignProjectionToSnapshot(child) {\n    child.prevViewportBox = child.projection.target;\n}\n\nexport { createBatcher };\n", "/** \nbased on framer-motion@4.0.3,\nCopyright (c) 2018 Framer B.V.\n*/\n\nimport { writable } from 'svelte/store';\nimport { createBatcher } from '../components/AnimateSharedLayout/utils/batcher.js';\nimport { getDomContext } from './DOMcontext.js';\n\nvar SharedLayoutContext = (custom) => getDomContext(\"SharedLayout\",custom)||writable(createBatcher());\n/**\n * @internal\n */\nvar FramerTreeLayoutContext = ()=> writable(createBatcher());\n\nfunction isSharedLayout(context) {\n    return !!context.forceUpdate;\n}\n\nexport { FramerTreeLayoutContext, SharedLayoutContext, isSharedLayout };\n", "/** \nbased on framer-motion@4.0.3,\nCopyright (c) 2018 Framer B.V.\n*/\n\n/**\n * A list of all transformable axes. We'll use this list to generated a version\n * of each axes for each transform.\n */\nvar transformAxes = [\"\", \"X\", \"Y\", \"Z\"];\n/**\n * An ordered array of each transformable value. By default, transform values\n * will be sorted to this order.\n */\nvar order = [\"translate\", \"scale\", \"rotate\", \"skew\"];\n/**\n * Generate a list of every possible transform key.\n */\nvar transformProps = [\"transformPerspective\", \"x\", \"y\", \"z\"];\norder.forEach(function (operationKey) {\n    return transformAxes.forEach(function (axesKey) {\n        return transformProps.push(operationKey + axesKey);\n    });\n});\n/**\n * A function to use with Array.sort to sort transform keys by their default order.\n */\nfunction sortTransformProps(a, b) {\n    return transformProps.indexOf(a) - transformProps.indexOf(b);\n}\n/**\n * A quick lookup for transform props.\n */\nvar transformPropSet = new Set(transformProps);\nfunction isTransformProp(key) {\n    return transformPropSet.has(key);\n}\n/**\n * A quick lookup for transform origin props\n */\nvar transformOriginProps = new Set([\"originX\", \"originY\", \"originZ\"]);\nfunction isTransformOriginProp(key) {\n    return transformOriginProps.has(key);\n}\n\nexport { isTransformOriginProp, isTransformProp, sortTransformProps, transformAxes, transformProps };\n", "/** \nbased on framer-motion@4.0.3,\nCopyright (c) 2018 Framer B.V.\n*/\nfunction isRefObject(ref) {\n    return (typeof ref === \"object\" &&\n        Object.prototype.hasOwnProperty.call(ref, \"current\"));\n}\n\nexport { isRefObject };\n", "\nconst fix = ()=>{\n    try{\n        \n        if (!process.env){\n            process.env={};\n        }\n        return true;;\n    }catch(e){}\n    \n    if (!window || (window.process && window.process.env)){\n        return false;\n    }\n    \n    if (!window.process){\n        window.process={}\n    }\n    window.process.env={};\n    return true;    \n}\n\nexport const fixed = fix();", "/** \nbased on framer-motion@4.0.3,\nCopyright (c) 2018 Framer B.V.\n*/\n\nfunction isMouseEvent(event) {\n    // PointerEvent inherits from MouseEvent so we can't use a straight instanceof check.\n    if (typeof PointerEvent !== \"undefined\" && event instanceof PointerEvent) {\n        return !!(event.pointerType === \"mouse\");\n    }\n    return event instanceof MouseEvent;\n}\nfunction isTouchEvent(event) {\n    var hasTouches = !!event.touches;\n    return hasTouches;\n}\n\nexport { isMouseEvent, isTouchEvent };\n", "/** \nbased on framer-motion@4.0.3,\nCopyright (c) 2018 Framer B.V.\n*/\n\nimport { isTouchEvent } from '../gestures/utils/event-type.js';\n\n/**\n * Filters out events not attached to the primary pointer (currently left mouse button)\n * @param eventHandler\n */\nfunction filterPrimaryPointer(eventHandler) {\n    return function (event) {\n        var isMouseEvent = event instanceof MouseEvent;\n        var isPrimaryPointer = !isMouseEvent ||\n            (isMouseEvent && event.button === 0);\n        if (isPrimaryPointer) {\n            eventHandler(event);\n        }\n    };\n}\nvar defaultPagePoint = { pageX: 0, pageY: 0 };\nfunction pointFromTouch(e, pointType) {\n    if (pointType === void 0) { pointType = \"page\"; }\n    var primaryTouch = e.touches[0] || e.changedTouches[0];\n    var point = primaryTouch || defaultPagePoint;\n    return {\n        x: point[pointType + \"X\"],\n        y: point[pointType + \"Y\"],\n    };\n}\nfunction pointFromMouse(point, pointType) {\n    if (pointType === void 0) { pointType = \"page\"; }\n    return {\n        x: point[pointType + \"X\"],\n        y: point[pointType + \"Y\"],\n    };\n}\nfunction extractEventInfo(event, pointType) {\n    if (pointType === void 0) { pointType = \"page\"; }\n    return {\n        point: isTouchEvent(event)\n            ? pointFromTouch(event, pointType)\n            : pointFromMouse(event, pointType),\n    };\n}\nfunction getViewportPointFromEvent(event) {\n    return extractEventInfo(event, \"client\");\n}\nvar wrapHandler = function (handler, shouldFilterPrimaryPointer) {\n    if (shouldFilterPrimaryPointer === void 0) { shouldFilterPrimaryPointer = false; }\n    var listener = function (event) {\n        return handler(event, extractEventInfo(event));\n    };\n    return shouldFilterPrimaryPointer\n        ? filterPrimaryPointer(listener)\n        : listener;\n};\n\nexport { extractEventInfo, getViewportPointFromEvent, wrapHandler };\n", "/** \nbased on framer-motion@4.0.3,\nCopyright (c) 2018 Framer B.V.\n*/\n/**\n * Converts seconds to milliseconds\n *\n * @param seconds - Time in seconds.\n * @return milliseconds - Converted time in milliseconds.\n */\nvar secondsToMilliseconds = function (seconds) { return seconds * 1000; };\n\nexport { secondsToMilliseconds };\n", "/** \nbased on framer-motion@4.0.3,\nCopyright (c) 2018 Framer B.V.\n*/\nvar isBrowser = typeof window !== \"undefined\";\n\nexport { isBrowser };\n", "/** \nbased on framer-motion@4.0.3,\nCopyright (c) 2018 Framer B.V.\n*/\n\nimport { isBrowser } from '../utils/is-browser.js';\n\n// We check for event support via functions in case they've been mocked by a testing suite.\nvar supportsPointerEvents = function () {\n    return isBrowser && window.onpointerdown === null;\n};\nvar supportsTouchEvents = function () {\n    return isBrowser && window.ontouchstart === null;\n};\nvar supportsMouseEvents = function () {\n    return isBrowser && window.onmousedown === null;\n};\n\nexport { supportsMouseEvents, supportsPointerEvents, supportsTouchEvents };\n", null, null, "/** \nbased on framer-motion@4.0.3,\nCopyright (c) 2018 Framer B.V.\n*/\nimport {fixed} from '../utils/fix-process-env';\nimport { isMouseEvent, isTouchEvent } from './utils/event-type.js';\nimport { extractEventInfo } from '../events/event-info.js';\nimport sync, { getFrameData, cancelSync } from 'framesync';\nimport { secondsToMilliseconds } from '../utils/time-conversion.js';\nimport { addPointerEvent } from '../events/use-pointer-event.js';\nimport { distance, pipe } from 'popmotion';\n\n/**\n * @internal\n */\nvar PanSession = /** @class */ (function () {\n    function PanSession(event, handlers, _a) {\n        var _this = this;\n        var _b = _a === void 0 ? {} : _a, transformPagePoint = _b.transformPagePoint;\n        /**\n         * @internal\n         */\n        this.startEvent = null;\n        /**\n         * @internal\n         */\n        this.lastMoveEvent = null;\n        /**\n         * @internal\n         */\n        this.lastMoveEventInfo = null;\n        /**\n         * @internal\n         */\n        this.handlers = {};\n        this.updatePoint = function () {\n            if (!(_this.lastMoveEvent && _this.lastMoveEventInfo))\n                return;\n            var info = getPanInfo(_this.lastMoveEventInfo, _this.history);\n            var isPanStarted = _this.startEvent !== null;\n            // Only start panning if the offset is larger than 3 pixels. If we make it\n            // any larger than this we'll want to reset the pointer history\n            // on the first update to avoid visual snapping to the cursoe.\n            var isDistancePastThreshold = distance(info.offset, { x: 0, y: 0 }) >= 3;\n            if (!isPanStarted && !isDistancePastThreshold)\n                return;\n            var point = info.point;\n            var timestamp = getFrameData().timestamp;\n            _this.history.push(Object.assign(Object.assign({}, point), { timestamp: timestamp }));\n            var _a = _this.handlers, onStart = _a.onStart, onMove = _a.onMove;\n            if (!isPanStarted) {\n                onStart && onStart(_this.lastMoveEvent, info);\n                _this.startEvent = _this.lastMoveEvent;\n            }\n            onMove && onMove(_this.lastMoveEvent, info);\n        };\n        this.handlePointerMove = function (event, info) {\n            _this.lastMoveEvent = event;\n            _this.lastMoveEventInfo = transformPoint(info, _this.transformPagePoint);\n            // Because Safari doesn't trigger mouseup events when it's above a `<select>`\n            if (isMouseEvent(event) && event.buttons === 0) {\n                _this.handlePointerUp(event, info);\n                return;\n            }\n            // Throttle mouse move event to once per frame\n            sync.update(_this.updatePoint, true);\n        };\n        this.handlePointerUp = function (event, info) {\n            _this.end();\n            var _a = _this.handlers, onEnd = _a.onEnd, onSessionEnd = _a.onSessionEnd;\n            var panInfo = getPanInfo(transformPoint(info, _this.transformPagePoint), _this.history);\n            if (_this.startEvent && onEnd) {\n                onEnd(event, panInfo);\n            }\n            onSessionEnd && onSessionEnd(event, panInfo);\n        };\n        // If we have more than one touch, don't start detecting this gesture\n        if (isTouchEvent(event) && event.touches.length > 1)\n            return;\n        this.handlers = handlers;\n        this.transformPagePoint = transformPagePoint;\n        var info = extractEventInfo(event);\n        var initialInfo = transformPoint(info, this.transformPagePoint);\n        var point = initialInfo.point;\n        var timestamp = getFrameData().timestamp;\n        this.history = [Object.assign(Object.assign({}, point), { timestamp: timestamp })];\n        var onSessionStart = handlers.onSessionStart;\n        onSessionStart &&\n            onSessionStart(event, getPanInfo(initialInfo, this.history));\n        this.removeListeners = pipe(addPointerEvent(window, \"pointermove\", this.handlePointerMove), addPointerEvent(window, \"pointerup\", this.handlePointerUp), addPointerEvent(window, \"pointercancel\", this.handlePointerUp));\n    }\n    PanSession.prototype.updateHandlers = function (handlers) {\n        this.handlers = handlers;\n    };\n    PanSession.prototype.end = function () {\n        this.removeListeners && this.removeListeners();\n        cancelSync.update(this.updatePoint);\n    };\n    return PanSession;\n}());\nfunction transformPoint(info, transformPagePoint) {\n    return transformPagePoint ? { point: transformPagePoint(info.point) } : info;\n}\nfunction subtractPoint(a, b) {\n    return { x: a.x - b.x, y: a.y - b.y };\n}\nfunction getPanInfo(_a, history) {\n    var point = _a.point;\n    return {\n        point: point,\n        delta: subtractPoint(point, lastDevicePoint(history)),\n        offset: subtractPoint(point, startDevicePoint(history)),\n        velocity: getVelocity(history, 0.1),\n    };\n}\nfunction startDevicePoint(history) {\n    return history[0];\n}\nfunction lastDevicePoint(history) {\n    return history[history.length - 1];\n}\nfunction getVelocity(history, timeDelta) {\n    if (history.length < 2) {\n        return { x: 0, y: 0 };\n    }\n    var i = history.length - 1;\n    var timestampedPoint = null;\n    var lastPoint = lastDevicePoint(history);\n    while (i >= 0) {\n        timestampedPoint = history[i];\n        if (lastPoint.timestamp - timestampedPoint.timestamp >\n            secondsToMilliseconds(timeDelta)) {\n            break;\n        }\n        i--;\n    }\n    if (!timestampedPoint) {\n        return { x: 0, y: 0 };\n    }\n    var time = (lastPoint.timestamp - timestampedPoint.timestamp) / 1000;\n    if (time === 0) {\n        return { x: 0, y: 0 };\n    }\n    var currentVelocity = {\n        x: (lastPoint.x - timestampedPoint.x) / time,\n        y: (lastPoint.y - timestampedPoint.y) / time,\n    };\n    if (currentVelocity.x === Infinity) {\n        currentVelocity.x = 0;\n    }\n    if (currentVelocity.y === Infinity) {\n        currentVelocity.y = 0;\n    }\n    return currentVelocity;\n}\n\nexport { PanSession };\n", "/** \nbased on framer-motion@4.1.17,\nCopyright (c) 2018 Framer B.V.\n*/\n\nfunction createLock(name) {\n    var lock = null;\n    return function () {\n        var openLock = function () {\n            lock = null;\n        };\n        \n        if (lock === null) {\n            lock = name;\n            return openLock;\n        }\n        return false;\n    };\n}\nvar globalHorizontalLock = createLock(\"dragHorizontal\");\nvar globalVerticalLock = createLock(\"dragVertical\");\nfunction getGlobalLock(drag) {\n    var lock = false;\n    if (drag === \"y\") {\n        \n        lock = globalVerticalLock();\n    }\n    else if (drag === \"x\") {\n        \n        lock = globalHorizontalLock();\n    }\n    else {\n        var openHorizontal_1 = globalHorizontalLock();\n        var openVertical_1 = globalVerticalLock();\n        if (openHorizontal_1 && openVertical_1) {\n            lock = function () {\n                openHorizontal_1();\n                openVertical_1();\n            };\n        }\n        else {\n            // Release the locks because we don't use them\n            if (openHorizontal_1)\n                openHorizontal_1();\n            if (openVertical_1)\n                openVertical_1();\n        }\n    }\n    return lock;\n}\nfunction isDragActive() {\n    // Check the gesture lock - if we get it, it means no drag gesture is active\n    // and we can safely fire the tap gesture.\n    var openGestureLock = getGlobalLock(true);\n    if (!openGestureLock)\n        return true;\n    openGestureLock();\n    return false;\n}\n\nexport { createLock, getGlobalLock, isDragActive };\n", "/** \nbased on framer-motion@4.0.3,\nCopyright (c) 2018 Framer B.V.\n*/\n// Call a handler once for each axis\nfunction eachAxis(handler) {\n    return [handler(\"x\"), handler(\"y\")];\n}\n\nexport { eachAxis };\n", "/** \nbased on framer-motion@4.1.17,\nCopyright (c) 2018 Framer B.V.\n*/\nimport {fixed} from '../../../utils/fix-process-env';\nimport { __read } from 'tslib';\nimport { mix } from 'popmotion';\n\n/**\n * Apply constraints to a point. These constraints are both physical along an\n * axis, and an elastic factor that determines how much to constrain the point\n * by if it does lie outside the defined parameters.\n */\nfunction applyConstraints(point, _a, elastic) {\n    var min = _a.min, max = _a.max;\n    if (min !== undefined && point < min) {\n        // If we have a min point defined, and this is outside of that, constrain\n        point = elastic ? mix(min, point, elastic.min) : Math.max(point, min);\n    }\n    else if (max !== undefined && point > max) {\n        // If we have a max point defined, and this is outside of that, constrain\n        point = elastic ? mix(max, point, elastic.max) : Math.min(point, max);\n    }\n    return point;\n}\n/**\n * Calculates a min projection point based on a pointer, pointer progress\n * within the drag target, and constraints.\n *\n * For instance if an element was 100px width, we were dragging from 0.25\n * along this axis, the pointer is at 200px, and there were no constraints,\n * we would calculate a min projection point of 175px.\n */\nfunction calcConstrainedMinPoint(point, length, progress, constraints, elastic) {\n    // Calculate a min point for this axis and apply it to the current pointer\n    var min = point - length * progress;\n    return constraints ? applyConstraints(min, constraints, elastic) : min;\n}\n/**\n * Calculate constraints in terms of the viewport when defined relatively to the\n * measured axis. This is measured from the nearest edge, so a max constraint of 200\n * on an axis with a max value of 300 would return a constraint of 500 - axis length\n */\nfunction calcRelativeAxisConstraints(axis, min, max) {\n    return {\n        min: min !== undefined ? axis.min + min : undefined,\n        max: max !== undefined\n            ? axis.max + max - (axis.max - axis.min)\n            : undefined,\n    };\n}\n/**\n * Calculate constraints in terms of the viewport when\n * defined relatively to the measured bounding box.\n */\nfunction calcRelativeConstraints(layoutBox, _a) {\n    var top = _a.top, left = _a.left, bottom = _a.bottom, right = _a.right;\n    return {\n        x: calcRelativeAxisConstraints(layoutBox.x, left, right),\n        y: calcRelativeAxisConstraints(layoutBox.y, top, bottom),\n    };\n}\n/**\n * Calculate viewport constraints when defined as another viewport-relative axis\n */\nfunction calcViewportAxisConstraints(layoutAxis, constraintsAxis) {\n    var _a;\n    var min = constraintsAxis.min - layoutAxis.min;\n    var max = constraintsAxis.max - layoutAxis.max;\n    // If the constraints axis is actually smaller than the layout axis then we can\n    // flip the constraints\n    if (constraintsAxis.max - constraintsAxis.min <\n        layoutAxis.max - layoutAxis.min) {\n        _a = __read([max, min], 2), min = _a[0], max = _a[1];\n    }\n    return {\n        min: layoutAxis.min + min,\n        max: layoutAxis.min + max,\n    };\n}\n/**\n * Calculate viewport constraints when defined as another viewport-relative box\n */\nfunction calcViewportConstraints(layoutBox, constraintsBox) {\n    return {\n        x: calcViewportAxisConstraints(layoutBox.x, constraintsBox.x),\n        y: calcViewportAxisConstraints(layoutBox.y, constraintsBox.y),\n    };\n}\n/**\n * Calculate the an axis position based on two axes and a progress value.\n */\nfunction calcPositionFromProgress(axis, constraints, progress) {\n    var axisLength = axis.max - axis.min;\n    var min = mix(constraints.min, constraints.max - axisLength, progress);\n    return { min: min, max: min + axisLength };\n}\n/**\n * Rebase the calculated viewport constraints relative to the layout.min point.\n */\nfunction rebaseAxisConstraints(layout, constraints) {\n    var relativeConstraints = {};\n    if (constraints.min !== undefined) {\n        relativeConstraints.min = constraints.min - layout.min;\n    }\n    if (constraints.max !== undefined) {\n        relativeConstraints.max = constraints.max - layout.min;\n    }\n    return relativeConstraints;\n}\nvar defaultElastic = 0.35;\n/**\n * Accepts a dragElastic prop and returns resolved elastic values for each axis.\n */\nfunction resolveDragElastic(dragElastic) {\n    if (dragElastic === false) {\n        dragElastic = 0;\n    }\n    else if (dragElastic === true) {\n        dragElastic = defaultElastic;\n    }\n    return {\n        x: resolveAxisElastic(dragElastic, \"left\", \"right\"),\n        y: resolveAxisElastic(dragElastic, \"top\", \"bottom\"),\n    };\n}\nfunction resolveAxisElastic(dragElastic, minLabel, maxLabel) {\n    return {\n        min: resolvePointElastic(dragElastic, minLabel),\n        max: resolvePointElastic(dragElastic, maxLabel),\n    };\n}\nfunction resolvePointElastic(dragElastic, label) {\n    var _a;\n    return typeof dragElastic === \"number\"\n        ? dragElastic\n        : (_a = dragElastic[label]) !== null && _a !== void 0 ? _a : 0;\n}\n\nexport { applyConstraints, calcConstrainedMinPoint, calcPositionFromProgress, calcRelativeAxisConstraints, calcRelativeConstraints, calcViewportAxisConstraints, calcViewportConstraints, defaultElastic, rebaseAxisConstraints, resolveAxisElastic, resolveDragElastic, resolvePointElastic };\n", "/** \nbased on framer-motion@4.0.3,\nCopyright (c) 2018 Framer B.V.\n*/\nimport { convertBoundingBoxToAxisBox, transformBoundingBox } from '../../../utils/geometry/index.js';\n\n/**\n * Measure and return the element bounding box.\n *\n * We convert the box into an AxisBox2D to make it easier to work with each axis\n * individually and programmatically.\n *\n * This function optionally accepts a transformPagePoint function which allows us to compensate\n * for, for instance, measuring the element within a scaled plane like a Framer devivce preview component.\n */\nfunction getBoundingBox(element, transformPagePoint) {\n    var box = element.getBoundingClientRect();\n    return convertBoundingBoxToAxisBox(transformBoundingBox(box, transformPagePoint));\n}\n\nexport { getBoundingBox };\n", "/** \nbased on framer-motion@4.1.15,\nCopyright (c) 2018 Framer B.V.\n*/\nimport {fixed} from '../../utils/fix-process-env';\nimport { mix, distance, clamp, progress } from 'popmotion';\n\nvar clampProgress = function (v) { return clamp(0, 1, v); };\n/**\n * Returns true if the provided value is within maxDistance of the provided target\n */\nfunction isNear(value, target, maxDistance) {\n    if (target === void 0) { target = 0; }\n    if (maxDistance === void 0) { maxDistance = 0.01; }\n    return distance(value, target) < maxDistance;\n}\nfunction calcLength(axis) {\n    return axis.max - axis.min;\n}\n/**\n * Calculate a transform origin relative to the source axis, between 0-1, that results\n * in an asthetically pleasing scale/transform needed to project from source to target.\n */\nfunction calcOrigin(source, target) {\n    var origin = 0.5;\n    var sourceLength = calcLength(source);\n    var targetLength = calcLength(target);\n    if (targetLength > sourceLength) {\n        origin = progress(target.min, target.max - sourceLength, source.min);\n    }\n    else if (sourceLength > targetLength) {\n        origin = progress(source.min, source.max - targetLength, target.min);\n    }\n    return clampProgress(origin);\n}\n/**\n * Update the AxisDelta with a transform that projects source into target.\n *\n * The transform `origin` is optional. If not provided, it'll be automatically\n * calculated based on the relative positions of the two bounding boxes.\n */\nfunction updateAxisDelta(delta, source, target, origin) {\n    if (origin === void 0) { origin = 0.5; }\n    delta.origin = origin;\n    delta.originPoint = mix(source.min, source.max, delta.origin);\n    delta.scale = calcLength(target) / calcLength(source);\n    if (isNear(delta.scale, 1, 0.0001))\n        delta.scale = 1;\n    delta.translate =\n        mix(target.min, target.max, delta.origin) - delta.originPoint;\n    if (isNear(delta.translate))\n        delta.translate = 0;\n}\n/**\n * Update the BoxDelta with a transform that projects the source into the target.\n *\n * The transform `origin` is optional. If not provided, it'll be automatically\n * calculated based on the relative positions of the two bounding boxes.\n */\nfunction updateBoxDelta(delta, source, target, origin) {\n    updateAxisDelta(delta.x, source.x, target.x, defaultOrigin(origin.originX));\n    updateAxisDelta(delta.y, source.y, target.y, defaultOrigin(origin.originY));\n}\n/**\n * Currently this only accepts numerical origins, measured as 0-1, but could\n * accept pixel values by comparing to the target axis.\n */\nfunction defaultOrigin(origin) {\n    return typeof origin === \"number\" ? origin : 0.5;\n}\nfunction calcRelativeAxis(target, relative, parent) {\n    target.min = parent.min + relative.min;\n    target.max = target.min + calcLength(relative);\n}\nfunction calcRelativeBox(projection, parentProjection) {\n    calcRelativeAxis(projection.target.x, projection.relativeTarget.x, parentProjection.target.x);\n    calcRelativeAxis(projection.target.y, projection.relativeTarget.y, parentProjection.target.y);\n}\n\nexport { calcOrigin, calcRelativeAxis, calcRelativeBox, isNear, updateAxisDelta, updateBoxDelta };\n", "\n/** \nbased on framer-motion@4.0.3,\nCopyright (c) 2018 Framer B.V.\n*/\nimport {fixed} from '../../utils/fix-process-env';\nimport { __read } from 'tslib';\nimport { cubicBezier, linear, easeIn, easeInOut, easeOut, circIn, circInOut, circOut, backIn, backInOut, backOut, anticipate, bounceIn, bounceInOut, bounceOut } from 'popmotion';\n//import { invariant } from 'hey-listen';\n\nvar easingLookup = {\n    linear: linear,\n    easeIn: easeIn,\n    easeInOut: easeInOut,\n    easeOut: easeOut,\n    circIn: circIn,\n    circInOut: circInOut,\n    circOut: circOut,\n    backIn: backIn,\n    backInOut: backInOut,\n    backOut: backOut,\n    anticipate: anticipate,\n    bounceIn: bounceIn,\n    bounceInOut: bounceInOut,\n    bounceOut: bounceOut,\n};\nvar easingDefinitionToFunction = function (definition) {\n    if (Array.isArray(definition)) {\n        // If cubic bezier definition, create bezier curve\n        //invariant(definition.length === 4, \"Cubic bezier arrays must contain four numerical values.\");\n        var _a = __read(definition, 4), x1 = _a[0], y1 = _a[1], x2 = _a[2], y2 = _a[3];\n        return cubicBezier(x1, y1, x2, y2);\n    }\n    else if (typeof definition === \"string\") {\n        // Else lookup from table\n        //invariant(easingLookup[definition] !== undefined, \"Invalid easing type '\" + definition + \"'\");\n        return easingLookup[definition];\n    }\n    return definition;\n};\nvar isEasingArray = function (ease) {\n    return Array.isArray(ease) && typeof ease[0] !== \"number\";\n};\n\nexport { easingDefinitionToFunction, isEasingArray };\n", "/** \nbased on framer-motion@4.0.3,\nCopyright (c) 2018 Framer B.V.\n*/\nimport {fixed} from '../../utils/fix-process-env';\nimport { complex } from 'style-value-types';\n\n/**\n * Check if a value is animatable. Examples:\n *\n * ✅: 100, \"100px\", \"#fff\"\n * ❌: \"block\", \"url(2.jpg)\"\n * @param value\n *\n * @internal\n */\nvar isAnimatable = function (key, value) {\n    // If the list of keys tat might be non-animatable grows, replace with Set\n    if (key === \"zIndex\")\n        return false;\n    // If it's a number or a keyframes array, we can animate it. We might at some point\n    // need to do a deep isAnimatable check of keyframes, or let Popmotion handle this,\n    // but for now lets leave it like this for performance reasons\n    if (typeof value === \"number\" || Array.isArray(value))\n        return true;\n    if (typeof value === \"string\" && // It's animatable if we have a string\n        complex.test(value) && // And it contains numbers and/or colors\n        !value.startsWith(\"url(\") // Unless it starts with \"url(\"\n    ) {\n        return true;\n    }\n    return false;\n};\n\nexport { isAnimatable };\n", "/** \nbased on framer-motion@4.0.3,\nCopyright (c) 2018 Framer B.V.\n*/\n\nvar isKeyframesTarget = function (v) {\n    return Array.isArray(v);\n};\n\nexport { isKeyframesTarget };\n", "/** \nbased on framer-motion@4.0.3,\nCopyright (c) 2018 Framer B.V.\n*/\n\nimport { isKeyframesTarget } from './is-keyframes-target.js';\n\nvar underDampedSpring = function () { return ({\n    type: \"spring\",\n    stiffness: 500,\n    damping: 25,\n    restDelta: 0.5,\n    restSpeed: 10,\n}); };\nvar criticallyDampedSpring = function (to) { return ({\n    type: \"spring\",\n    stiffness: 550,\n    damping: to === 0 ? 2 * Math.sqrt(550) : 30,\n    restDelta: 0.01,\n    restSpeed: 10,\n}); };\nvar linearTween = function () { return ({\n    type: \"keyframes\",\n    ease: \"linear\",\n    duration: 0.3,\n}); };\nvar keyframes = function (values) { return ({\n    type: \"keyframes\",\n    duration: 0.8,\n    values: values,\n}); };\nvar defaultTransitions = {\n    x: underDampedSpring,\n    y: underDampedSpring,\n    z: underDampedSpring,\n    rotate: underDampedSpring,\n    rotateX: underDampedSpring,\n    rotateY: underDampedSpring,\n    rotateZ: underDampedSpring,\n    scaleX: criticallyDampedSpring,\n    scaleY: criticallyDampedSpring,\n    scale: criticallyDampedSpring,\n    opacity: linearTween,\n    backgroundColor: linearTween,\n    color: linearTween,\n    default: criticallyDampedSpring,\n};\nvar getDefaultTransition = function (valueKey, to) {\n    var transitionFactory;\n    if (isKeyframesTarget(to)) {\n        transitionFactory = keyframes;\n    }\n    else {\n        transitionFactory =\n            defaultTransitions[valueKey] || defaultTransitions.default;\n    }\n    return Object.assign({ to: to }, transitionFactory(to));\n};\n\nexport { criticallyDampedSpring, getDefaultTransition, linearTween, underDampedSpring };\n", "/** \nbased on framer-motion@4.0.3,\nCopyright (c) 2018 Framer B.V.\n*/\nimport {fixed} from '../../../utils/fix-process-env';\nimport { number } from 'style-value-types';\n\nvar int = Object.assign(Object.assign({}, number), { transform: Math.round });\n\nexport { int };\n", "/** \nbased on framer-motion@4.0.3,\nCopyright (c) 2018 Framer B.V.\n*/\nimport {fixed} from '../../../utils/fix-process-env';\nimport { px, degrees, scale, alpha, progressPercentage } from 'style-value-types';\nimport { int } from './type-int.js';\n\nvar numberValueTypes = {\n    // Border props\n    borderWidth: px,\n    borderTopWidth: px,\n    borderRightWidth: px,\n    borderBottomWidth: px,\n    borderLeftWidth: px,\n    borderRadius: px,\n    radius: px,\n    borderTopLeftRadius: px,\n    borderTopRightRadius: px,\n    borderBottomRightRadius: px,\n    borderBottomLeftRadius: px,\n    // Positioning props\n    width: px,\n    maxWidth: px,\n    height: px,\n    maxHeight: px,\n    size: px,\n    top: px,\n    right: px,\n    bottom: px,\n    left: px,\n    // Spacing props\n    padding: px,\n    paddingTop: px,\n    paddingRight: px,\n    paddingBottom: px,\n    paddingLeft: px,\n    margin: px,\n    marginTop: px,\n    marginRight: px,\n    marginBottom: px,\n    marginLeft: px,\n    // Transform props\n    rotate: degrees,\n    rotateX: degrees,\n    rotateY: degrees,\n    rotateZ: degrees,\n    scale: scale,\n    scaleX: scale,\n    scaleY: scale,\n    scaleZ: scale,\n    skew: degrees,\n    skewX: degrees,\n    skewY: degrees,\n    distance: px,\n    translateX: px,\n    translateY: px,\n    translateZ: px,\n    x: px,\n    y: px,\n    z: px,\n    perspective: px,\n    transformPerspective: px,\n    opacity: alpha,\n    originX: progressPercentage,\n    originY: progressPercentage,\n    originZ: px,\n    // Misc\n    zIndex: int,\n    // SVG\n    fillOpacity: alpha,\n    strokeOpacity: alpha,\n    numOctaves: int,\n};\n\nexport { numberValueTypes };\n", "/** \nbased on framer-motion@4.0.3,\nCopyright (c) 2018 Framer B.V.\n*/\nimport {fixed} from '../../../utils/fix-process-env';\nimport { color, filter } from 'style-value-types';\nimport { numberValueTypes } from './number.js';\n\n/**\n * A map of default value types for common values\n */\nvar defaultValueTypes = Object.assign(Object.assign({}, numberValueTypes), { \n    // Color props\n    color: color, backgroundColor: color, outlineColor: color, fill: color, stroke: color, \n    // Border props\n    borderColor: color, borderTopColor: color, borderRightColor: color, borderBottomColor: color, borderLeftColor: color, filter: filter, WebkitFilter: filter });\n/**\n * Gets the default ValueType for the provided value key\n */\nvar getDefaultValueType = function (key) { return defaultValueTypes[key]; };\n\nexport { defaultValueTypes, getDefaultValueType };\n", "/** \nbased on framer-motion@4.0.3,\nCopyright (c) 2018 Framer B.V.\n*/\nimport {fixed} from '../../../utils/fix-process-env';\nimport { filter, complex } from 'style-value-types';\nimport { getDefaultValueType } from './defaults.js';\n\nfunction getAnimatableNone(key, value) {\n    var _a;\n    var defaultValueType = getDefaultValueType(key);\n    if (defaultValueType !== filter)\n        defaultValueType = complex;\n    // If value is not recognised as animatable, ie \"none\", create an animatable version origin based on the target\n    return (_a = defaultValueType.getAnimatableNone) === null || _a === void 0 ? void 0 : _a.call(defaultValueType, value);\n}\n\nexport { getAnimatableNone };\n", "/** \nbased on framer-motion@4.1.15,\nCopyright (c) 2018 Framer B.V.\n*/\nimport {fixed} from '../../utils/fix-process-env';\nimport { __rest, __spreadArray, __read } from 'tslib';\nimport { inertia, animate } from 'popmotion';\nimport { secondsToMilliseconds } from '../../utils/time-conversion.js';\nimport { isEasingArray, easingDefinitionToFunction } from './easing.js';\nimport { isAnimatable } from './is-animatable.js';\nimport { getDefaultTransition } from './default-transitions.js';\nimport { warning } from 'hey-listen';\nimport { getAnimatableNone } from '../../render/dom/value-types/animatable-none.js';\n\n/**\n * Decide whether a transition is defined on a given Transition.\n * This filters out orchestration options and returns true\n * if any options are left.\n */\nfunction isTransitionDefined(_a) {\n    _a.when; _a.delay; _a.delayChildren; _a.staggerChildren; _a.staggerDirection; _a.repeat; _a.repeatType; _a.repeatDelay; _a.from; var transition = __rest(_a, [\"when\", \"delay\", \"delayChildren\", \"staggerChildren\", \"staggerDirection\", \"repeat\", \"repeatType\", \"repeatDelay\", \"from\"]);\n    return !!Object.keys(transition).length;\n}\nvar legacyRepeatWarning = false;\n/**\n * Convert Framer Motion's Transition type into Popmotion-compatible options.\n */\nfunction convertTransitionToAnimationOptions(_a) {\n    var ease = _a.ease, times = _a.times, yoyo = _a.yoyo, flip = _a.flip, loop = _a.loop, transition = __rest(_a, [\"ease\", \"times\", \"yoyo\", \"flip\", \"loop\"]);\n    var options = Object.assign({}, transition);\n    if (times)\n        options[\"offset\"] = times;\n    /**\n     * Convert any existing durations from seconds to milliseconds\n     */\n    if (transition.duration)\n        options[\"duration\"] = secondsToMilliseconds(transition.duration);\n    if (transition.repeatDelay)\n        options.repeatDelay = secondsToMilliseconds(transition.repeatDelay);\n    /**\n     * Map easing names to Popmotion's easing functions\n     */\n    if (ease) {\n        options[\"ease\"] = isEasingArray(ease)\n            ? ease.map(easingDefinitionToFunction)\n            : easingDefinitionToFunction(ease);\n    }\n    /**\n     * Support legacy transition API\n     */\n    if (transition.type === \"tween\")\n        options.type = \"keyframes\";\n    /**\n     * TODO: These options are officially removed from the API.\n     */\n    if (yoyo || loop || flip) {\n        warning(!legacyRepeatWarning, \"yoyo, loop and flip have been removed from the API. Replace with repeat and repeatType options.\");\n        legacyRepeatWarning = true;\n        if (yoyo) {\n            options.repeatType = \"reverse\";\n        }\n        else if (loop) {\n            options.repeatType = \"loop\";\n        }\n        else if (flip) {\n            options.repeatType = \"mirror\";\n        }\n        options.repeat = loop || yoyo || flip || transition.repeat;\n    }\n    /**\n     * TODO: Popmotion 9 has the ability to automatically detect whether to use\n     * a keyframes or spring animation, but does so by detecting velocity and other spring options.\n     * It'd be good to introduce a similar thing here.\n     */\n    if (transition.type !== \"spring\")\n        options.type = \"keyframes\";\n    return options;\n}\n/**\n * Get the delay for a value by checking Transition with decreasing specificity.\n */\nfunction getDelayFromTransition(transition, key) {\n    var _a;\n    var valueTransition = getValueTransition(transition, key) || {};\n    return (_a = valueTransition.delay) !== null && _a !== void 0 ? _a : 0;\n}\nfunction hydrateKeyframes(options) {\n    if (Array.isArray(options.to) && options.to[0] === null) {\n        options.to = __spreadArray([], __read(options.to));\n        options.to[0] = options.from;\n    }\n    return options;\n}\nfunction getPopmotionAnimationOptions(transition, options, key) {\n    var _a;\n    if (Array.isArray(options.to)) {\n        (_a = transition.duration) !== null && _a !== void 0 ? _a : (transition.duration = 0.8);\n    }\n    hydrateKeyframes(options);\n    /**\n     * Get a default transition if none is determined to be defined.\n     */\n    if (!isTransitionDefined(transition)) {\n        transition = Object.assign(Object.assign({}, transition), getDefaultTransition(key, options.to));\n    }\n    return Object.assign(Object.assign({}, options), convertTransitionToAnimationOptions(transition));\n}\n/**\n *\n */\nfunction getAnimation(key, value, target, transition, onComplete) {\n    var _a;\n    var valueTransition = getValueTransition(transition, key);\n    var origin = (_a = valueTransition.from) !== null && _a !== void 0 ? _a : value.get();\n    var isTargetAnimatable = isAnimatable(key, target);\n    if (origin === \"none\" && isTargetAnimatable && typeof target === \"string\") {\n        /**\n         * If we're trying to animate from \"none\", try and get an animatable version\n         * of the target. This could be improved to work both ways.\n         */\n        origin = getAnimatableNone(key, target);\n    }\n    else if (isZero(origin) && typeof target === \"string\") {\n        origin = getZeroUnit(target);\n    }\n    else if (!Array.isArray(target) &&\n        isZero(target) &&\n        typeof origin === \"string\") {\n        target = getZeroUnit(origin);\n    }\n    var isOriginAnimatable = isAnimatable(key, origin);\n    warning(isOriginAnimatable === isTargetAnimatable, \"You are trying to animate \" + key + \" from \\\"\" + origin + \"\\\" to \\\"\" + target + \"\\\". \" + origin + \" is not an animatable value - to enable this animation set \" + origin + \" to a value animatable to \" + target + \" via the `style` property.\");\n    function start() {\n        var options = {\n            from: origin,\n            to: target,\n            velocity: value.getVelocity(),\n            onComplete: onComplete,\n            onUpdate: function (v) { return value.set(v); },\n        };\n        return valueTransition.type === \"inertia\" ||\n            valueTransition.type === \"decay\"\n            ? inertia(Object.assign(Object.assign({}, options), valueTransition))\n            : animate(Object.assign(Object.assign({}, getPopmotionAnimationOptions(valueTransition, options, key)), { onUpdate: function (v) {\n                    var _a;\n                    options.onUpdate(v);\n                    (_a = valueTransition.onUpdate) === null || _a === void 0 ? void 0 : _a.call(valueTransition, v);\n                }, onComplete: function () {\n                    var _a;\n                    options.onComplete();\n                    (_a = valueTransition.onComplete) === null || _a === void 0 ? void 0 : _a.call(valueTransition);\n                } }));\n    }\n    function set() {\n        var _a;\n        value.set(target);\n        onComplete();\n        (_a = valueTransition === null || valueTransition === void 0 ? void 0 : valueTransition.onComplete) === null || _a === void 0 ? void 0 : _a.call(valueTransition);\n        return { stop: function () { } };\n    }\n    return !isOriginAnimatable ||\n        !isTargetAnimatable ||\n        valueTransition.type === false\n        ? set\n        : start;\n}\nfunction isZero(value) {\n    return (value === 0 ||\n        (typeof value === \"string\" &&\n            parseFloat(value) === 0 &&\n            value.indexOf(\" \") === -1));\n}\nfunction getZeroUnit(potentialUnitType) {\n    return typeof potentialUnitType === \"number\"\n        ? 0\n        : getAnimatableNone(\"\", potentialUnitType);\n}\nfunction getValueTransition(transition, key) {\n    return transition[key] || transition[\"default\"] || transition;\n}\n/**\n * Start animation on a MotionValue. This function is an interface between\n * Framer Motion and Popmotion\n *\n * @internal\n */\nfunction startAnimation(key, value, target, transition) {\n    if (transition === void 0) { transition = {}; }\n    return value.start(function (onComplete) {\n        var delayTimer;\n        var controls;\n        var animation = getAnimation(key, value, target, transition, onComplete);\n        var delay = getDelayFromTransition(transition, key);\n        var start = function () { return (controls = animation()); };\n        if (delay) {\n            delayTimer = setTimeout(start, secondsToMilliseconds(delay));\n        }\n        else {\n            start();\n        }\n        return function () {\n            clearTimeout(delayTimer);\n            controls === null || controls === void 0 ? void 0 : controls.stop();\n        };\n    });\n}\n\nexport { convertTransitionToAnimationOptions, getDelayFromTransition, getPopmotionAnimationOptions, getValueTransition, getZeroUnit, hydrateKeyframes, isTransitionDefined, isZero, startAnimation };\n", "/** \nbased on framer-motion@4.0.3,\nCopyright (c) 2018 Framer B.V.\n*/\nvar AnimationType;\n(function (AnimationType) {\n    AnimationType[\"Animate\"] = \"animate\";\n    AnimationType[\"Hover\"] = \"whileHover\";\n    AnimationType[\"Tap\"] = \"whileTap\";\n    AnimationType[\"Drag\"] = \"whileDrag\";\n    AnimationType[\"Focus\"] = \"whileFocus\";\n    AnimationType[\"Exit\"] = \"exit\";\n})(AnimationType || (AnimationType = {}));\n\nexport { AnimationType };\n", "/** \nbased on framer-motion@4.1.11,\nCopyright (c) 2018 Framer B.V.\n*/\nimport {fixed} from '../../../utils/fix-process-env';\nimport { mix } from 'popmotion';\n\nfunction tweenAxis(target, prev, next, p) {\n    target.min = mix(prev.min, next.min, p);\n    target.max = mix(prev.max, next.max, p);\n}\nfunction calcRelativeOffsetAxis(parent, child) {\n    return {\n        min: child.min - parent.min,\n        max: child.max - parent.min,\n    };\n}\nfunction calcRelativeOffset(parent, child) {\n    return {\n        x: calcRelativeOffsetAxis(parent.x, child.x),\n        y: calcRelativeOffsetAxis(parent.y, child.y),\n    };\n}\nfunction checkIfParentHasChanged(prev, next) {\n    var prevId = prev.getLayoutId();\n    var nextId = next.getLayoutId();\n    return prevId !== nextId || (nextId === undefined && prev !== next);\n}\n\nexport { calcRelativeOffset, calcRelativeOffsetAxis, checkIfParentHasChanged, tweenAxis };\n\n", "/** \nbased on framer-motion@4.1.11,\nCopyright (c) 2018 Framer B.V.\n*/\nfunction isDraggable(visualElement) {\n    var _a = visualElement.getProps(), drag = _a.drag, _dragX = _a._dragX;\n    return drag && !_dragX;\n}\n\nexport { isDraggable };\n", "/** \nbased on framer-motion@4.1.15,\nCopyright (c) 2018 Framer B.V.\n*/\nimport {fixed} from '../fix-process-env';\nimport { __read } from 'tslib';\nimport { mix } from 'popmotion';\nimport { isDraggable } from '../../render/utils/is-draggable.js';\n\n/**\n * Reset an axis to the provided origin box.\n *\n * This is a mutative operation.\n */\nfunction resetAxis(axis, originAxis) {\n    axis.min = originAxis.min;\n    axis.max = originAxis.max;\n}\n/**\n * Reset a box to the provided origin box.\n *\n * This is a mutative operation.\n */\nfunction resetBox(box, originBox) {\n    resetAxis(box.x, originBox.x);\n    resetAxis(box.y, originBox.y);\n}\n/**\n * Scales a point based on a factor and an originPoint\n */\nfunction scalePoint(point, scale, originPoint) {\n    var distanceFromOrigin = point - originPoint;\n    var scaled = scale * distanceFromOrigin;\n    return originPoint + scaled;\n}\n/**\n * Applies a translate/scale delta to a point\n */\nfunction applyPointDelta(point, translate, scale, originPoint, boxScale) {\n    if (boxScale !== undefined) {\n        point = scalePoint(point, boxScale, originPoint);\n    }\n    return scalePoint(point, scale, originPoint) + translate;\n}\n/**\n * Applies a translate/scale delta to an axis\n */\nfunction applyAxisDelta(axis, translate, scale, originPoint, boxScale) {\n    if (translate === void 0) { translate = 0; }\n    if (scale === void 0) { scale = 1; }\n    axis.min = applyPointDelta(axis.min, translate, scale, originPoint, boxScale);\n    axis.max = applyPointDelta(axis.max, translate, scale, originPoint, boxScale);\n}\n/**\n * Applies a translate/scale delta to a box\n */\nfunction applyBoxDelta(box, _a) {\n    var x = _a.x, y = _a.y;\n    applyAxisDelta(box.x, x.translate, x.scale, x.originPoint);\n    applyAxisDelta(box.y, y.translate, y.scale, y.originPoint);\n}\n/**\n * Apply a transform to an axis from the latest resolved motion values.\n * This function basically acts as a bridge between a flat motion value map\n * and applyAxisDelta\n */\nfunction applyAxisTransforms(final, axis, transforms, _a) {\n    var _b = __read(_a, 3), key = _b[0], scaleKey = _b[1], originKey = _b[2];\n    // Copy the current axis to the final axis before mutation\n    final.min = axis.min;\n    final.max = axis.max;\n    var axisOrigin = transforms[originKey] !== undefined ? transforms[originKey] : 0.5;\n    var originPoint = mix(axis.min, axis.max, axisOrigin);\n    // Apply the axis delta to the final axis\n    applyAxisDelta(final, transforms[key], transforms[scaleKey], originPoint, transforms.scale);\n}\n/**\n * The names of the motion values we want to apply as translation, scale and origin.\n */\nvar xKeys = [\"x\", \"scaleX\", \"originX\"];\nvar yKeys = [\"y\", \"scaleY\", \"originY\"];\n/**\n * Apply a transform to a box from the latest resolved motion values.\n */\nfunction applyBoxTransforms(finalBox, box, transforms) {\n    applyAxisTransforms(finalBox.x, box.x, transforms, xKeys);\n    applyAxisTransforms(finalBox.y, box.y, transforms, yKeys);\n}\n/**\n * Remove a delta from a point. This is essentially the steps of applyPointDelta in reverse\n */\nfunction removePointDelta(point, translate, scale, originPoint, boxScale) {\n    point -= translate;\n    point = scalePoint(point, 1 / scale, originPoint);\n    if (boxScale !== undefined) {\n        point = scalePoint(point, 1 / boxScale, originPoint);\n    }\n    return point;\n}\n/**\n * Remove a delta from an axis. This is essentially the steps of applyAxisDelta in reverse\n */\nfunction removeAxisDelta(axis, translate, scale, origin, boxScale) {\n    if (translate === void 0) { translate = 0; }\n    if (scale === void 0) { scale = 1; }\n    if (origin === void 0) { origin = 0.5; }\n    var originPoint = mix(axis.min, axis.max, origin) - translate;\n    axis.min = removePointDelta(axis.min, translate, scale, originPoint, boxScale);\n    axis.max = removePointDelta(axis.max, translate, scale, originPoint, boxScale);\n}\n/**\n * Remove a transforms from an axis. This is essentially the steps of applyAxisTransforms in reverse\n * and acts as a bridge between motion values and removeAxisDelta\n */\nfunction removeAxisTransforms(axis, transforms, _a) {\n    var _b = __read(_a, 3), key = _b[0], scaleKey = _b[1], originKey = _b[2];\n    removeAxisDelta(axis, transforms[key], transforms[scaleKey], transforms[originKey], transforms.scale);\n}\n/**\n * Remove a transforms from an box. This is essentially the steps of applyAxisBox in reverse\n * and acts as a bridge between motion values and removeAxisDelta\n */\nfunction removeBoxTransforms(box, transforms) {\n    removeAxisTransforms(box.x, transforms, xKeys);\n    removeAxisTransforms(box.y, transforms, yKeys);\n}\n/**\n * Apply a tree of deltas to a box. We do this to calculate the effect of all the transforms\n * in a tree upon our box before then calculating how to project it into our desired viewport-relative box\n *\n * This is the final nested loop within updateLayoutDelta for future refactoring\n */\nfunction applyTreeDeltas(box, treeScale, treePath) {\n    var treeLength = treePath.length;\n    if (!treeLength)\n        return;\n    // Reset the treeScale\n    treeScale.x = treeScale.y = 1;\n    var node;\n    var delta;\n    for (var i = 0; i < treeLength; i++) {\n        node = treePath[i];\n        delta = node.getLayoutState().delta;\n        // Incoporate each ancestor's scale into a culmulative treeScale for this component\n        treeScale.x *= delta.x.scale;\n        treeScale.y *= delta.y.scale;\n        // Apply each ancestor's calculated delta into this component's recorded layout box\n        applyBoxDelta(box, delta);\n        // If this is a draggable ancestor, also incorporate the node's transform to the layout box\n        if (isDraggable(node)) {\n            applyBoxTransforms(box, box, node.getLatestValues());\n        }\n    }\n}\n\nexport { applyAxisDelta, applyAxisTransforms, applyBoxDelta, applyBoxTransforms, applyPointDelta, applyTreeDeltas, removeAxisDelta, removeAxisTransforms, removeBoxTransforms, removePointDelta, resetAxis, resetBox, scalePoint };\n", "/** \nbased on framer-motion@4.1.11,\nCopyright (c) 2018 Framer B.V.\n*/\n\nimport { calcRelativeOffset } from '../../../motion/features/layout/utils.js';\nimport { eachAxis } from '../../../utils/each-axis.js';\nimport { removeBoxTransforms } from '../../../utils/geometry/delta-apply.js';\n\n/**\n * Returns a boolean stating whether or not we converted the projection\n * to relative projection.\n */\nfunction convertToRelativeProjection(visualElement, isLayoutDrag) {\n    if (isLayoutDrag === void 0) { isLayoutDrag = true; }\n    var projectionParent = visualElement.getProjectionParent();\n    if (!projectionParent)\n        return false;\n    var offset;\n    if (isLayoutDrag) {\n        offset = calcRelativeOffset(projectionParent.projection.target, visualElement.projection.target);\n        removeBoxTransforms(offset, projectionParent.getLatestValues());\n    }\n    else {\n        offset = calcRelativeOffset(projectionParent.getLayoutState().layout, visualElement.getLayoutState().layout);\n    }\n    eachAxis(function (axis) {\n        return visualElement.setProjectionTargetAxis(axis, offset[axis].min, offset[axis].max, true);\n    });\n    return true;\n}\n\nexport { convertToRelativeProjection };\n", "/** \nbased on framer-motion@4.1.15,\nCopyright (c) 2018 Framer B.V.\n*/\nimport {fixed} from '../../utils/fix-process-env';\nimport { __rest, __spreadArray, __read } from 'tslib';\nimport { invariant } from 'hey-listen';\nimport { PanSession } from '../PanSession.js';\nimport { getGlobalLock } from './utils/lock.js';\nimport { isRefObject } from '../../utils/is-ref-object.js';\nimport { addPointerEvent } from '../../events/use-pointer-event.js';\nimport { addDomEvent } from '../../events/use-dom-event.js';\nimport { getViewportPointFromEvent } from '../../events/event-info.js';\nimport { axisBox, convertAxisBoxToBoundingBox, convertBoundingBoxToAxisBox } from '../../utils/geometry/index.js';\nimport { eachAxis } from '../../utils/each-axis.js';\nimport { calcRelativeConstraints, resolveDragElastic, rebaseAxisConstraints, calcViewportConstraints, applyConstraints, calcConstrainedMinPoint, calcPositionFromProgress, defaultElastic } from './utils/constraints.js';\nimport { getBoundingBox } from '../../render/dom/projection/measure.js';\nimport { calcOrigin } from '../../utils/geometry/delta-calc.js';\nimport { startAnimation } from '../../animation/utils/transitions.js';\nimport { AnimationType } from '../../render/utils/types.js';\nimport { collectProjectingAncestors, updateLayoutMeasurement, collectProjectingChildren } from '../../render/dom/projection/utils.js';\nimport { progress } from 'popmotion';\nimport { convertToRelativeProjection } from '../../render/dom/projection/convert-to-relative.js';\nimport { calcRelativeOffset } from '../../motion/features/layout/utils.js';\nimport { flushLayout, batchLayout } from '../../render/dom/utils/batch-layout.js';\nimport { flushSync } from 'framesync';\n\nvar elementDragControls = new WeakMap();\n/**\n *\n */\nvar lastPointerEvent;\nvar VisualElementDragControls = /** @class */ (function () {\n    function VisualElementDragControls(_a) {\n        var visualElement = _a.visualElement;\n        /**\n         * Track whether we're currently dragging.\n         *\n         * @internal\n         */\n        this.isDragging = false;\n        /**\n         * The current direction of drag, or `null` if both.\n         *\n         * @internal\n         */\n        this.currentDirection = null;\n        /**\n         * The permitted boundaries of travel, in pixels.\n         *\n         * @internal\n         */\n        this.constraints = false;\n        /**\n         * The per-axis resolved elastic values.\n         *\n         * @internal\n         */\n        this.elastic = axisBox();\n        /**\n         * A reference to the host component's latest props.\n         *\n         * @internal\n         */\n        this.props = {};\n        /**\n         * @internal\n         */\n        this.hasMutatedConstraints = false;\n        /**\n         * Track the initial position of the cursor relative to the dragging element\n         * when dragging starts as a value of 0-1 on each axis. We then use this to calculate\n         * an ideal bounding box for the VisualElement renderer to project into every frame.\n         *\n         * @internal\n         */\n        this.cursorProgress = {\n            x: 0.5,\n            y: 0.5,\n        };\n        // When updating _dragX, or _dragY instead of the VisualElement,\n        // persist their values between drag gestures.\n        this.originPoint = {};\n        // This is a reference to the global drag gesture lock, ensuring only one component\n        // can \"capture\" the drag of one or both axes.\n        // TODO: Look into moving this into pansession?\n        this.openGlobalLock = null;\n        /**\n         * @internal\n         */\n        this.panSession = null;\n        this.visualElement = visualElement;\n        this.visualElement.enableLayoutProjection();\n        elementDragControls.set(visualElement, this);\n    }\n    /**\n     * Instantiate a PanSession for the drag gesture\n     *\n     * @public\n     */\n    VisualElementDragControls.prototype.start = function (originEvent, _a) {\n        var _this = this;\n        var _b = _a === void 0 ? {} : _a, _c = _b.snapToCursor, snapToCursor = _c === void 0 ? false : _c, cursorProgress = _b.cursorProgress;\n        var onSessionStart = function (event) {\n            var _a;\n            // Stop any animations on both axis values immediately. This allows the user to throw and catch\n            // the component.\n            _this.stopMotion();\n            /**\n             * Save the initial point. We'll use this to calculate the pointer's position rather\n             * than the one we receive when the gesture actually starts. By then, the pointer will\n             * have already moved, and the perception will be of the pointer \"slipping\" across the element\n             */\n            var initialPoint = getViewportPointFromEvent(event).point;\n            (_a = _this.cancelLayout) === null || _a === void 0 ? void 0 : _a.call(_this);\n            _this.cancelLayout = batchLayout(function (read, write) {\n                var ancestors = collectProjectingAncestors(_this.visualElement);\n                var children = collectProjectingChildren(_this.visualElement);\n                var tree = __spreadArray(__spreadArray([], __read(ancestors)), __read(children));\n                var hasManuallySetCursorOrigin = false;\n                /**\n                 * Apply a simple lock to the projection target. This ensures no animations\n                 * can run on the projection box while this lock is active.\n                 */\n                _this.isLayoutDrag() && _this.visualElement.lockProjectionTarget();\n                write(function () {\n                    tree.forEach(function (element) { return element.resetTransform(); });\n                });\n                read(function () {\n                    updateLayoutMeasurement(_this.visualElement);\n                    children.forEach(updateLayoutMeasurement);\n                });\n                write(function () {\n                    tree.forEach(function (element) { return element.restoreTransform(); });\n                    if (snapToCursor) {\n                        hasManuallySetCursorOrigin = _this.snapToCursor(initialPoint);\n                    }\n                });\n                read(function () {\n                    var isRelativeDrag = Boolean(_this.getAxisMotionValue(\"x\") && !_this.isExternalDrag());\n                    if (!isRelativeDrag) {\n                        _this.visualElement.rebaseProjectionTarget(true, _this.visualElement.measureViewportBox(false));\n                    }\n                    _this.visualElement.scheduleUpdateLayoutProjection();\n                    /**\n                     * When dragging starts, we want to find where the cursor is relative to the bounding box\n                     * of the element. Every frame, we calculate a new bounding box using this relative position\n                     * and let the visualElement renderer figure out how to reproject the element into this bounding\n                     * box.\n                     *\n                     * By doing it this way, rather than applying an x/y transform directly to the element,\n                     * we can ensure the component always visually sticks to the cursor as we'd expect, even\n                     * if the DOM element itself changes layout as a result of React updates the user might\n                     * make based on the drag position.\n                     */\n                    var projection = _this.visualElement.projection;\n                    eachAxis(function (axis) {\n                        if (!hasManuallySetCursorOrigin) {\n                            var _a = projection.target[axis], min = _a.min, max = _a.max;\n                            _this.cursorProgress[axis] = cursorProgress\n                                ? cursorProgress[axis]\n                                : progress(min, max, initialPoint[axis]);\n                        }\n                        /**\n                         * If we have external drag MotionValues, record their origin point. On pointermove\n                         * we'll apply the pan gesture offset directly to this value.\n                         */\n                        var axisValue = _this.getAxisMotionValue(axis);\n                        if (axisValue) {\n                            _this.originPoint[axis] = axisValue.get();\n                        }\n                    });\n                });\n                write(function () {\n                    flushSync.update();\n                    flushSync.preRender();\n                    flushSync.render();\n                    flushSync.postRender();\n                });\n                read(function () { return _this.resolveDragConstraints(); });\n            });\n        };\n        var onStart = function (event, info) {\n            var _a, _b, _c;\n            // Attempt to grab the global drag gesture lock - maybe make this part of PanSession\n            var _d = _this.props, drag = _d.drag, dragPropagation = _d.dragPropagation;\n            if (drag && !dragPropagation) {\n                if (_this.openGlobalLock)\n                    _this.openGlobalLock();\n                _this.openGlobalLock = getGlobalLock(drag);\n                // If we don 't have the lock, don't start dragging\n                if (!_this.openGlobalLock)\n                    return;\n            }\n            flushLayout();\n            // Set current drag status\n            _this.isDragging = true;\n            _this.currentDirection = null;\n            // Fire onDragStart event\n            (_b = (_a = _this.props).onDragStart) === null || _b === void 0 ? void 0 : _b.call(_a, event, info);\n            (_c = _this.visualElement.animationState) === null || _c === void 0 ? void 0 : _c.setActive(AnimationType.Drag, true);\n        };\n        var onMove = function (event, info) {\n            var _a, _b, _c, _d;\n            var _e = _this.props, dragPropagation = _e.dragPropagation, dragDirectionLock = _e.dragDirectionLock;\n            // If we didn't successfully receive the gesture lock, early return.\n            if (!dragPropagation && !_this.openGlobalLock)\n                return;\n            var offset = info.offset;\n            // Attempt to detect drag direction if directionLock is true\n            if (dragDirectionLock && _this.currentDirection === null) {\n                _this.currentDirection = getCurrentDirection(offset);\n                // If we've successfully set a direction, notify listener\n                if (_this.currentDirection !== null) {\n                    (_b = (_a = _this.props).onDirectionLock) === null || _b === void 0 ? void 0 : _b.call(_a, _this.currentDirection);\n                }\n                return;\n            }\n            // Update each point with the latest position\n            _this.updateAxis(\"x\", info.point, offset);\n            _this.updateAxis(\"y\", info.point, offset);\n            // Fire onDrag event\n            (_d = (_c = _this.props).onDrag) === null || _d === void 0 ? void 0 : _d.call(_c, event, info);\n            // Update the last pointer event\n            lastPointerEvent = event;\n        };\n        var onSessionEnd = function (event, info) {\n            return _this.stop(event, info);\n        };\n        var transformPagePoint = this.props.transformPagePoint;\n        this.panSession = new PanSession(originEvent, {\n            onSessionStart: onSessionStart,\n            onStart: onStart,\n            onMove: onMove,\n            onSessionEnd: onSessionEnd,\n        }, { transformPagePoint: transformPagePoint });\n    };\n    VisualElementDragControls.prototype.resolveDragConstraints = function () {\n        var _this = this;\n        var _a = this.props, dragConstraints = _a.dragConstraints, dragElastic = _a.dragElastic;\n        var layout = this.visualElement.getLayoutState().layoutCorrected;\n        if (dragConstraints) {\n            this.constraints = isRefObject(dragConstraints)\n                ? this.resolveRefConstraints(layout, dragConstraints)\n                : calcRelativeConstraints(layout, dragConstraints);\n        }\n        else {\n            this.constraints = false;\n        }\n        this.elastic = resolveDragElastic(dragElastic);\n        /**\n         * If we're outputting to external MotionValues, we want to rebase the measured constraints\n         * from viewport-relative to component-relative.\n         */\n        if (this.constraints && !this.hasMutatedConstraints) {\n            eachAxis(function (axis) {\n                if (_this.getAxisMotionValue(axis)) {\n                    _this.constraints[axis] = rebaseAxisConstraints(layout[axis], _this.constraints[axis]);\n                }\n            });\n        }\n    };\n    VisualElementDragControls.prototype.resolveRefConstraints = function (layoutBox, constraints) {\n        var _a = this.props, onMeasureDragConstraints = _a.onMeasureDragConstraints, transformPagePoint = _a.transformPagePoint;\n        var constraintsElement = constraints.current;\n        invariant(constraintsElement !== null, \"If `dragConstraints` is set as a React ref, that ref must be passed to another component's `ref` prop.\");\n        this.constraintsBox = getBoundingBox(constraintsElement, transformPagePoint);\n        var measuredConstraints = calcViewportConstraints(layoutBox, this.constraintsBox);\n        /**\n         * If there's an onMeasureDragConstraints listener we call it and\n         * if different constraints are returned, set constraints to that\n         */\n        if (onMeasureDragConstraints) {\n            var userConstraints = onMeasureDragConstraints(convertAxisBoxToBoundingBox(measuredConstraints));\n            this.hasMutatedConstraints = !!userConstraints;\n            if (userConstraints) {\n                measuredConstraints = convertBoundingBoxToAxisBox(userConstraints);\n            }\n        }\n        return measuredConstraints;\n    };\n    VisualElementDragControls.prototype.cancelDrag = function () {\n        var _a, _b;\n        this.visualElement.unlockProjectionTarget();\n        (_a = this.cancelLayout) === null || _a === void 0 ? void 0 : _a.call(this);\n        this.isDragging = false;\n        this.panSession && this.panSession.end();\n        this.panSession = null;\n        if (!this.props.dragPropagation && this.openGlobalLock) {\n            this.openGlobalLock();\n            this.openGlobalLock = null;\n        }\n        (_b = this.visualElement.animationState) === null || _b === void 0 ? void 0 : _b.setActive(AnimationType.Drag, false);\n    };\n    VisualElementDragControls.prototype.stop = function (event, info) {\n        var _a, _b, _c;\n        (_a = this.panSession) === null || _a === void 0 ? void 0 : _a.end();\n        this.panSession = null;\n        var isDragging = this.isDragging;\n        this.cancelDrag();\n        if (!isDragging)\n            return;\n        var velocity = info.velocity;\n        this.animateDragEnd(velocity);\n        (_c = (_b = this.props).onDragEnd) === null || _c === void 0 ? void 0 : _c.call(_b, event, info);\n    };\n    VisualElementDragControls.prototype.snapToCursor = function (point) {\n        var _this = this;\n        return eachAxis(function (axis) {\n            var drag = _this.props.drag;\n            // If we're not dragging this axis, do an early return.\n            if (!shouldDrag(axis, drag, _this.currentDirection))\n                return;\n            var axisValue = _this.getAxisMotionValue(axis);\n            if (axisValue) {\n                var box = _this.visualElement.getLayoutState().layout;\n                var length_1 = box[axis].max - box[axis].min;\n                var center = box[axis].min + length_1 / 2;\n                var offset = point[axis] - center;\n                _this.originPoint[axis] = point[axis];\n                axisValue.set(offset);\n            }\n            else {\n                _this.cursorProgress[axis] = 0.5;\n                return true;\n            }\n        }).includes(true);\n    };\n    /**\n     * Update the specified axis with the latest pointer information.\n     */\n    VisualElementDragControls.prototype.updateAxis = function (axis, point, offset) {\n        var drag = this.props.drag;\n        // If we're not dragging this axis, do an early return.\n        if (!shouldDrag(axis, drag, this.currentDirection))\n            return;\n        return this.getAxisMotionValue(axis)\n            ? this.updateAxisMotionValue(axis, offset)\n            : this.updateVisualElementAxis(axis, point);\n    };\n    VisualElementDragControls.prototype.updateAxisMotionValue = function (axis, offset) {\n        var axisValue = this.getAxisMotionValue(axis);\n        if (!offset || !axisValue)\n            return;\n        var nextValue = this.originPoint[axis] + offset[axis];\n        var update = this.constraints\n            ? applyConstraints(nextValue, this.constraints[axis], this.elastic[axis])\n            : nextValue;\n        axisValue.set(update);\n    };\n    VisualElementDragControls.prototype.updateVisualElementAxis = function (axis, point) {\n        var _a;\n        // Get the actual layout bounding box of the element\n        var axisLayout = this.visualElement.getLayoutState().layout[axis];\n        // Calculate its current length. In the future we might want to lerp this to animate\n        // between lengths if the layout changes as we change the DOM\n        var axisLength = axisLayout.max - axisLayout.min;\n        // Get the initial progress that the pointer sat on this axis on gesture start.\n        var axisProgress = this.cursorProgress[axis];\n        // Calculate a new min point based on the latest pointer position, constraints and elastic\n        var min = calcConstrainedMinPoint(point[axis], axisLength, axisProgress, (_a = this.constraints) === null || _a === void 0 ? void 0 : _a[axis], this.elastic[axis]);\n        // Update the axis viewport target with this new min and the length\n        this.visualElement.setProjectionTargetAxis(axis, min, min + axisLength);\n    };\n    VisualElementDragControls.prototype.setProps = function (_a) {\n        var _b = _a.drag, drag = _b === void 0 ? false : _b, _c = _a.dragDirectionLock, dragDirectionLock = _c === void 0 ? false : _c, _d = _a.dragPropagation, dragPropagation = _d === void 0 ? false : _d, _e = _a.dragConstraints, dragConstraints = _e === void 0 ? false : _e, _f = _a.dragElastic, dragElastic = _f === void 0 ? defaultElastic : _f, _g = _a.dragMomentum, dragMomentum = _g === void 0 ? true : _g, remainingProps = __rest(_a, [\"drag\", \"dragDirectionLock\", \"dragPropagation\", \"dragConstraints\", \"dragElastic\", \"dragMomentum\"]);\n        this.props = Object.assign({ drag: drag,\n            dragDirectionLock: dragDirectionLock,\n            dragPropagation: dragPropagation,\n            dragConstraints: dragConstraints,\n            dragElastic: dragElastic,\n            dragMomentum: dragMomentum }, remainingProps);\n    };\n    /**\n     * Drag works differently depending on which props are provided.\n     *\n     * - If _dragX and _dragY are provided, we output the gesture delta directly to those motion values.\n     * - If the component will perform layout animations, we output the gesture to the component's\n     *      visual bounding box\n     * - Otherwise, we apply the delta to the x/y motion values.\n     */\n    VisualElementDragControls.prototype.getAxisMotionValue = function (axis) {\n        var _a = this.props, layout = _a.layout, layoutId = _a.layoutId;\n        var dragKey = \"_drag\" + axis.toUpperCase();\n        if (this.props[dragKey]) {\n            return this.props[dragKey];\n        }\n        else if (!layout && layoutId === undefined) {\n            return this.visualElement.getValue(axis, 0);\n        }\n    };\n    VisualElementDragControls.prototype.isLayoutDrag = function () {\n        return !this.getAxisMotionValue(\"x\");\n    };\n    VisualElementDragControls.prototype.isExternalDrag = function () {\n        var _a = this.props, _dragX = _a._dragX, _dragY = _a._dragY;\n        return _dragX || _dragY;\n    };\n    VisualElementDragControls.prototype.animateDragEnd = function (velocity) {\n        var _this = this;\n        var _a = this.props, drag = _a.drag, dragMomentum = _a.dragMomentum, dragElastic = _a.dragElastic, dragTransition = _a.dragTransition;\n        /**\n         * Everything beyond the drag gesture should be performed with\n         * relative projection so children stay in sync with their parent element.\n         */\n        var isRelative = convertToRelativeProjection(this.visualElement, this.isLayoutDrag() && !this.isExternalDrag());\n        /**\n         * If we had previously resolved constraints relative to the viewport,\n         * we need to also convert those to a relative coordinate space for the animation\n         */\n        var constraints = this.constraints || {};\n        if (isRelative &&\n            Object.keys(constraints).length &&\n            this.isLayoutDrag()) {\n            var projectionParent = this.visualElement.getProjectionParent();\n            if (projectionParent) {\n                var relativeConstraints_1 = calcRelativeOffset(projectionParent.projection.targetFinal, constraints);\n                eachAxis(function (axis) {\n                    var _a = relativeConstraints_1[axis], min = _a.min, max = _a.max;\n                    constraints[axis] = {\n                        min: isNaN(min) ? undefined : min,\n                        max: isNaN(max) ? undefined : max,\n                    };\n                });\n            }\n        }\n        var momentumAnimations = eachAxis(function (axis) {\n            var _a;\n            if (!shouldDrag(axis, drag, _this.currentDirection)) {\n                return;\n            }\n            var transition = (_a = constraints === null || constraints === void 0 ? void 0 : constraints[axis]) !== null && _a !== void 0 ? _a : {};\n            /**\n             * Overdamp the boundary spring if `dragElastic` is disabled. There's still a frame\n             * of spring animations so we should look into adding a disable spring option to `inertia`.\n             * We could do something here where we affect the `bounceStiffness` and `bounceDamping`\n             * using the value of `dragElastic`.\n             */\n            var bounceStiffness = dragElastic ? 200 : 1000000;\n            var bounceDamping = dragElastic ? 40 : 10000000;\n            var inertia = Object.assign(Object.assign({ type: \"inertia\", velocity: dragMomentum ? velocity[axis] : 0, bounceStiffness: bounceStiffness,\n                bounceDamping: bounceDamping, timeConstant: 750, restDelta: 1, restSpeed: 10 }, dragTransition), transition);\n            // If we're not animating on an externally-provided `MotionValue` we can use the\n            // component's animation controls which will handle interactions with whileHover (etc),\n            // otherwise we just have to animate the `MotionValue` itself.\n            return _this.getAxisMotionValue(axis)\n                ? _this.startAxisValueAnimation(axis, inertia)\n                : _this.visualElement.startLayoutAnimation(axis, inertia, isRelative);\n        });\n        // Run all animations and then resolve the new drag constraints.\n        return Promise.all(momentumAnimations).then(function () {\n            var _a, _b;\n            (_b = (_a = _this.props).onDragTransitionEnd) === null || _b === void 0 ? void 0 : _b.call(_a);\n        });\n    };\n    VisualElementDragControls.prototype.stopMotion = function () {\n        var _this = this;\n        eachAxis(function (axis) {\n            var axisValue = _this.getAxisMotionValue(axis);\n            axisValue\n                ? axisValue.stop()\n                : _this.visualElement.stopLayoutAnimation();\n        });\n    };\n    VisualElementDragControls.prototype.startAxisValueAnimation = function (axis, transition) {\n        var axisValue = this.getAxisMotionValue(axis);\n        if (!axisValue)\n            return;\n        var currentValue = axisValue.get();\n        axisValue.set(currentValue);\n        axisValue.set(currentValue); // Set twice to hard-reset velocity\n        return startAnimation(axis, axisValue, 0, transition);\n    };\n    VisualElementDragControls.prototype.scalePoint = function () {\n        var _this = this;\n        var _a = this.props, drag = _a.drag, dragConstraints = _a.dragConstraints;\n        if (!isRefObject(dragConstraints) || !this.constraintsBox)\n            return;\n        // Stop any current animations as there can be some visual glitching if we resize mid animation\n        this.stopMotion();\n        // Record the relative progress of the targetBox relative to the constraintsBox\n        var boxProgress = { x: 0, y: 0 };\n        eachAxis(function (axis) {\n            boxProgress[axis] = calcOrigin(_this.visualElement.projection.target[axis], _this.constraintsBox[axis]);\n        });\n        /**\n         * For each axis, calculate the current progress of the layout axis within the constraints.\n         * Then, using the latest layout and constraints measurements, reposition the new layout axis\n         * proportionally within the constraints.\n         */\n        this.updateConstraints(function () {\n            eachAxis(function (axis) {\n                if (!shouldDrag(axis, drag, null))\n                    return;\n                // Calculate the position of the targetBox relative to the constraintsBox using the\n                // previously calculated progress\n                var _a = calcPositionFromProgress(_this.visualElement.projection.target[axis], _this.constraintsBox[axis], boxProgress[axis]), min = _a.min, max = _a.max;\n                _this.visualElement.setProjectionTargetAxis(axis, min, max);\n            });\n        });\n        /**\n         * If any other draggable components are queuing the same tasks synchronously\n         * this will wait until they've all been scheduled before flushing.\n         */\n        setTimeout(flushLayout, 1);\n    };\n    VisualElementDragControls.prototype.updateConstraints = function (onReady) {\n        var _this = this;\n        this.cancelLayout = batchLayout(function (read, write) {\n            var ancestors = collectProjectingAncestors(_this.visualElement);\n            write(function () {\n                return ancestors.forEach(function (element) { return element.resetTransform(); });\n            });\n            read(function () { return updateLayoutMeasurement(_this.visualElement); });\n            write(function () {\n                return ancestors.forEach(function (element) { return element.restoreTransform(); });\n            });\n            read(function () {\n                _this.resolveDragConstraints();\n            });\n            if (onReady)\n                write(onReady);\n        });\n    };\n    VisualElementDragControls.prototype.mount = function (visualElement) {\n        var _this = this;\n        var element = visualElement.getInstance();\n        /**\n         * Attach a pointerdown event listener on this DOM element to initiate drag tracking.\n         */\n        var stopPointerListener = addPointerEvent(element, \"pointerdown\", function (event) {\n            var _a = _this.props, drag = _a.drag, _b = _a.dragListener, dragListener = _b === void 0 ? true : _b;\n            drag && dragListener && _this.start(event);\n        });\n        /**\n         * Attach a window resize listener to scale the draggable target within its defined\n         * constraints as the window resizes.\n         */\n        var stopResizeListener = addDomEvent(window, \"resize\", function () {\n            _this.scalePoint();\n        });\n        /**\n         * Ensure drag constraints are resolved correctly relative to the dragging element\n         * whenever its layout changes.\n         */\n        var stopLayoutUpdateListener = visualElement.onLayoutUpdate(function () {\n            if (_this.isDragging) {\n                _this.resolveDragConstraints();\n            }\n        });\n        /**\n         * If the previous component with this same layoutId was dragging at the time\n         * it was unmounted, we want to continue the same gesture on this component.\n         */\n        var prevDragCursor = visualElement.prevDragCursor;\n        if (prevDragCursor) {\n            this.start(lastPointerEvent, { cursorProgress: prevDragCursor });\n        }\n        /**\n         * Return a function that will teardown the drag gesture\n         */\n        return function () {\n            stopPointerListener === null || stopPointerListener === void 0 ? void 0 : stopPointerListener();\n            stopResizeListener === null || stopResizeListener === void 0 ? void 0 : stopResizeListener();\n            stopLayoutUpdateListener === null || stopLayoutUpdateListener === void 0 ? void 0 : stopLayoutUpdateListener();\n            _this.cancelDrag();\n        };\n    };\n    return VisualElementDragControls;\n}());\nfunction shouldDrag(direction, drag, currentDirection) {\n    return ((drag === true || drag === direction) &&\n        (currentDirection === null || currentDirection === direction));\n}\n/**\n * Based on an x/y offset determine the current drag direction. If both axis' offsets are lower\n * than the provided threshold, return `null`.\n *\n * @param offset - The x/y offset from origin.\n * @param lockThreshold - (Optional) - the minimum absolute offset before we can determine a drag direction.\n */\nfunction getCurrentDirection(offset, lockThreshold) {\n    if (lockThreshold === void 0) { lockThreshold = 10; }\n    var direction = null;\n    if (Math.abs(offset.y) > lockThreshold) {\n        direction = \"y\";\n    }\n    else if (Math.abs(offset.x) > lockThreshold) {\n        direction = \"x\";\n    }\n    return direction;\n}\n\nexport { VisualElementDragControls, elementDragControls };\n", "/** \nbased on framer-motion@4.0.3,\nCopyright (c) 2018 Framer B.V.\n*/\nvar isMotionValue = function (value) {\n    return value !== null && typeof value === \"object\" && value.getVelocity;\n};\n\nexport { isMotionValue };\n", "/** \nbased on framer-motion@4.0.3,\nCopyright (c) 2018 Framer B.V.\n*/\nfunction addUniqueItem(arr, item) {\n    arr.indexOf(item) === -1 && arr.push(item);\n}\nfunction removeItem(arr, item) {\n    var index = arr.indexOf(item);\n    index > -1 && arr.splice(index, 1);\n}\n\nexport { addUniqueItem, removeItem };\n", "/** \nbased on framer-motion@4.0.3,\nCopyright (c) 2018 Framer B.V.\n*/\nimport { addUniqueItem, removeItem } from './array.js';\n\nvar SubscriptionManager = /** @class */ (function () {\n    function SubscriptionManager() {\n        this.subscriptions = [];\n    }\n    SubscriptionManager.prototype.add = function (handler) {\n        var _this = this;\n        addUniqueItem(this.subscriptions, handler);\n        return function () { return removeItem(_this.subscriptions, handler); };\n    };\n    SubscriptionManager.prototype.notify = function (a, b, c) {\n        var numSubscriptions = this.subscriptions.length;\n        if (!numSubscriptions)\n            return;\n        if (numSubscriptions === 1) {\n            /**\n             * If there's only a single handler we can just call it without invoking a loop.\n             */\n            this.subscriptions[0](a, b, c);\n        }\n        else {\n            for (var i = 0; i < numSubscriptions; i++) {\n                /**\n                 * Check whether the handler exists before firing as it's possible\n                 * the subscriptions were modified during this loop running.\n                 */\n                var handler = this.subscriptions[i];\n                handler && handler(a, b, c);\n            }\n        }\n    };\n    SubscriptionManager.prototype.getSize = function () {\n        return this.subscriptions.length;\n    };\n    SubscriptionManager.prototype.clear = function () {\n        this.subscriptions.length = 0;\n    };\n    return SubscriptionManager;\n}());\n\nexport { SubscriptionManager };\n", "\n/** \nbased on framer-motion@4.0.3,\nCopyright (c) 2018 Framer B.V.\n*/\nimport { fixed } from '../utils/fix-process-env';\nimport sync, { getFrameData } from 'framesync';\nimport { velocityPerSecond } from 'popmotion';\nimport { SubscriptionManager } from '../utils/subscription-manager.js';\n\nvar isFloat = function (value) {\n    return !isNaN(parseFloat(value));\n};\n/**\n * `MotionValue` is used to track the state and velocity of motion values.\n *\n * @public\n */\nvar MotionValue = /** @class */ (function () {\n    /**\n     * @param init - The initiating value\n     * @param config - Optional configuration options\n     *\n     * -  `transformer`: A function to transform incoming values with.\n     *\n     * @internal\n     */\n    function MotionValue(init, startStopNotifier) {\n        var _this = this;\n        /**\n         * Duration, in milliseconds, since last updating frame.\n         *\n         * @internal\n         */\n        this.timeDelta = 0;\n        /**\n         * Timestamp of the last time this `MotionValue` was updated.\n         *\n         * @internal\n         */\n        this.lastUpdated = 0;\n        /**\n         * Functions to notify when the `MotionValue` updates.\n         *\n         * @internal\n         */\n        this.updateSubscribers = new SubscriptionManager();\n        /**\n         * Functions to notify when the velocity updates.\n         *\n         * @internal\n         */\n        this.velocityUpdateSubscribers = new SubscriptionManager();\n        /**\n         * Functions to notify when the `MotionValue` updates and `render` is set to `true`.\n         *\n         * @internal\n         */\n        this.renderSubscribers = new SubscriptionManager();\n        /**\n         * Tracks whether this value can output a velocity. Currently this is only true\n         * if the value is numerical, but we might be able to widen the scope here and support\n         * other value types.\n         *\n         * @internal\n         */\n        this.canTrackVelocity = false;\n        this.updateAndNotify = function (v, render) {\n            if (render === void 0) { render = true; }\n            _this.prev = _this.current;\n            _this.current = v;\n            // Update timestamp\n            var _a = getFrameData(), delta = _a.delta, timestamp = _a.timestamp;\n            if (_this.lastUpdated !== timestamp) {\n                _this.timeDelta = delta;\n                _this.lastUpdated = timestamp;\n                sync.postRender(_this.scheduleVelocityCheck);\n            }\n            // Update update subscribers\n            if (_this.prev !== _this.current) {\n                _this.updateSubscribers.notify(_this.current);\n            }\n            // Update velocity subscribers\n            if (_this.velocityUpdateSubscribers.getSize()) {\n                _this.velocityUpdateSubscribers.notify(_this.getVelocity());\n            }\n            // Update render subscribers\n            if (render) {\n                _this.renderSubscribers.notify(_this.current);\n            }\n        };\n        /**\n         * Schedule a velocity check for the next frame.\n         *\n         * This is an instanced and bound function to prevent generating a new\n         * function once per frame.\n         *\n         * @internal\n         */\n        this.scheduleVelocityCheck = function () { return sync.postRender(_this.velocityCheck); };\n        /**\n         * Updates `prev` with `current` if the value hasn't been updated this frame.\n         * This ensures velocity calculations return `0`.\n         *\n         * This is an instanced and bound function to prevent generating a new\n         * function once per frame.\n         *\n         * @internal\n         */\n        this.velocityCheck = function (_a) {\n            var timestamp = _a.timestamp;\n            if (timestamp !== _this.lastUpdated) {\n                _this.prev = _this.current;\n                _this.velocityUpdateSubscribers.notify(_this.getVelocity());\n            }\n        };\n        this.hasAnimated = false;\n        this.prev = this.current = init;\n        this.canTrackVelocity = isFloat(this.current);\n        this.onSubscription = () => { }\n        this.onUnsubscription = () => { }\n        if (startStopNotifier) {\n            this.onSubscription = () => {\n                if (this.updateSubscribers.getSize() + this.velocityUpdateSubscribers.getSize() + this.renderSubscribers.getSize() === 0) {\n\n                    const unsub = startStopNotifier()\n                    this.onUnsubscription = () => { }\n                    if (unsub) {\n                        this.onUnsubscription = () => {\n                            if (this.updateSubscribers.getSize() + this.velocityUpdateSubscribers.getSize() + this.renderSubscribers.getSize() === 0) {\n                                unsub()\n                            }\n                        }\n                    }\n\n                }\n            }\n        }\n    }\n    /**\n     * Adds a function that will be notified when the `MotionValue` is updated.\n     *\n     * It returns a function that, when called, will cancel the subscription.\n     *\n     * When calling `onChange` inside a React component, it should be wrapped with the\n     * `useEffect` hook. As it returns an unsubscribe function, this should be returned\n     * from the `useEffect` function to ensure you don't add duplicate subscribers..\n     *\n     * @motion\n     *\n     * ```jsx\n     * export const MyComponent = () => {\n     *   const x = useMotionValue(0)\n     *   const y = useMotionValue(0)\n     *   const opacity = useMotionValue(1)\n     *\n     *   useEffect(() => {\n     *     function updateOpacity() {\n     *       const maxXY = Math.max(x.get(), y.get())\n     *       const newOpacity = transform(maxXY, [0, 100], [1, 0])\n     *       opacity.set(newOpacity)\n     *     }\n     *\n     *     const unsubscribeX = x.onChange(updateOpacity)\n     *     const unsubscribeY = y.onChange(updateOpacity)\n     *\n     *     return () => {\n     *       unsubscribeX()\n     *       unsubscribeY()\n     *     }\n     *   }, [])\n     *\n     *   return <MotionDiv style={{ x }} />\n     * }\n     * ```\n     *\n     * @internalremarks\n     *\n     * We could look into a `useOnChange` hook if the above lifecycle management proves confusing.\n     *\n     * ```jsx\n     * useOnChange(x, () => {})\n     * ```\n     *\n     * @param subscriber - A function that receives the latest value.\n     * @returns A function that, when called, will cancel this subscription.\n     *\n     * @public\n     */\n    MotionValue.prototype.onChange = function (subscription) {\n        this.onSubscription();\n        const unsub = this.updateSubscribers.add(subscription);\n        return () => {\n            unsub()\n            this.onUnsubscription()\n\n        }\n    };\n    /** Add subscribe method for Svelte store interface */\n    MotionValue.prototype.subscribe = function (subscription) {\n        return this.onChange(subscription);\n    };\n\n    MotionValue.prototype.clearListeners = function () {\n        this.updateSubscribers.clear();\n        this.onUnsubscription()\n    };\n    /**\n     * Adds a function that will be notified when the `MotionValue` requests a render.\n     *\n     * @param subscriber - A function that's provided the latest value.\n     * @returns A function that, when called, will cancel this subscription.\n     *\n     * @internal\n     */\n    MotionValue.prototype.onRenderRequest = function (subscription) {\n        this.onSubscription()\n        // Render immediately\n        subscription(this.get());\n        const unsub = this.renderSubscribers.add(subscription);\n        return () => {\n            unsub()\n            this.onUnsubscription()\n        }\n    };\n    /**\n     * Attaches a passive effect to the `MotionValue`.\n     *\n     * @internal\n     */\n    MotionValue.prototype.attach = function (passiveEffect) {\n        this.passiveEffect = passiveEffect;\n    };\n    /**\n     * Sets the state of the `MotionValue`.\n     *\n     * @remarks\n     *\n     * ```jsx\n     * const x = useMotionValue(0)\n     * x.set(10)\n     * ```\n     *\n     * @param latest - Latest value to set.\n     * @param render - Whether to notify render subscribers. Defaults to `true`\n     *\n     * @public\n     */\n    MotionValue.prototype.set = function (v, render) {\n        if (render === void 0) { render = true; }\n        if (!render || !this.passiveEffect) {\n            this.updateAndNotify(v, render);\n        }\n        else {\n            this.passiveEffect(v, this.updateAndNotify);\n        }\n    };\n    /** Add update method for Svelte Store behavior */\n    MotionValue.prototype.update = function (v) {\n        this.set(v(this.get()));\n    }\n    /**\n     * Returns the latest state of `MotionValue`\n     *\n     * @returns - The latest state of `MotionValue`\n     *\n     * @public\n     */\n    MotionValue.prototype.get = function () {\n        this.onSubscription()\n        const curr = this.current;\n        this.onUnsubscription()\n        return curr\n    };\n    /**\n     * @public\n     */\n    MotionValue.prototype.getPrevious = function () {\n        return this.prev;\n    };\n    /**\n     * Returns the latest velocity of `MotionValue`\n     *\n     * @returns - The latest velocity of `MotionValue`. Returns `0` if the state is non-numerical.\n     *\n     * @public\n     */\n    MotionValue.prototype.getVelocity = function () {\n        // This could be isFloat(this.prev) && isFloat(this.current), but that would be wasteful\n        this.onSubscription()\n        const vel = this.canTrackVelocity\n            ? // These casts could be avoided if parseFloat would be typed better\n            velocityPerSecond(parseFloat(this.current) -\n                parseFloat(this.prev), this.timeDelta)\n            : 0;\n        this.onUnsubscription()\n        return vel;\n    };\n    /**\n     * Registers a new animation to control this `MotionValue`. Only one\n     * animation can drive a `MotionValue` at one time.\n     *\n     * ```jsx\n     * value.start()\n     * ```\n     *\n     * @param animation - A function that starts the provided animation\n     *\n     * @internal\n     */\n    MotionValue.prototype.start = function (animation) {\n        var _this = this;\n        this.stop();\n        return new Promise(function (resolve) {\n            _this.hasAnimated = true;\n            _this.stopAnimation = animation(resolve);\n        }).then(function () { return _this.clearAnimation(); });\n    };\n    /**\n     * Stop the currently active animation.\n     *\n     * @public\n     */\n    MotionValue.prototype.stop = function () {\n        if (this.stopAnimation)\n            this.stopAnimation();\n        this.clearAnimation();\n    };\n    /**\n     * Returns `true` if this value is currently animating.\n     *\n     * @public\n     */\n    MotionValue.prototype.isAnimating = function () {\n        return !!this.stopAnimation;\n    };\n    MotionValue.prototype.clearAnimation = function () {\n        this.stopAnimation = null;\n    };\n    /**\n     * Destroy and clean up subscribers to this `MotionValue`.\n     *\n     * The `MotionValue` hooks like `useMotionValue` and `useTransform` automatically\n     * handle the lifecycle of the returned `MotionValue`, so this method is only necessary if you've manually\n     * created a `MotionValue` via the `motionValue` function.\n     *\n     * @public\n     */\n    MotionValue.prototype.destroy = function () {\n        this.updateSubscribers.clear();\n        this.renderSubscribers.clear();\n        this.stop();\n        this.onUnsubscription()\n    };\n    return MotionValue;\n}());\n/**\n * @internal\n */\nfunction motionValue(init, startStopNotifier) {\n    return new MotionValue(init, startStopNotifier);\n}\n\nexport { MotionValue, motionValue };\n\n"],
  "mappings": "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",
  "names": ["Presence", "VisibilityAction", "transformPoint", "layoutState", "order", "isMouseEvent", "ctx", "PanSession", "info", "point", "timestamp", "_a", "event", "progress", "delta", "_a", "AnimationType", "scale", "delta", "VisualElementDragControls", "_a", "_b", "_c", "inertia", "SubscriptionManager", "MotionValue", "init", "delta"]
}
