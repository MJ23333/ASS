import {
  MotionConfigContext,
  ScaleCorrectionContext,
  ScaleCorrectionParentContext,
  provideScaleCorrection
} from "./chunk-KNJTIMYH.js";
import {
  setDomContext
} from "./chunk-OTU5X46N.js";
import {
  writable
} from "./chunk-F4TPOVUK.js";
import "./chunk-X7HCJ7ZS.js";
import {
  SvelteComponentDev,
  component_subscribe,
  create_slot,
  dispatch_dev,
  getContext,
  get_all_dirty_from_scope,
  get_slot_changes,
  get_store_value,
  init,
  safe_not_equal,
  setContext,
  transition_in,
  transition_out,
  update_slot_base,
  validate_slots,
  validate_store
} from "./chunk-POX46NQO.js";
import "./chunk-NRUTNXHJ.js";
import "./chunk-2NWPA7HM.js";
import "./chunk-WTEL7FPM.js";

// node_modules/svelte-motion/src/components/MotionConfig/MotionConfigScaleCorrection.js
var scaleCorrection = () => {
  const scaleCorrectionContext = getContext(ScaleCorrectionContext);
  const scaleCorrectionParentContext = getContext(
    ScaleCorrectionParentContext
  );
  const afterU = (nc = false) => {
    const scc = get_store_value(scaleCorrectionContext);
    scc.forEach((v, i) => {
      var _a;
      (_a = v.afterU) == null ? void 0 : _a.call(v, true);
    });
  };
  const updater = () => {
    get_store_value(scaleCorrectionContext).forEach((v) => {
      var _a;
      (_a = v.updater) == null ? void 0 : _a.call(v, true);
    });
  };
  scaleCorrectionParentContext.update(
    (v) => v.concat([
      {
        updater,
        afterU
      }
    ])
  );
  return {
    update: updater
  };
};

// node_modules/svelte-motion/src/components/MotionConfig/MotionConfig.svelte
function create_fragment(ctx) {
  let current;
  const default_slot_template = (
    /*#slots*/
    ctx[9].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[8],
    null
  );
  const block = {
    c: function create() {
      if (default_slot)
        default_slot.c();
    },
    l: function claim(nodes) {
      if (default_slot)
        default_slot.l(nodes);
    },
    m: function mount(target, anchor) {
      if (default_slot) {
        default_slot.m(target, anchor);
      }
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope*/
        256)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[8],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[8]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[8],
              dirty,
              null
            ),
            null
          );
        }
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(default_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (default_slot)
        default_slot.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance($$self, $$props, $$invalidate) {
  let transitionDependency;
  let $mcc;
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("MotionConfig", slots, ["default"]);
  let { transformPagePoint = void 0, isStatic = void 0, transition = void 0, isCustom = false } = $$props;
  const mcc = getContext(MotionConfigContext) || MotionConfigContext(isCustom);
  validate_store(mcc, "mcc");
  component_subscribe($$self, mcc, (value) => $$invalidate(7, $mcc = value));
  let config = {
    ...get_store_value(mcc),
    ...{ transformPagePoint, isStatic, transition }
  };
  provideScaleCorrection();
  let context = writable(config);
  setContext(MotionConfigContext, context);
  setDomContext("Motion", isCustom, context);
  const memo = () => config;
  const scaleCorrector = scaleCorrection();
  const writable_props = ["transformPagePoint", "isStatic", "transition", "isCustom"];
  Object.keys($$props).forEach((key) => {
    if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$" && key !== "slot")
      console.warn(`<MotionConfig> was created with unknown prop '${key}'`);
  });
  $$self.$$set = ($$props2) => {
    if ("transformPagePoint" in $$props2)
      $$invalidate(1, transformPagePoint = $$props2.transformPagePoint);
    if ("isStatic" in $$props2)
      $$invalidate(2, isStatic = $$props2.isStatic);
    if ("transition" in $$props2)
      $$invalidate(3, transition = $$props2.transition);
    if ("isCustom" in $$props2)
      $$invalidate(4, isCustom = $$props2.isCustom);
    if ("$$scope" in $$props2)
      $$invalidate(8, $$scope = $$props2.$$scope);
  };
  $$self.$capture_state = () => ({
    getContext,
    setContext,
    writable,
    get: get_store_value,
    setDomContext,
    MotionConfigContext,
    provideScaleCorrection,
    scaleCorrection,
    transformPagePoint,
    isStatic,
    transition,
    isCustom,
    mcc,
    config,
    context,
    memo,
    scaleCorrector,
    transitionDependency,
    $mcc
  });
  $$self.$inject_state = ($$props2) => {
    if ("transformPagePoint" in $$props2)
      $$invalidate(1, transformPagePoint = $$props2.transformPagePoint);
    if ("isStatic" in $$props2)
      $$invalidate(2, isStatic = $$props2.isStatic);
    if ("transition" in $$props2)
      $$invalidate(3, transition = $$props2.transition);
    if ("isCustom" in $$props2)
      $$invalidate(4, isCustom = $$props2.isCustom);
    if ("config" in $$props2)
      $$invalidate(5, config = $$props2.config);
    if ("context" in $$props2)
      $$invalidate(10, context = $$props2.context);
    if ("transitionDependency" in $$props2)
      $$invalidate(6, transitionDependency = $$props2.transitionDependency);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$self.$$.update = () => {
    if ($$self.$$.dirty & /*$mcc, transformPagePoint, isStatic, transition*/
    142) {
      $:
        $$invalidate(5, config = {
          ...$mcc,
          ...{ transformPagePoint, isStatic, transition }
        });
    }
    if ($$self.$$.dirty & /*config*/
    32) {
      $:
        $$invalidate(6, transitionDependency = typeof config.transition === "object" ? config.transition.toString() : "");
    }
    if ($$self.$$.dirty & /*transitionDependency, config*/
    96) {
      $: {
        context.set(memo(transitionDependency, config.transformPagePoint));
        scaleCorrector.update();
      }
    }
  };
  return [
    mcc,
    transformPagePoint,
    isStatic,
    transition,
    isCustom,
    config,
    transitionDependency,
    $mcc,
    $$scope,
    slots
  ];
}
var MotionConfig = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance, create_fragment, safe_not_equal, {
      transformPagePoint: 1,
      isStatic: 2,
      transition: 3,
      isCustom: 4
    });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "MotionConfig",
      options,
      id: create_fragment.name
    });
  }
  get transformPagePoint() {
    throw new Error("<MotionConfig>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set transformPagePoint(value) {
    throw new Error("<MotionConfig>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get isStatic() {
    throw new Error("<MotionConfig>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set isStatic(value) {
    throw new Error("<MotionConfig>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get transition() {
    throw new Error("<MotionConfig>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set transition(value) {
    throw new Error("<MotionConfig>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get isCustom() {
    throw new Error("<MotionConfig>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set isCustom(value) {
    throw new Error("<MotionConfig>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var MotionConfig_default = MotionConfig;
export {
  MotionConfig_default as default
};
//# sourceMappingURL=svelte-motion_src_components_MotionConfig_MotionConfig__svelte.js.map
