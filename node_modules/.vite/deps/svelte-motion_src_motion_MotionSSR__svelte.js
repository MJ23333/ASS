import {
  AnimationType,
  FramerTreeLayoutContext,
  MotionContext,
  PanSession,
  Presence,
  SharedLayoutContext,
  SubscriptionManager,
  UseDomEvent_default,
  UsePointerEvent_default,
  VisualElementDragControls,
  addPointerEvent,
  addUniqueItem,
  applyBoxTransforms,
  applyTreeDeltas,
  axisBox,
  calcRelativeBox,
  calcRelativeOffset,
  compareByDepth,
  delta,
  eachAxis,
  fixed,
  getAnimatableNone,
  getBoundingBox,
  getDefaultValueType,
  getValueTransition,
  isDragActive,
  isDraggable,
  isKeyframesTarget,
  isMotionValue,
  isMouseEvent,
  isRefObject,
  isSharedLayout,
  isTransformOriginProp,
  isTransformProp,
  motionValue,
  numberValueTypes,
  removeBoxTransforms,
  removeItem,
  resetBox,
  snapshotViewportBox,
  sortTransformProps,
  startAnimation,
  transformProps,
  tweenAxis,
  updateBoxDelta
} from "./chunk-VVTWI2QP.js";
import {
  mix,
  pipe
} from "./chunk-IXYIOGO3.js";
import "./chunk-DPJLTTUP.js";
import {
  MotionConfigContext,
  ScaleCorrectionContext,
  ScaleCorrectionParentContext,
  ScaleCorrectionProvider_default
} from "./chunk-KNJTIMYH.js";
import {
  getDomContext,
  setDomContext
} from "./chunk-OTU5X46N.js";
import {
  __assign,
  __read,
  __rest,
  __spreadArray
} from "./chunk-STGXCCFQ.js";
import {
  cancelSync,
  es_default
} from "./chunk-F3MIBQYA.js";
import {
  color,
  complex,
  degrees,
  number,
  percent,
  px,
  vh,
  vw
} from "./chunk-NXTUI3FV.js";
import "./chunk-NRUTNXHJ.js";
import {
  derived,
  readable,
  writable
} from "./chunk-F4TPOVUK.js";
import "./chunk-X7HCJ7ZS.js";
import {
  SvelteComponentDev,
  afterUpdate,
  assign,
  beforeUpdate,
  check_outros,
  claim_component,
  claim_space,
  component_subscribe,
  compute_rest_props,
  construct_svelte_component_dev,
  create_component,
  create_slot,
  destroy_component,
  detach_dev,
  dispatch_dev,
  empty,
  ensure_array_like_dev,
  exclude_internal_props,
  getContext,
  get_all_dirty_from_scope,
  get_slot_changes,
  get_store_value,
  globals,
  group_outros,
  init,
  insert_hydration_dev,
  mount_component,
  noop,
  onDestroy,
  onMount,
  outro_and_destroy_block,
  safe_not_equal,
  setContext,
  space,
  tick,
  transition_in,
  transition_out,
  update_keyed_each,
  update_slot_base,
  validate_each_keys,
  validate_slots,
  validate_store
} from "./chunk-POX46NQO.js";
import "./chunk-2NWPA7HM.js";
import {
  __require
} from "./chunk-WTEL7FPM.js";

// node_modules/svelte-motion/src/context/PresenceContext.js
var PresenceContext = (c) => getDomContext("Presence", c) || writable(null);

// node_modules/svelte-motion/src/context/LazyContext.js
var LazyContext = (c) => getDomContext("Lazy", c) || writable({ strict: false });

// node_modules/svelte-motion/src/context/LayoutGroupContext.js
var LayoutGroupContext = (c) => getDomContext("LayoutGroup", c) || writable(null);

// node_modules/svelte-motion/src/components/AnimatePresence/use-presence.js
var counter = 0;
var incrementId = () => counter++;
function isPresent(context) {
  return context === null ? true : context.isPresent;
}
var usePresence = (isCustom = false) => {
  const context = getContext(PresenceContext) || PresenceContext(isCustom);
  const id = get_store_value(context) === null ? void 0 : incrementId();
  onMount(() => {
    if (get_store_value(context) !== null) {
      get_store_value(context).register(id);
    }
  });
  if (get_store_value(context) === null) {
    return readable([true, null]);
  }
  return derived(
    context,
    ($v) => !$v.isPresent && $v.onExitComplete ? [false, () => {
      var _a;
      return (_a = $v.onExitComplete) == null ? void 0 : _a.call($v, id);
    }] : [true]
  );
};

// node_modules/svelte-motion/src/motion/utils/UseVisualElement.svelte
var get_default_slot_changes = (dirty) => ({
  visualElement: dirty & /*visualElement*/
  1
});
var get_default_slot_context = (ctx) => ({ visualElement: (
  /*visualElement*/
  ctx[0]
) });
function create_fragment(ctx) {
  let current;
  const default_slot_template = (
    /*#slots*/
    ctx[19].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[18],
    get_default_slot_context
  );
  const block = {
    c: function create() {
      if (default_slot)
        default_slot.c();
    },
    l: function claim(nodes) {
      if (default_slot)
        default_slot.l(nodes);
    },
    m: function mount(target, anchor) {
      if (default_slot) {
        default_slot.m(target, anchor);
      }
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope, visualElement*/
        262145)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[18],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[18]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[18],
              dirty,
              get_default_slot_changes
            ),
            get_default_slot_context
          );
        }
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(default_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (default_slot)
        default_slot.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
var ssr = false;
function instance($$self, $$props, $$invalidate) {
  let $presenceContext;
  let $config;
  let $lazyContext;
  let $layoutGroupId;
  let $mc;
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("UseVisualElement", slots, ["default"]);
  let { createVisualElement = void 0, props, Component, visualState, isCustom } = $$props;
  const config = getContext(MotionConfigContext) || MotionConfigContext(isCustom);
  validate_store(config, "config");
  component_subscribe($$self, config, (value) => $$invalidate(15, $config = value));
  const presenceContext = getContext(PresenceContext) || PresenceContext(isCustom);
  validate_store(presenceContext, "presenceContext");
  component_subscribe($$self, presenceContext, (value) => $$invalidate(14, $presenceContext = value));
  const lazyContext = getContext(LazyContext) || LazyContext(isCustom);
  validate_store(lazyContext, "lazyContext");
  component_subscribe($$self, lazyContext, (value) => $$invalidate(20, $lazyContext = value));
  const mc = getContext(MotionContext) || MotionContext(isCustom);
  validate_store(mc, "mc");
  component_subscribe($$self, mc, (value) => $$invalidate(17, $mc = value));
  let parent = get_store_value(mc).visualElement;
  const layoutGroupId = getContext(LayoutGroupContext) || LayoutGroupContext(isCustom);
  validate_store(layoutGroupId, "layoutGroupId");
  component_subscribe($$self, layoutGroupId, (value) => $$invalidate(16, $layoutGroupId = value));
  let layoutId = $layoutGroupId && props.layoutId !== void 0 ? $layoutGroupId + "-" + props.layoutId : props.layoutId;
  let visualElementRef = void 0;
  if (!createVisualElement) {
    createVisualElement = $lazyContext.renderer;
  }
  let visualElement2 = visualElementRef;
  afterUpdate(() => {
    tick().then(() => {
      var _a;
      (_a = visualElement2.animationState) == null ? void 0 : _a.animateChanges();
    });
  });
  onDestroy(() => {
    visualElement2 == null ? void 0 : visualElement2.notifyUnmount();
  });
  $$self.$$.on_mount.push(function() {
    if (props === void 0 && !("props" in $$props || $$self.$$.bound[$$self.$$.props["props"]])) {
      console.warn("<UseVisualElement> was created without expected prop 'props'");
    }
    if (Component === void 0 && !("Component" in $$props || $$self.$$.bound[$$self.$$.props["Component"]])) {
      console.warn("<UseVisualElement> was created without expected prop 'Component'");
    }
    if (visualState === void 0 && !("visualState" in $$props || $$self.$$.bound[$$self.$$.props["visualState"]])) {
      console.warn("<UseVisualElement> was created without expected prop 'visualState'");
    }
    if (isCustom === void 0 && !("isCustom" in $$props || $$self.$$.bound[$$self.$$.props["isCustom"]])) {
      console.warn("<UseVisualElement> was created without expected prop 'isCustom'");
    }
  });
  const writable_props = ["createVisualElement", "props", "Component", "visualState", "isCustom"];
  Object.keys($$props).forEach((key) => {
    if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$" && key !== "slot")
      console.warn(`<UseVisualElement> was created with unknown prop '${key}'`);
  });
  $$self.$$set = ($$props2) => {
    if ("createVisualElement" in $$props2)
      $$invalidate(6, createVisualElement = $$props2.createVisualElement);
    if ("props" in $$props2)
      $$invalidate(7, props = $$props2.props);
    if ("Component" in $$props2)
      $$invalidate(8, Component = $$props2.Component);
    if ("visualState" in $$props2)
      $$invalidate(9, visualState = $$props2.visualState);
    if ("isCustom" in $$props2)
      $$invalidate(10, isCustom = $$props2.isCustom);
    if ("$$scope" in $$props2)
      $$invalidate(18, $$scope = $$props2.$$scope);
  };
  $$self.$capture_state = () => ({
    ssr,
    afterUpdate,
    getContext,
    onDestroy,
    tick,
    PresenceContext,
    LazyContext,
    MotionConfigContext,
    LayoutGroupContext,
    MotionContext,
    isPresent,
    get: get_store_value,
    createVisualElement,
    props,
    Component,
    visualState,
    isCustom,
    config,
    presenceContext,
    lazyContext,
    mc,
    parent,
    layoutGroupId,
    layoutId,
    visualElementRef,
    visualElement: visualElement2,
    $presenceContext,
    $config,
    $lazyContext,
    $layoutGroupId,
    $mc
  });
  $$self.$inject_state = ($$props2) => {
    if ("createVisualElement" in $$props2)
      $$invalidate(6, createVisualElement = $$props2.createVisualElement);
    if ("props" in $$props2)
      $$invalidate(7, props = $$props2.props);
    if ("Component" in $$props2)
      $$invalidate(8, Component = $$props2.Component);
    if ("visualState" in $$props2)
      $$invalidate(9, visualState = $$props2.visualState);
    if ("isCustom" in $$props2)
      $$invalidate(10, isCustom = $$props2.isCustom);
    if ("parent" in $$props2)
      $$invalidate(11, parent = $$props2.parent);
    if ("layoutId" in $$props2)
      $$invalidate(12, layoutId = $$props2.layoutId);
    if ("visualElementRef" in $$props2)
      $$invalidate(13, visualElementRef = $$props2.visualElementRef);
    if ("visualElement" in $$props2)
      $$invalidate(0, visualElement2 = $$props2.visualElement);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$self.$$.update = () => {
    if ($$self.$$.dirty & /*$mc*/
    131072) {
      $:
        $$invalidate(11, parent = $mc.visualElement);
    }
    if ($$self.$$.dirty & /*$layoutGroupId, props*/
    65664) {
      $:
        $$invalidate(12, layoutId = $layoutGroupId && props.layoutId !== void 0 ? $layoutGroupId + "-" + props.layoutId : props.layoutId);
    }
    if ($$self.$$.dirty & /*visualElementRef, createVisualElement, Component, visualState, parent, props, layoutId, $presenceContext*/
    31680) {
      $:
        if (!visualElementRef && createVisualElement) {
          $$invalidate(13, visualElementRef = createVisualElement(Component, {
            visualState,
            parent,
            props: { ...props, layoutId },
            presenceId: $presenceContext == null ? void 0 : $presenceContext.id,
            blockInitialAnimation: ($presenceContext == null ? void 0 : $presenceContext.initial) === false
          }));
        }
    }
    if ($$self.$$.dirty & /*visualElementRef*/
    8192) {
      $:
        $$invalidate(0, visualElement2 = visualElementRef);
    }
    if ($$self.$$.dirty & /*visualElement, $config, props, layoutId, $presenceContext, parent*/
    55425) {
      $:
        if (visualElement2) {
          visualElement2.setProps({ ...$config, ...props, layoutId });
          $$invalidate(0, visualElement2.isPresent = isPresent($presenceContext), visualElement2);
          $$invalidate(0, visualElement2.isPresenceRoot = !parent || parent.presenceId !== ($presenceContext == null ? void 0 : $presenceContext.id), visualElement2);
          visualElement2.syncRender();
        }
    }
  };
  return [
    visualElement2,
    config,
    presenceContext,
    lazyContext,
    mc,
    layoutGroupId,
    createVisualElement,
    props,
    Component,
    visualState,
    isCustom,
    parent,
    layoutId,
    visualElementRef,
    $presenceContext,
    $config,
    $layoutGroupId,
    $mc,
    $$scope,
    slots
  ];
}
var UseVisualElement = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance, create_fragment, safe_not_equal, {
      createVisualElement: 6,
      props: 7,
      Component: 8,
      visualState: 9,
      isCustom: 10
    });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "UseVisualElement",
      options,
      id: create_fragment.name
    });
  }
  get createVisualElement() {
    throw new Error("<UseVisualElement>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set createVisualElement(value) {
    throw new Error("<UseVisualElement>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get props() {
    throw new Error("<UseVisualElement>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set props(value) {
    throw new Error("<UseVisualElement>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get Component() {
    throw new Error("<UseVisualElement>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set Component(value) {
    throw new Error("<UseVisualElement>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get visualState() {
    throw new Error("<UseVisualElement>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set visualState(value) {
    throw new Error("<UseVisualElement>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get isCustom() {
    throw new Error("<UseVisualElement>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set isCustom(value) {
    throw new Error("<UseVisualElement>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var UseVisualElement_default = UseVisualElement;

// node_modules/svelte-motion/src/motion/features/definitions.js
var createDefinition = function(propNames) {
  return {
    isEnabled: function(props) {
      return propNames.some(function(name) {
        return !!props[name];
      });
    }
  };
};
var featureDefinitions = {
  measureLayout: createDefinition(["layout", "layoutId", "drag"]),
  animation: createDefinition([
    "animate",
    "exit",
    "variants",
    "whileHover",
    "whileTap",
    "whileFocus",
    "whileDrag"
  ]),
  exit: createDefinition(["exit"]),
  drag: createDefinition(["drag", "dragControls"]),
  focus: createDefinition(["whileFocus"]),
  hover: createDefinition(["whileHover", "onHoverStart", "onHoverEnd"]),
  tap: createDefinition(["whileTap", "onTap", "onTapStart", "onTapCancel"]),
  pan: createDefinition([
    "onPan",
    "onPanStart",
    "onPanSessionStart",
    "onPanEnd"
  ]),
  layoutAnimation: createDefinition(["layout", "layoutId"])
};
function loadFeatures(features) {
  for (var key in features) {
    var Component = features[key];
    if (Component !== null) {
      featureDefinitions[key].Component = Component;
    }
  }
}

// node_modules/svelte-motion/src/motion/features/UseFeatures.svelte
var { Object: Object_1 } = globals;
var get_default_slot_changes2 = (dirty) => ({ features: dirty & /*features*/
2 });
var get_default_slot_context2 = (ctx) => ({ features: (
  /*features*/
  ctx[1]
) });
function create_if_block(ctx) {
  let current;
  const default_slot_template = (
    /*#slots*/
    ctx[4].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[3],
    get_default_slot_context2
  );
  const block = {
    c: function create() {
      if (default_slot)
        default_slot.c();
    },
    l: function claim(nodes) {
      if (default_slot)
        default_slot.l(nodes);
    },
    m: function mount(target, anchor) {
      if (default_slot) {
        default_slot.m(target, anchor);
      }
      current = true;
    },
    p: function update(ctx2, dirty) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope, features*/
        10)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[3],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[3]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[3],
              dirty,
              get_default_slot_changes2
            ),
            get_default_slot_context2
          );
        }
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(default_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (default_slot)
        default_slot.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block.name,
    type: "if",
    source: "(40:0) {#if visualElement}",
    ctx
  });
  return block;
}
function create_fragment2(ctx) {
  let if_block_anchor;
  let current;
  let if_block = (
    /*visualElement*/
    ctx[0] && create_if_block(ctx)
  );
  const block = {
    c: function create() {
      if (if_block)
        if_block.c();
      if_block_anchor = empty();
    },
    l: function claim(nodes) {
      if (if_block)
        if_block.l(nodes);
      if_block_anchor = empty();
    },
    m: function mount(target, anchor) {
      if (if_block)
        if_block.m(target, anchor);
      insert_hydration_dev(target, if_block_anchor, anchor);
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      if (
        /*visualElement*/
        ctx2[0]
      ) {
        if (if_block) {
          if_block.p(ctx2, dirty);
          if (dirty & /*visualElement*/
          1) {
            transition_in(if_block, 1);
          }
        } else {
          if_block = create_if_block(ctx2);
          if_block.c();
          transition_in(if_block, 1);
          if_block.m(if_block_anchor.parentNode, if_block_anchor);
        }
      } else if (if_block) {
        group_outros();
        transition_out(if_block, 1, 1, () => {
          if_block = null;
        });
        check_outros();
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(if_block);
      current = true;
    },
    o: function outro(local) {
      transition_out(if_block);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(if_block_anchor);
      }
      if (if_block)
        if_block.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment2.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance2($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("UseFeatures", slots, ["default"]);
  const featureNames = Object.keys(featureDefinitions);
  const numFeatures = featureNames.length;
  let { visualElement: visualElement2, props } = $$props;
  let features = [];
  $$self.$$.on_mount.push(function() {
    if (visualElement2 === void 0 && !("visualElement" in $$props || $$self.$$.bound[$$self.$$.props["visualElement"]])) {
      console.warn("<UseFeatures> was created without expected prop 'visualElement'");
    }
    if (props === void 0 && !("props" in $$props || $$self.$$.bound[$$self.$$.props["props"]])) {
      console.warn("<UseFeatures> was created without expected prop 'props'");
    }
  });
  const writable_props = ["visualElement", "props"];
  Object_1.keys($$props).forEach((key) => {
    if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$" && key !== "slot")
      console.warn(`<UseFeatures> was created with unknown prop '${key}'`);
  });
  $$self.$$set = ($$props2) => {
    if ("visualElement" in $$props2)
      $$invalidate(0, visualElement2 = $$props2.visualElement);
    if ("props" in $$props2)
      $$invalidate(2, props = $$props2.props);
    if ("$$scope" in $$props2)
      $$invalidate(3, $$scope = $$props2.$$scope);
  };
  $$self.$capture_state = () => ({
    featureDefinitions,
    featureNames,
    numFeatures,
    visualElement: visualElement2,
    props,
    features
  });
  $$self.$inject_state = ($$props2) => {
    if ("visualElement" in $$props2)
      $$invalidate(0, visualElement2 = $$props2.visualElement);
    if ("props" in $$props2)
      $$invalidate(2, props = $$props2.props);
    if ("features" in $$props2)
      $$invalidate(1, features = $$props2.features);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$self.$$.update = () => {
    if ($$self.$$.dirty & /*props, features, visualElement*/
    7) {
      $: {
        $$invalidate(1, features = []);
        for (let i = 0; i < numFeatures; i++) {
          const name = featureNames[i];
          const { isEnabled, Component } = featureDefinitions[name];
          if (isEnabled(props) && Component) {
            features.push({
              Component,
              key: name,
              props,
              visualElement: visualElement2
            });
          }
        }
      }
    }
  };
  return [visualElement2, features, props, $$scope, slots];
}
var UseFeatures = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance2, create_fragment2, safe_not_equal, { visualElement: 0, props: 2 });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "UseFeatures",
      options,
      id: create_fragment2.name
    });
  }
  get visualElement() {
    throw new Error("<UseFeatures>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set visualElement(value) {
    throw new Error("<UseFeatures>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get props() {
    throw new Error("<UseFeatures>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set props(value) {
    throw new Error("<UseFeatures>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var UseFeatures_default = UseFeatures;

// node_modules/svelte-motion/src/context/MotionContext/MotionContextProvider.svelte
function create_fragment3(ctx) {
  let current;
  const default_slot_template = (
    /*#slots*/
    ctx[3].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[2],
    null
  );
  const block = {
    c: function create() {
      if (default_slot)
        default_slot.c();
    },
    l: function claim(nodes) {
      if (default_slot)
        default_slot.l(nodes);
    },
    m: function mount(target, anchor) {
      if (default_slot) {
        default_slot.m(target, anchor);
      }
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope*/
        4)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[2],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[2]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[2],
              dirty,
              null
            ),
            null
          );
        }
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(default_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (default_slot)
        default_slot.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment3.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance3($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("MotionContextProvider", slots, ["default"]);
  let { value, isCustom } = $$props;
  let store = writable(value);
  setContext(MotionContext, store);
  setDomContext("Motion", isCustom, store);
  onDestroy(() => {
    var _a;
    (_a = value == null ? void 0 : value.visualElement) == null ? void 0 : _a.unmount();
  });
  $$self.$$.on_mount.push(function() {
    if (value === void 0 && !("value" in $$props || $$self.$$.bound[$$self.$$.props["value"]])) {
      console.warn("<MotionContextProvider> was created without expected prop 'value'");
    }
    if (isCustom === void 0 && !("isCustom" in $$props || $$self.$$.bound[$$self.$$.props["isCustom"]])) {
      console.warn("<MotionContextProvider> was created without expected prop 'isCustom'");
    }
  });
  const writable_props = ["value", "isCustom"];
  Object.keys($$props).forEach((key) => {
    if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$" && key !== "slot")
      console.warn(`<MotionContextProvider> was created with unknown prop '${key}'`);
  });
  $$self.$$set = ($$props2) => {
    if ("value" in $$props2)
      $$invalidate(0, value = $$props2.value);
    if ("isCustom" in $$props2)
      $$invalidate(1, isCustom = $$props2.isCustom);
    if ("$$scope" in $$props2)
      $$invalidate(2, $$scope = $$props2.$$scope);
  };
  $$self.$capture_state = () => ({
    onDestroy,
    setContext,
    writable,
    setDomContext,
    MotionContext,
    value,
    isCustom,
    store
  });
  $$self.$inject_state = ($$props2) => {
    if ("value" in $$props2)
      $$invalidate(0, value = $$props2.value);
    if ("isCustom" in $$props2)
      $$invalidate(1, isCustom = $$props2.isCustom);
    if ("store" in $$props2)
      $$invalidate(4, store = $$props2.store);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$self.$$.update = () => {
    if ($$self.$$.dirty & /*value*/
    1) {
      $:
        store.set(value);
    }
  };
  return [value, isCustom, $$scope, slots];
}
var MotionContextProvider = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance3, create_fragment3, safe_not_equal, { value: 0, isCustom: 1 });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "MotionContextProvider",
      options,
      id: create_fragment3.name
    });
  }
  get value() {
    throw new Error("<MotionContextProvider>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set value(value) {
    throw new Error("<MotionContextProvider>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get isCustom() {
    throw new Error("<MotionContextProvider>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set isCustom(value) {
    throw new Error("<MotionContextProvider>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var MotionContextProvider_default = MotionContextProvider;

// node_modules/svelte-motion/src/render/html/utils/create-render-state.js
var createHtmlRenderState = function() {
  return {
    style: {},
    transform: {},
    transformKeys: [],
    transformOrigin: {},
    vars: {}
  };
};

// node_modules/svelte-motion/src/render/svg/utils/create-render-state.js
var createSvgRenderState = function() {
  return __assign(__assign({}, createHtmlRenderState()), { attrs: {} });
};

// node_modules/svelte-motion/src/render/dom/projection/scale-correction.js
var valueScaleCorrection = {};
function addScaleCorrection(correctors) {
  for (var key in correctors) {
    valueScaleCorrection[key] = correctors[key];
  }
}

// node_modules/svelte-motion/src/motion/utils/is-forced-motion-value.js
function isForcedMotionValue(key, _a) {
  var layout = _a.layout, layoutId = _a.layoutId;
  return isTransformProp(key) || isTransformOriginProp(key) || (layout || layoutId !== void 0) && !!valueScaleCorrection[key];
}

// node_modules/svelte-motion/src/render/html/utils/build-transform.js
var translateAlias = {
  x: "translateX",
  y: "translateY",
  z: "translateZ",
  transformPerspective: "perspective"
};
function buildTransform(_a, _b, transformIsDefault, transformTemplate) {
  var transform = _a.transform, transformKeys2 = _a.transformKeys;
  var _c = _b.enableHardwareAcceleration, enableHardwareAcceleration = _c === void 0 ? true : _c, _d = _b.allowTransformNone, allowTransformNone = _d === void 0 ? true : _d;
  var transformString = "";
  transformKeys2.sort(sortTransformProps);
  var transformHasZ = false;
  var numTransformKeys = transformKeys2.length;
  for (var i = 0; i < numTransformKeys; i++) {
    var key = transformKeys2[i];
    transformString += (translateAlias[key] || key) + "(" + transform[key] + ") ";
    if (key === "z")
      transformHasZ = true;
  }
  if (!transformHasZ && enableHardwareAcceleration) {
    transformString += "translateZ(0)";
  } else {
    transformString = transformString.trim();
  }
  if (transformTemplate) {
    transformString = transformTemplate(transform, transformIsDefault ? "" : transformString);
  } else if (allowTransformNone && transformIsDefault) {
    transformString = "none";
  }
  return transformString;
}
function buildTransformOrigin(_a) {
  var _b = _a.originX, originX = _b === void 0 ? "50%" : _b, _c = _a.originY, originY = _c === void 0 ? "50%" : _c, _d = _a.originZ, originZ = _d === void 0 ? 0 : _d;
  return originX + " " + originY + " " + originZ;
}

// node_modules/svelte-motion/src/render/dom/utils/is-css-variable.js
function isCSSVariable(key) {
  return key.startsWith("--");
}

// node_modules/svelte-motion/src/render/dom/value-types/get-as-type.js
var getValueAsType = function(value, type) {
  return type && typeof value === "number" ? type.transform(value) : value;
};

// node_modules/svelte-motion/src/render/html/utils/build-styles.js
function buildHTMLStyles(state, latestValues, projection, layoutState, options, transformTemplate, buildProjectionTransform, buildProjectionTransformOrigin) {
  var _a;
  var style = state.style, vars = state.vars, transform = state.transform, transformKeys2 = state.transformKeys, transformOrigin = state.transformOrigin;
  transformKeys2.length = 0;
  var hasTransform = false;
  var hasTransformOrigin = false;
  var transformIsNone = true;
  for (var key in latestValues) {
    var value = latestValues[key];
    if (isCSSVariable(key)) {
      vars[key] = value;
      continue;
    }
    var valueType = numberValueTypes[key];
    var valueAsType = getValueAsType(value, valueType);
    if (isTransformProp(key)) {
      hasTransform = true;
      transform[key] = valueAsType;
      transformKeys2.push(key);
      if (!transformIsNone)
        continue;
      if (value !== ((_a = valueType.default) !== null && _a !== void 0 ? _a : 0))
        transformIsNone = false;
    } else if (isTransformOriginProp(key)) {
      transformOrigin[key] = valueAsType;
      hasTransformOrigin = true;
    } else {
      if (layoutState && projection && layoutState.isHydrated && valueScaleCorrection[key]) {
        var correctedValue = valueScaleCorrection[key].process(value, layoutState, projection);
        var applyTo = valueScaleCorrection[key].applyTo;
        if (applyTo) {
          var num = applyTo.length;
          for (var i = 0; i < num; i++) {
            style[applyTo[i]] = correctedValue;
          }
        } else {
          style[key] = correctedValue;
        }
      } else {
        style[key] = valueAsType;
      }
    }
  }
  if (layoutState && projection && buildProjectionTransform && buildProjectionTransformOrigin) {
    style.transform = buildProjectionTransform(layoutState.deltaFinal, layoutState.treeScale, hasTransform ? transform : void 0);
    if (transformTemplate) {
      style.transform = transformTemplate(transform, style.transform);
    }
    style.transformOrigin = buildProjectionTransformOrigin(layoutState);
  } else {
    if (hasTransform) {
      style.transform = buildTransform(state, options, transformIsNone, transformTemplate);
    }
    if (hasTransformOrigin) {
      style.transformOrigin = buildTransformOrigin(transformOrigin);
    }
  }
}

// node_modules/svelte-motion/src/render/html/UseInitialMotionValues.svelte
var get_default_slot_changes3 = (dirty) => ({ styles: dirty & /*styles*/
1 });
var get_default_slot_context3 = (ctx) => ({ styles: (
  /*styles*/
  ctx[0]
) });
function create_fragment4(ctx) {
  let current;
  const default_slot_template = (
    /*#slots*/
    ctx[5].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[4],
    get_default_slot_context3
  );
  const block = {
    c: function create() {
      if (default_slot)
        default_slot.c();
    },
    l: function claim(nodes) {
      if (default_slot)
        default_slot.l(nodes);
    },
    m: function mount(target, anchor) {
      if (default_slot) {
        default_slot.m(target, anchor);
      }
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope, styles*/
        17)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[4],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[4]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[4],
              dirty,
              get_default_slot_changes3
            ),
            get_default_slot_context3
          );
        }
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(default_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (default_slot)
        default_slot.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment4.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance4($$self, $$props, $$invalidate) {
  let styles;
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("UseInitialMotionValues", slots, ["default"]);
  let { visualState, isStatic, props } = $$props;
  const memo = () => {
    let state = createHtmlRenderState();
    buildHTMLStyles(state, visualState, void 0, void 0, { enableHardwareAcceleration: !isStatic }, props.transformTemplate);
    const { vars, style } = state;
    return { ...vars, ...style };
  };
  $$self.$$.on_mount.push(function() {
    if (visualState === void 0 && !("visualState" in $$props || $$self.$$.bound[$$self.$$.props["visualState"]])) {
      console.warn("<UseInitialMotionValues> was created without expected prop 'visualState'");
    }
    if (isStatic === void 0 && !("isStatic" in $$props || $$self.$$.bound[$$self.$$.props["isStatic"]])) {
      console.warn("<UseInitialMotionValues> was created without expected prop 'isStatic'");
    }
    if (props === void 0 && !("props" in $$props || $$self.$$.bound[$$self.$$.props["props"]])) {
      console.warn("<UseInitialMotionValues> was created without expected prop 'props'");
    }
  });
  const writable_props = ["visualState", "isStatic", "props"];
  Object.keys($$props).forEach((key) => {
    if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$" && key !== "slot")
      console.warn(`<UseInitialMotionValues> was created with unknown prop '${key}'`);
  });
  $$self.$$set = ($$props2) => {
    if ("visualState" in $$props2)
      $$invalidate(1, visualState = $$props2.visualState);
    if ("isStatic" in $$props2)
      $$invalidate(2, isStatic = $$props2.isStatic);
    if ("props" in $$props2)
      $$invalidate(3, props = $$props2.props);
    if ("$$scope" in $$props2)
      $$invalidate(4, $$scope = $$props2.$$scope);
  };
  $$self.$capture_state = () => ({
    buildHTMLStyles,
    createHtmlRenderState,
    visualState,
    isStatic,
    props,
    memo,
    styles
  });
  $$self.$inject_state = ($$props2) => {
    if ("visualState" in $$props2)
      $$invalidate(1, visualState = $$props2.visualState);
    if ("isStatic" in $$props2)
      $$invalidate(2, isStatic = $$props2.isStatic);
    if ("props" in $$props2)
      $$invalidate(3, props = $$props2.props);
    if ("styles" in $$props2)
      $$invalidate(0, styles = $$props2.styles);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$self.$$.update = () => {
    if ($$self.$$.dirty & /*visualState*/
    2) {
      $:
        $$invalidate(0, styles = memo(visualState));
    }
  };
  return [styles, visualState, isStatic, props, $$scope, slots];
}
var UseInitialMotionValues = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance4, create_fragment4, safe_not_equal, { visualState: 1, isStatic: 2, props: 3 });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "UseInitialMotionValues",
      options,
      id: create_fragment4.name
    });
  }
  get visualState() {
    throw new Error("<UseInitialMotionValues>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set visualState(value) {
    throw new Error("<UseInitialMotionValues>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get isStatic() {
    throw new Error("<UseInitialMotionValues>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set isStatic(value) {
    throw new Error("<UseInitialMotionValues>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get props() {
    throw new Error("<UseInitialMotionValues>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set props(value) {
    throw new Error("<UseInitialMotionValues>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var UseInitialMotionValues_default = UseInitialMotionValues;

// node_modules/svelte-motion/src/render/html/UseStyle.svelte
var { Object: Object_12 } = globals;
var get_default_slot_changes4 = (dirty) => ({ styles: dirty & /*s1, props, style*/
522 });
var get_default_slot_context4 = (ctx) => ({
  styles: (
    /*toStyle*/
    ctx[4](
      /*s1*/
      ctx[9],
      /*props*/
      ctx[1],
      /*style*/
      ctx[3]
    )
  )
});
function create_default_slot(ctx) {
  let current;
  const default_slot_template = (
    /*#slots*/
    ctx[6].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[7],
    get_default_slot_context4
  );
  const block = {
    c: function create() {
      if (default_slot)
        default_slot.c();
    },
    l: function claim(nodes) {
      if (default_slot)
        default_slot.l(nodes);
    },
    m: function mount(target, anchor) {
      if (default_slot) {
        default_slot.m(target, anchor);
      }
      current = true;
    },
    p: function update(ctx2, dirty) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope, s1, props, style*/
        650)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[7],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[7]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[7],
              dirty,
              get_default_slot_changes4
            ),
            get_default_slot_context4
          );
        }
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(default_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (default_slot)
        default_slot.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot.name,
    type: "slot",
    source: "(41:0) <UseInitialMotionValues {props} {visualState} {isStatic} let:styles={s1}>",
    ctx
  });
  return block;
}
function create_fragment5(ctx) {
  let useinitialmotionvalues;
  let current;
  useinitialmotionvalues = new UseInitialMotionValues_default({
    props: {
      props: (
        /*props*/
        ctx[1]
      ),
      visualState: (
        /*visualState*/
        ctx[0]
      ),
      isStatic: (
        /*isStatic*/
        ctx[2]
      ),
      $$slots: {
        default: [
          create_default_slot,
          ({ styles: s1 }) => ({ 9: s1 }),
          ({ styles: s1 }) => s1 ? 512 : 0
        ]
      },
      $$scope: { ctx }
    },
    $$inline: true
  });
  const block = {
    c: function create() {
      create_component(useinitialmotionvalues.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(useinitialmotionvalues.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(useinitialmotionvalues, target, anchor);
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      const useinitialmotionvalues_changes = {};
      if (dirty & /*props*/
      2)
        useinitialmotionvalues_changes.props = /*props*/
        ctx2[1];
      if (dirty & /*visualState*/
      1)
        useinitialmotionvalues_changes.visualState = /*visualState*/
        ctx2[0];
      if (dirty & /*isStatic*/
      4)
        useinitialmotionvalues_changes.isStatic = /*isStatic*/
        ctx2[2];
      if (dirty & /*$$scope, s1, props, style*/
      650) {
        useinitialmotionvalues_changes.$$scope = { dirty, ctx: ctx2 };
      }
      useinitialmotionvalues.$set(useinitialmotionvalues_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(useinitialmotionvalues.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(useinitialmotionvalues.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(useinitialmotionvalues, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment5.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function copyRawValuesOnly(target, source, props) {
  for (const key in source) {
    if (!isMotionValue(source[key]) && !isForcedMotionValue(key, props)) {
      target[key] = source[key];
    }
  }
}
function instance5($$self, $$props, $$invalidate) {
  let styleProp;
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("UseStyle", slots, ["default"]);
  let { visualState, props, isStatic } = $$props;
  let style = {};
  const cRVO = copyRawValuesOnly;
  const toStyle = (s1) => {
    Object.assign(style, s1);
    if (props.transformValues) {
      $$invalidate(3, style = props.transformValues(style));
    }
    return style;
  };
  $$self.$$.on_mount.push(function() {
    if (visualState === void 0 && !("visualState" in $$props || $$self.$$.bound[$$self.$$.props["visualState"]])) {
      console.warn("<UseStyle> was created without expected prop 'visualState'");
    }
    if (props === void 0 && !("props" in $$props || $$self.$$.bound[$$self.$$.props["props"]])) {
      console.warn("<UseStyle> was created without expected prop 'props'");
    }
    if (isStatic === void 0 && !("isStatic" in $$props || $$self.$$.bound[$$self.$$.props["isStatic"]])) {
      console.warn("<UseStyle> was created without expected prop 'isStatic'");
    }
  });
  const writable_props = ["visualState", "props", "isStatic"];
  Object_12.keys($$props).forEach((key) => {
    if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$" && key !== "slot")
      console.warn(`<UseStyle> was created with unknown prop '${key}'`);
  });
  $$self.$$set = ($$props2) => {
    if ("visualState" in $$props2)
      $$invalidate(0, visualState = $$props2.visualState);
    if ("props" in $$props2)
      $$invalidate(1, props = $$props2.props);
    if ("isStatic" in $$props2)
      $$invalidate(2, isStatic = $$props2.isStatic);
    if ("$$scope" in $$props2)
      $$invalidate(7, $$scope = $$props2.$$scope);
  };
  $$self.$capture_state = () => ({
    copyRawValuesOnly,
    isMotionValue,
    isForcedMotionValue,
    UseInitialMotionValues: UseInitialMotionValues_default,
    visualState,
    props,
    isStatic,
    style,
    cRVO,
    toStyle,
    styleProp
  });
  $$self.$inject_state = ($$props2) => {
    if ("visualState" in $$props2)
      $$invalidate(0, visualState = $$props2.visualState);
    if ("props" in $$props2)
      $$invalidate(1, props = $$props2.props);
    if ("isStatic" in $$props2)
      $$invalidate(2, isStatic = $$props2.isStatic);
    if ("style" in $$props2)
      $$invalidate(3, style = $$props2.style);
    if ("styleProp" in $$props2)
      $$invalidate(5, styleProp = $$props2.styleProp);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$self.$$.update = () => {
    if ($$self.$$.dirty & /*props*/
    2) {
      $:
        $$invalidate(5, styleProp = props.style || {});
    }
    if ($$self.$$.dirty & /*style, styleProp, props*/
    42) {
      $:
        cRVO(style, styleProp, props);
    }
  };
  return [visualState, props, isStatic, style, toStyle, styleProp, slots, $$scope];
}
var UseStyle = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance5, create_fragment5, safe_not_equal, { visualState: 0, props: 1, isStatic: 2 });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "UseStyle",
      options,
      id: create_fragment5.name
    });
  }
  get visualState() {
    throw new Error("<UseStyle>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set visualState(value) {
    throw new Error("<UseStyle>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get props() {
    throw new Error("<UseStyle>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set props(value) {
    throw new Error("<UseStyle>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get isStatic() {
    throw new Error("<UseStyle>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set isStatic(value) {
    throw new Error("<UseStyle>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var UseStyle_default = UseStyle;

// node_modules/svelte-motion/src/render/html/UseHTMLProps.svelte
var get_default_slot_changes5 = (dirty) => ({
  visualProps: dirty & /*styles, props*/
  65
});
var get_default_slot_context5 = (ctx) => ({
  visualProps: (
    /*getHTMLProps*/
    ctx[3](
      /*styles*/
      ctx[6],
      /*props*/
      ctx[0]
    )
  )
});
function create_default_slot2(ctx) {
  let current;
  const default_slot_template = (
    /*#slots*/
    ctx[4].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[5],
    get_default_slot_context5
  );
  const block = {
    c: function create() {
      if (default_slot)
        default_slot.c();
    },
    l: function claim(nodes) {
      if (default_slot)
        default_slot.l(nodes);
    },
    m: function mount(target, anchor) {
      if (default_slot) {
        default_slot.m(target, anchor);
      }
      current = true;
    },
    p: function update(ctx2, dirty) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope, styles, props*/
        97)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[5],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[5]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[5],
              dirty,
              get_default_slot_changes5
            ),
            get_default_slot_context5
          );
        }
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(default_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (default_slot)
        default_slot.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot2.name,
    type: "slot",
    source: "(36:0) <UseStyle let:styles {visualState} {props} {isStatic}>",
    ctx
  });
  return block;
}
function create_fragment6(ctx) {
  let usestyle;
  let current;
  usestyle = new UseStyle_default({
    props: {
      visualState: (
        /*visualState*/
        ctx[1]
      ),
      props: (
        /*props*/
        ctx[0]
      ),
      isStatic: (
        /*isStatic*/
        ctx[2]
      ),
      $$slots: {
        default: [
          create_default_slot2,
          ({ styles }) => ({ 6: styles }),
          ({ styles }) => styles ? 64 : 0
        ]
      },
      $$scope: { ctx }
    },
    $$inline: true
  });
  const block = {
    c: function create() {
      create_component(usestyle.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(usestyle.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(usestyle, target, anchor);
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      const usestyle_changes = {};
      if (dirty & /*visualState*/
      2)
        usestyle_changes.visualState = /*visualState*/
        ctx2[1];
      if (dirty & /*props*/
      1)
        usestyle_changes.props = /*props*/
        ctx2[0];
      if (dirty & /*isStatic*/
      4)
        usestyle_changes.isStatic = /*isStatic*/
        ctx2[2];
      if (dirty & /*$$scope, styles, props*/
      97) {
        usestyle_changes.$$scope = { dirty, ctx: ctx2 };
      }
      usestyle.$set(usestyle_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(usestyle.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(usestyle.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(usestyle, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment6.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance6($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("UseHTMLProps", slots, ["default"]);
  let { props, visualState, isStatic } = $$props;
  const getHTMLProps = (style, props2) => {
    let htmlProps = {};
    if (Boolean(props2.drag)) {
      htmlProps.draggable = false;
      style.userSelect = style.WebkitUserSelect = style.WebkitTouchCallout = "none";
      style.touchAction = props2.drag === true ? "none" : `pan-${props2.drag === "x" ? "y" : "x"}`;
    }
    htmlProps.style = style;
    return htmlProps;
  };
  $$self.$$.on_mount.push(function() {
    if (props === void 0 && !("props" in $$props || $$self.$$.bound[$$self.$$.props["props"]])) {
      console.warn("<UseHTMLProps> was created without expected prop 'props'");
    }
    if (visualState === void 0 && !("visualState" in $$props || $$self.$$.bound[$$self.$$.props["visualState"]])) {
      console.warn("<UseHTMLProps> was created without expected prop 'visualState'");
    }
    if (isStatic === void 0 && !("isStatic" in $$props || $$self.$$.bound[$$self.$$.props["isStatic"]])) {
      console.warn("<UseHTMLProps> was created without expected prop 'isStatic'");
    }
  });
  const writable_props = ["props", "visualState", "isStatic"];
  Object.keys($$props).forEach((key) => {
    if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$" && key !== "slot")
      console.warn(`<UseHTMLProps> was created with unknown prop '${key}'`);
  });
  $$self.$$set = ($$props2) => {
    if ("props" in $$props2)
      $$invalidate(0, props = $$props2.props);
    if ("visualState" in $$props2)
      $$invalidate(1, visualState = $$props2.visualState);
    if ("isStatic" in $$props2)
      $$invalidate(2, isStatic = $$props2.isStatic);
    if ("$$scope" in $$props2)
      $$invalidate(5, $$scope = $$props2.$$scope);
  };
  $$self.$capture_state = () => ({
    UseStyle: UseStyle_default,
    props,
    visualState,
    isStatic,
    getHTMLProps
  });
  $$self.$inject_state = ($$props2) => {
    if ("props" in $$props2)
      $$invalidate(0, props = $$props2.props);
    if ("visualState" in $$props2)
      $$invalidate(1, visualState = $$props2.visualState);
    if ("isStatic" in $$props2)
      $$invalidate(2, isStatic = $$props2.isStatic);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  return [props, visualState, isStatic, getHTMLProps, slots, $$scope];
}
var UseHTMLProps = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance6, create_fragment6, safe_not_equal, { props: 0, visualState: 1, isStatic: 2 });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "UseHTMLProps",
      options,
      id: create_fragment6.name
    });
  }
  get props() {
    throw new Error("<UseHTMLProps>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set props(value) {
    throw new Error("<UseHTMLProps>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get visualState() {
    throw new Error("<UseHTMLProps>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set visualState(value) {
    throw new Error("<UseHTMLProps>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get isStatic() {
    throw new Error("<UseHTMLProps>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set isStatic(value) {
    throw new Error("<UseHTMLProps>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var UseHTMLProps_default = UseHTMLProps;

// node_modules/svelte-motion/src/render/svg/utils/transform-origin.js
function calcOrigin(origin, offset, size) {
  return typeof origin === "string" ? origin : px.transform(offset + size * origin);
}
function calcSVGTransformOrigin(dimensions, originX, originY) {
  var pxOriginX = calcOrigin(originX, dimensions.x, dimensions.width);
  var pxOriginY = calcOrigin(originY, dimensions.y, dimensions.height);
  return pxOriginX + " " + pxOriginY;
}

// node_modules/svelte-motion/src/render/svg/utils/path.js
var progressToPixels = function(progress, length) {
  return px.transform(progress * length);
};
var dashKeys = {
  offset: "stroke-dashoffset",
  array: "stroke-dasharray"
};
var camelKeys = {
  offset: "strokeDashoffset",
  array: "strokeDasharray"
};
function buildSVGPath(attrs, totalLength, length, spacing, offset, useDashCase) {
  if (spacing === void 0) {
    spacing = 1;
  }
  if (offset === void 0) {
    offset = 0;
  }
  if (useDashCase === void 0) {
    useDashCase = true;
  }
  var keys = useDashCase ? dashKeys : camelKeys;
  attrs[keys.offset] = progressToPixels(-offset, totalLength);
  var pathLength = progressToPixels(length, totalLength);
  var pathSpacing = progressToPixels(spacing, totalLength);
  attrs[keys.array] = pathLength + " " + pathSpacing;
}

// node_modules/svelte-motion/src/render/svg/utils/build-attrs.js
function buildSVGAttrs(state, _a, projection, layoutState, options, transformTemplate, buildProjectionTransform, buildProjectionTransformOrigin) {
  var attrX = _a.attrX, attrY = _a.attrY, originX = _a.originX, originY = _a.originY, pathLength = _a.pathLength, _b = _a.pathSpacing, pathSpacing = _b === void 0 ? 1 : _b, _c = _a.pathOffset, pathOffset = _c === void 0 ? 0 : _c, latest = __rest(_a, ["attrX", "attrY", "originX", "originY", "pathLength", "pathSpacing", "pathOffset"]);
  buildHTMLStyles(state, latest, projection, layoutState, options, transformTemplate, buildProjectionTransform, buildProjectionTransformOrigin);
  state.attrs = state.style;
  state.style = {};
  var attrs = state.attrs, style = state.style, dimensions = state.dimensions, totalPathLength = state.totalPathLength;
  if (attrs.transform) {
    if (dimensions)
      style.transform = attrs.transform;
    delete attrs.transform;
  }
  if (dimensions && (originX !== void 0 || originY !== void 0 || style.transform)) {
    style.transformOrigin = calcSVGTransformOrigin(dimensions, originX !== void 0 ? originX : 0.5, originY !== void 0 ? originY : 0.5);
  }
  if (attrX !== void 0)
    attrs.x = attrX;
  if (attrY !== void 0)
    attrs.y = attrY;
  if (totalPathLength !== void 0 && pathLength !== void 0) {
    buildSVGPath(attrs, totalPathLength, pathLength, pathSpacing, pathOffset, false);
  }
}

// node_modules/svelte-motion/src/render/svg/UseSVGProps.svelte
var get_default_slot_changes6 = (dirty) => ({ visualProps: dirty & /*visualProps*/
1 });
var get_default_slot_context6 = (ctx) => ({ visualProps: (
  /*visualProps*/
  ctx[0]
) });
function create_fragment7(ctx) {
  let current;
  const default_slot_template = (
    /*#slots*/
    ctx[4].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[3],
    get_default_slot_context6
  );
  const block = {
    c: function create() {
      if (default_slot)
        default_slot.c();
    },
    l: function claim(nodes) {
      if (default_slot)
        default_slot.l(nodes);
    },
    m: function mount(target, anchor) {
      if (default_slot) {
        default_slot.m(target, anchor);
      }
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope, visualProps*/
        9)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[3],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[3]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[3],
              dirty,
              get_default_slot_changes6
            ),
            get_default_slot_context6
          );
        }
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(default_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (default_slot)
        default_slot.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment7.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance7($$self, $$props, $$invalidate) {
  let visualProps;
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("UseSVGProps", slots, ["default"]);
  let { visualState, props } = $$props;
  let memo = () => {
    const state = createSvgRenderState();
    buildSVGAttrs(state, visualState, void 0, void 0, { enableHardwareAcceleration: false }, props.transformTemplate);
    return {
      ...state.attrs,
      style: { ...state.style }
    };
  };
  $$self.$$.on_mount.push(function() {
    if (visualState === void 0 && !("visualState" in $$props || $$self.$$.bound[$$self.$$.props["visualState"]])) {
      console.warn("<UseSVGProps> was created without expected prop 'visualState'");
    }
    if (props === void 0 && !("props" in $$props || $$self.$$.bound[$$self.$$.props["props"]])) {
      console.warn("<UseSVGProps> was created without expected prop 'props'");
    }
  });
  const writable_props = ["visualState", "props"];
  Object.keys($$props).forEach((key) => {
    if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$" && key !== "slot")
      console.warn(`<UseSVGProps> was created with unknown prop '${key}'`);
  });
  $$self.$$set = ($$props2) => {
    if ("visualState" in $$props2)
      $$invalidate(1, visualState = $$props2.visualState);
    if ("props" in $$props2)
      $$invalidate(2, props = $$props2.props);
    if ("$$scope" in $$props2)
      $$invalidate(3, $$scope = $$props2.$$scope);
  };
  $$self.$capture_state = () => ({
    createSvgRenderState,
    copyRawValuesOnly,
    buildSVGAttrs,
    visualState,
    props,
    memo,
    visualProps
  });
  $$self.$inject_state = ($$props2) => {
    if ("visualState" in $$props2)
      $$invalidate(1, visualState = $$props2.visualState);
    if ("props" in $$props2)
      $$invalidate(2, props = $$props2.props);
    if ("memo" in $$props2)
      $$invalidate(5, memo = $$props2.memo);
    if ("visualProps" in $$props2)
      $$invalidate(0, visualProps = $$props2.visualProps);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$self.$$.update = () => {
    if ($$self.$$.dirty & /*visualState*/
    2) {
      $:
        $$invalidate(0, visualProps = memo(visualState));
    }
    if ($$self.$$.dirty & /*props, visualProps*/
    5) {
      $:
        if (props.style) {
          const rawStyles = {};
          copyRawValuesOnly(rawStyles, props.style, props);
          $$invalidate(0, visualProps.style = { ...rawStyles, ...visualProps.style }, visualProps);
        }
    }
  };
  return [visualProps, visualState, props, $$scope, slots];
}
var UseSVGProps = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance7, create_fragment7, safe_not_equal, { visualState: 1, props: 2 });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "UseSVGProps",
      options,
      id: create_fragment7.name
    });
  }
  get visualState() {
    throw new Error("<UseSVGProps>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set visualState(value) {
    throw new Error("<UseSVGProps>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get props() {
    throw new Error("<UseSVGProps>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set props(value) {
    throw new Error("<UseSVGProps>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var UseSVGProps_default = UseSVGProps;

// node_modules/svelte-motion/src/motion/utils/valid-prop.js
var validMotionProps = /* @__PURE__ */ new Set([
  "initial",
  "animate",
  "exit",
  "style",
  "variants",
  "transition",
  "transformTemplate",
  "transformValues",
  "custom",
  "inherit",
  "layout",
  "layoutId",
  "onLayoutAnimationComplete",
  "onViewportBoxUpdate",
  "onLayoutMeasure",
  "onBeforeLayoutMeasure",
  "onAnimationStart",
  "onAnimationComplete",
  "onUpdate",
  "onDragStart",
  "onDrag",
  "onDragEnd",
  "onMeasureDragConstraints",
  "onDirectionLock",
  "onDragTransitionEnd",
  "drag",
  "dragControls",
  "dragListener",
  "dragConstraints",
  "dragDirectionLock",
  "_dragX",
  "_dragY",
  "dragElastic",
  "dragMomentum",
  "dragPropagation",
  "dragTransition",
  "whileDrag",
  "onPan",
  "onPanStart",
  "onPanEnd",
  "onPanSessionStart",
  "onTap",
  "onTapStart",
  "onTapCancel",
  "onHoverStart",
  "onHoverEnd",
  "whileFocus",
  "whileTap",
  "whileHover"
]);
function isValidMotionProp(key) {
  return validMotionProps.has(key);
}

// node_modules/svelte-motion/src/render/dom/utils/filter-props.js
var shouldForward = function(key) {
  return !isValidMotionProp(key);
};
try {
  emotionIsPropValid_1 = __require("@emotion/is-prop-valid").default;
  shouldForward = function(key) {
    if (key.startsWith("on")) {
      return !isValidMotionProp(key);
    } else {
      return emotionIsPropValid_1(key);
    }
  };
} catch (_a) {
}
var emotionIsPropValid_1;
function filterProps(props, isDom, forwardMotionProps) {
  var filteredProps = {};
  for (var key in props) {
    if (shouldForward(key) || forwardMotionProps === true && isValidMotionProp(key) || !isDom && !isValidMotionProp(key)) {
      filteredProps[key] = props[key];
    }
  }
  return filteredProps;
}

// node_modules/svelte-motion/src/render/dom/UseRender.svelte
var get_default_slot_changes7 = (dirty) => ({
  props: dirty & /*filteredProps, visualProps*/
  2064
});
var get_default_slot_context7 = (ctx) => ({
  motion: (
    /*motion*/
    ctx[5]
  ),
  props: {
    .../*filteredProps*/
    ctx[4],
    .../*visualProps*/
    ctx[11]
  }
});
function create_default_slot3(ctx) {
  let current;
  const default_slot_template = (
    /*#slots*/
    ctx[9].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[10],
    get_default_slot_context7
  );
  const block = {
    c: function create() {
      if (default_slot)
        default_slot.c();
    },
    l: function claim(nodes) {
      if (default_slot)
        default_slot.l(nodes);
    },
    m: function mount(target, anchor) {
      if (default_slot) {
        default_slot.m(target, anchor);
      }
      current = true;
    },
    p: function update(ctx2, dirty) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope, filteredProps, visualProps*/
        3088)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[10],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[10]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[10],
              dirty,
              get_default_slot_changes7
            ),
            get_default_slot_context7
          );
        }
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(default_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (default_slot)
        default_slot.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot3.name,
    type: "slot",
    source: "(33:0) <svelte:component     this={Component === 'SVG' ? UseSVGProps : UseHTMLProps}     {visualState}     {isStatic}     {props}     let:visualProps>",
    ctx
  });
  return block;
}
function create_fragment8(ctx) {
  let switch_instance;
  let switch_instance_anchor;
  let current;
  var switch_value = (
    /*Component*/
    ctx[2] === "SVG" ? UseSVGProps_default : UseHTMLProps_default
  );
  function switch_props(ctx2, dirty) {
    return {
      props: {
        visualState: (
          /*visualState*/
          ctx2[1]
        ),
        isStatic: (
          /*isStatic*/
          ctx2[3]
        ),
        props: (
          /*props*/
          ctx2[0]
        ),
        $$slots: {
          default: [
            create_default_slot3,
            ({ visualProps }) => ({ 11: visualProps }),
            ({ visualProps }) => visualProps ? 2048 : 0
          ]
        },
        $$scope: { ctx: ctx2 }
      },
      $$inline: true
    };
  }
  if (switch_value) {
    switch_instance = construct_svelte_component_dev(switch_value, switch_props(ctx));
  }
  const block = {
    c: function create() {
      if (switch_instance)
        create_component(switch_instance.$$.fragment);
      switch_instance_anchor = empty();
    },
    l: function claim(nodes) {
      if (switch_instance)
        claim_component(switch_instance.$$.fragment, nodes);
      switch_instance_anchor = empty();
    },
    m: function mount(target, anchor) {
      if (switch_instance)
        mount_component(switch_instance, target, anchor);
      insert_hydration_dev(target, switch_instance_anchor, anchor);
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      if (dirty & /*Component*/
      4 && switch_value !== (switch_value = /*Component*/
      ctx2[2] === "SVG" ? UseSVGProps_default : UseHTMLProps_default)) {
        if (switch_instance) {
          group_outros();
          const old_component = switch_instance;
          transition_out(old_component.$$.fragment, 1, 0, () => {
            destroy_component(old_component, 1);
          });
          check_outros();
        }
        if (switch_value) {
          switch_instance = construct_svelte_component_dev(switch_value, switch_props(ctx2, dirty));
          create_component(switch_instance.$$.fragment);
          transition_in(switch_instance.$$.fragment, 1);
          mount_component(switch_instance, switch_instance_anchor.parentNode, switch_instance_anchor);
        } else {
          switch_instance = null;
        }
      } else if (switch_value) {
        const switch_instance_changes = {};
        if (dirty & /*visualState*/
        2)
          switch_instance_changes.visualState = /*visualState*/
          ctx2[1];
        if (dirty & /*isStatic*/
        8)
          switch_instance_changes.isStatic = /*isStatic*/
          ctx2[3];
        if (dirty & /*props*/
        1)
          switch_instance_changes.props = /*props*/
          ctx2[0];
        if (dirty & /*$$scope, filteredProps, visualProps*/
        3088) {
          switch_instance_changes.$$scope = { dirty, ctx: ctx2 };
        }
        switch_instance.$set(switch_instance_changes);
      }
    },
    i: function intro(local) {
      if (current)
        return;
      if (switch_instance)
        transition_in(switch_instance.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      if (switch_instance)
        transition_out(switch_instance.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(switch_instance_anchor);
      }
      if (switch_instance)
        destroy_component(switch_instance, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment8.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance8($$self, $$props, $$invalidate) {
  let filteredProps;
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("UseRender", slots, ["default"]);
  let { props, visualState, Component, forwardMotionProps = false, isStatic, ref, targetEl = void 0 } = $$props;
  const motion = (node) => {
    ref(node);
  };
  $$self.$$.on_mount.push(function() {
    if (props === void 0 && !("props" in $$props || $$self.$$.bound[$$self.$$.props["props"]])) {
      console.warn("<UseRender> was created without expected prop 'props'");
    }
    if (visualState === void 0 && !("visualState" in $$props || $$self.$$.bound[$$self.$$.props["visualState"]])) {
      console.warn("<UseRender> was created without expected prop 'visualState'");
    }
    if (Component === void 0 && !("Component" in $$props || $$self.$$.bound[$$self.$$.props["Component"]])) {
      console.warn("<UseRender> was created without expected prop 'Component'");
    }
    if (isStatic === void 0 && !("isStatic" in $$props || $$self.$$.bound[$$self.$$.props["isStatic"]])) {
      console.warn("<UseRender> was created without expected prop 'isStatic'");
    }
    if (ref === void 0 && !("ref" in $$props || $$self.$$.bound[$$self.$$.props["ref"]])) {
      console.warn("<UseRender> was created without expected prop 'ref'");
    }
  });
  const writable_props = [
    "props",
    "visualState",
    "Component",
    "forwardMotionProps",
    "isStatic",
    "ref",
    "targetEl"
  ];
  Object.keys($$props).forEach((key) => {
    if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$" && key !== "slot")
      console.warn(`<UseRender> was created with unknown prop '${key}'`);
  });
  $$self.$$set = ($$props2) => {
    if ("props" in $$props2)
      $$invalidate(0, props = $$props2.props);
    if ("visualState" in $$props2)
      $$invalidate(1, visualState = $$props2.visualState);
    if ("Component" in $$props2)
      $$invalidate(2, Component = $$props2.Component);
    if ("forwardMotionProps" in $$props2)
      $$invalidate(6, forwardMotionProps = $$props2.forwardMotionProps);
    if ("isStatic" in $$props2)
      $$invalidate(3, isStatic = $$props2.isStatic);
    if ("ref" in $$props2)
      $$invalidate(7, ref = $$props2.ref);
    if ("targetEl" in $$props2)
      $$invalidate(8, targetEl = $$props2.targetEl);
    if ("$$scope" in $$props2)
      $$invalidate(10, $$scope = $$props2.$$scope);
  };
  $$self.$capture_state = () => ({
    UseSVGProps: UseSVGProps_default,
    UseHTMLProps: UseHTMLProps_default,
    filterProps,
    props,
    visualState,
    Component,
    forwardMotionProps,
    isStatic,
    ref,
    targetEl,
    motion,
    filteredProps
  });
  $$self.$inject_state = ($$props2) => {
    if ("props" in $$props2)
      $$invalidate(0, props = $$props2.props);
    if ("visualState" in $$props2)
      $$invalidate(1, visualState = $$props2.visualState);
    if ("Component" in $$props2)
      $$invalidate(2, Component = $$props2.Component);
    if ("forwardMotionProps" in $$props2)
      $$invalidate(6, forwardMotionProps = $$props2.forwardMotionProps);
    if ("isStatic" in $$props2)
      $$invalidate(3, isStatic = $$props2.isStatic);
    if ("ref" in $$props2)
      $$invalidate(7, ref = $$props2.ref);
    if ("targetEl" in $$props2)
      $$invalidate(8, targetEl = $$props2.targetEl);
    if ("filteredProps" in $$props2)
      $$invalidate(4, filteredProps = $$props2.filteredProps);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$self.$$.update = () => {
    if ($$self.$$.dirty & /*props, Component, forwardMotionProps*/
    69) {
      $:
        $$invalidate(4, filteredProps = filterProps(props, typeof Component === "string", forwardMotionProps));
    }
    if ($$self.$$.dirty & /*targetEl*/
    256) {
      $:
        if (targetEl) {
          motion(targetEl);
        }
    }
  };
  return [
    props,
    visualState,
    Component,
    isStatic,
    filteredProps,
    motion,
    forwardMotionProps,
    ref,
    targetEl,
    slots,
    $$scope
  ];
}
var UseRender = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance8, create_fragment8, safe_not_equal, {
      props: 0,
      visualState: 1,
      Component: 2,
      forwardMotionProps: 6,
      isStatic: 3,
      ref: 7,
      targetEl: 8
    });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "UseRender",
      options,
      id: create_fragment8.name
    });
  }
  get props() {
    throw new Error("<UseRender>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set props(value) {
    throw new Error("<UseRender>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get visualState() {
    throw new Error("<UseRender>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set visualState(value) {
    throw new Error("<UseRender>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get Component() {
    throw new Error("<UseRender>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set Component(value) {
    throw new Error("<UseRender>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get forwardMotionProps() {
    throw new Error("<UseRender>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set forwardMotionProps(value) {
    throw new Error("<UseRender>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get isStatic() {
    throw new Error("<UseRender>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set isStatic(value) {
    throw new Error("<UseRender>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get ref() {
    throw new Error("<UseRender>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set ref(value) {
    throw new Error("<UseRender>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get targetEl() {
    throw new Error("<UseRender>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set targetEl(value) {
    throw new Error("<UseRender>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var UseRender_default = UseRender;

// node_modules/svelte-motion/src/render/utils/state.js
var createProjectionState = function() {
  return {
    isEnabled: false,
    isTargetLocked: false,
    target: axisBox(),
    targetFinal: axisBox()
  };
};
function createLayoutState() {
  return {
    isHydrated: false,
    layout: axisBox(),
    layoutCorrected: axisBox(),
    treeScale: { x: 1, y: 1 },
    delta: delta(),
    deltaFinal: delta(),
    deltaTransform: ""
  };
}
var zeroLayout = createLayoutState();

// node_modules/svelte-motion/src/render/html/utils/build-projection-transform.js
function buildLayoutProjectionTransform(_a, treeScale, latestTransform) {
  var x = _a.x, y = _a.y;
  var xTranslate = x.translate / treeScale.x;
  var yTranslate = y.translate / treeScale.y;
  var transform = "translate3d(" + xTranslate + "px, " + yTranslate + "px, 0) ";
  if (latestTransform) {
    var rotate = latestTransform.rotate, rotateX = latestTransform.rotateX, rotateY = latestTransform.rotateY;
    if (rotate)
      transform += "rotate(" + rotate + ") ";
    if (rotateX)
      transform += "rotateX(" + rotateX + ") ";
    if (rotateY)
      transform += "rotateY(" + rotateY + ") ";
  }
  transform += "scale(" + x.scale + ", " + y.scale + ")";
  return !latestTransform && transform === identityProjection ? "" : transform;
}
function buildLayoutProjectionTransformOrigin(_a) {
  var deltaFinal = _a.deltaFinal;
  return deltaFinal.x.origin * 100 + "% " + deltaFinal.y.origin * 100 + "% 0";
}
var identityProjection = buildLayoutProjectionTransform(zeroLayout.delta, zeroLayout.treeScale, { x: 1, y: 1 });

// node_modules/svelte-motion/src/animation/utils/is-animation-controls.js
var isAnimationControls = function(v) {
  return typeof v === "object" && typeof v.start === "function";
};

// node_modules/svelte-motion/src/utils/shallow-compare.js
function shallowCompare(next, prev) {
  if (!Array.isArray(prev))
    return false;
  var prevLength = prev.length;
  if (prevLength !== next.length)
    return false;
  for (var i = 0; i < prevLength; i++) {
    if (prev[i] !== next[i])
      return false;
  }
  return true;
}

// node_modules/svelte-motion/src/utils/is-numerical-string.js
var isNumericalString = function(v) {
  return /^\-?\d*\.?\d+$/.test(v);
};

// node_modules/svelte-motion/src/utils/resolve-value.js
var isCustomValue = function(v) {
  return Boolean(v && typeof v === "object" && v.mix && v.toValue);
};
var resolveFinalValueInKeyframes = function(v) {
  return isKeyframesTarget(v) ? v[v.length - 1] || 0 : v;
};

// node_modules/svelte-motion/src/render/dom/value-types/test.js
var testValueType = function(v) {
  return function(type) {
    return type.test(v);
  };
};

// node_modules/svelte-motion/src/render/dom/value-types/type-auto.js
var auto = {
  test: function(v) {
    return v === "auto";
  },
  parse: function(v) {
    return v;
  }
};

// node_modules/svelte-motion/src/render/dom/value-types/dimensions.js
var dimensionValueTypes = [number, px, percent, degrees, vw, vh, auto];
var findDimensionValueType = function(v) {
  return dimensionValueTypes.find(testValueType(v));
};

// node_modules/svelte-motion/src/render/dom/value-types/find.js
var valueTypes = __spreadArray(__spreadArray([], __read(dimensionValueTypes)), [color, complex]);
var findValueType = function(v) {
  return valueTypes.find(testValueType(v));
};

// node_modules/svelte-motion/src/render/utils/variants.js
function isVariantLabels(v) {
  return Array.isArray(v);
}
function isVariantLabel(v) {
  return typeof v === "string" || isVariantLabels(v);
}
function getCurrent(visualElement2) {
  var current = {};
  visualElement2.forEachValue(function(value, key) {
    return current[key] = value.get();
  });
  return current;
}
function getVelocity(visualElement2) {
  var velocity = {};
  visualElement2.forEachValue(function(value, key) {
    return velocity[key] = value.getVelocity();
  });
  return velocity;
}
function resolveVariantFromProps(props, definition, custom, currentValues, currentVelocity) {
  var _a;
  if (currentValues === void 0) {
    currentValues = {};
  }
  if (currentVelocity === void 0) {
    currentVelocity = {};
  }
  if (typeof definition === "string") {
    definition = (_a = props.variants) === null || _a === void 0 ? void 0 : _a[definition];
  }
  return typeof definition === "function" ? definition(custom !== null && custom !== void 0 ? custom : props.custom, currentValues, currentVelocity) : definition;
}
function resolveVariant(visualElement2, definition, custom) {
  var props = visualElement2.getProps();
  return resolveVariantFromProps(props, definition, custom !== null && custom !== void 0 ? custom : props.custom, getCurrent(visualElement2), getVelocity(visualElement2));
}
function checkIfControllingVariants(props) {
  var _a;
  return typeof ((_a = props.animate) === null || _a === void 0 ? void 0 : _a.start) === "function" || isVariantLabel(props.initial) || isVariantLabel(props.animate) || isVariantLabel(props.whileHover) || isVariantLabel(props.whileDrag) || isVariantLabel(props.whileTap) || isVariantLabel(props.whileFocus) || isVariantLabel(props.exit);
}
function checkIfVariantNode(props) {
  return Boolean(checkIfControllingVariants(props) || props.variants);
}

// node_modules/svelte-motion/src/render/utils/setters.js
function setMotionValue(visualElement2, key, value) {
  if (visualElement2.hasValue(key)) {
    visualElement2.getValue(key).set(value);
  } else {
    visualElement2.addValue(key, motionValue(value));
  }
}
function setTarget(visualElement2, definition) {
  var resolved = resolveVariant(visualElement2, definition);
  var _a = resolved ? visualElement2.makeTargetAnimatable(resolved, false) : {}, _b = _a.transitionEnd, transitionEnd = _b === void 0 ? {} : _b;
  _a.transition;
  var target = __rest(_a, ["transitionEnd", "transition"]);
  target = __assign(__assign({}, target), transitionEnd);
  for (var key in target) {
    var value = resolveFinalValueInKeyframes(target[key]);
    setMotionValue(visualElement2, key, value);
  }
}
function checkTargetForNewValues(visualElement2, target, origin) {
  var _a, _b, _c;
  var _d;
  var newValueKeys = Object.keys(target).filter(function(key2) {
    return !visualElement2.hasValue(key2);
  });
  var numNewValues = newValueKeys.length;
  if (!numNewValues)
    return;
  for (var i = 0; i < numNewValues; i++) {
    var key = newValueKeys[i];
    var targetValue = target[key];
    var value = null;
    if (Array.isArray(targetValue)) {
      value = targetValue[0];
    }
    if (value === null) {
      value = (_b = (_a = origin[key]) !== null && _a !== void 0 ? _a : visualElement2.readValue(key)) !== null && _b !== void 0 ? _b : target[key];
    }
    if (value === void 0 || value === null)
      continue;
    if (typeof value === "string" && isNumericalString(value)) {
      value = parseFloat(value);
    } else if (!findValueType(value) && complex.test(targetValue)) {
      value = getAnimatableNone(key, targetValue);
    }
    visualElement2.addValue(key, motionValue(value));
    (_c = (_d = origin)[key]) !== null && _c !== void 0 ? _c : _d[key] = value;
    visualElement2.setBaseTarget(key, value);
  }
}
function getOriginFromTransition(key, transition) {
  if (!transition)
    return;
  var valueTransition = transition[key] || transition["default"] || transition;
  return valueTransition.from;
}
function getOrigin(target, transition, visualElement2) {
  var _a, _b;
  var origin = {};
  for (var key in target) {
    origin[key] = (_a = getOriginFromTransition(key, transition)) !== null && _a !== void 0 ? _a : (_b = visualElement2.getValue(key)) === null || _b === void 0 ? void 0 : _b.get();
  }
  return origin;
}

// node_modules/svelte-motion/src/render/utils/animation.js
function animateVisualElement(visualElement2, definition, options) {
  if (options === void 0) {
    options = {};
  }
  visualElement2.notifyAnimationStart();
  var animation;
  if (Array.isArray(definition)) {
    var animations2 = definition.map(function(variant) {
      return animateVariant(visualElement2, variant, options);
    });
    animation = Promise.all(animations2);
  } else if (typeof definition === "string") {
    animation = animateVariant(visualElement2, definition, options);
  } else {
    var resolvedDefinition = typeof definition === "function" ? resolveVariant(visualElement2, definition, options.custom) : definition;
    animation = animateTarget(visualElement2, resolvedDefinition, options);
  }
  return animation.then(function() {
    return visualElement2.notifyAnimationComplete(definition);
  });
}
function animateVariant(visualElement2, variant, options) {
  var _a;
  if (options === void 0) {
    options = {};
  }
  var resolved = resolveVariant(visualElement2, variant, options.custom);
  var _b = (resolved || {}).transition, transition = _b === void 0 ? visualElement2.getDefaultTransition() || {} : _b;
  if (options.transitionOverride) {
    transition = options.transitionOverride;
  }
  var getAnimation = resolved ? function() {
    return animateTarget(visualElement2, resolved, options);
  } : function() {
    return Promise.resolve();
  };
  var getChildAnimations = ((_a = visualElement2.variantChildren) === null || _a === void 0 ? void 0 : _a.size) ? function(forwardDelay) {
    if (forwardDelay === void 0) {
      forwardDelay = 0;
    }
    var _a2 = transition.delayChildren, delayChildren = _a2 === void 0 ? 0 : _a2, staggerChildren = transition.staggerChildren, staggerDirection = transition.staggerDirection;
    return animateChildren(visualElement2, variant, delayChildren + forwardDelay, staggerChildren, staggerDirection, options);
  } : function() {
    return Promise.resolve();
  };
  var when = transition.when;
  if (when) {
    var _c = __read(when === "beforeChildren" ? [getAnimation, getChildAnimations] : [getChildAnimations, getAnimation], 2), first = _c[0], last = _c[1];
    return first().then(last);
  } else {
    return Promise.all([getAnimation(), getChildAnimations(options.delay)]);
  }
}
function animateTarget(visualElement2, definition, _a) {
  var _b;
  var _c = _a === void 0 ? {} : _a, _d = _c.delay, delay = _d === void 0 ? 0 : _d, transitionOverride = _c.transitionOverride, type = _c.type;
  var _e = visualElement2.makeTargetAnimatable(definition), _f = _e.transition, transition = _f === void 0 ? visualElement2.getDefaultTransition() : _f, transitionEnd = _e.transitionEnd, target = __rest(_e, ["transition", "transitionEnd"]);
  if (transitionOverride)
    transition = transitionOverride;
  var animations2 = [];
  var animationTypeState = type && ((_b = visualElement2.animationState) === null || _b === void 0 ? void 0 : _b.getState()[type]);
  for (var key in target) {
    var value = visualElement2.getValue(key);
    var valueTarget = target[key];
    if (!value || valueTarget === void 0 || animationTypeState && shouldBlockAnimation(animationTypeState, key)) {
      continue;
    }
    var animation = startAnimation(key, value, valueTarget, __assign({ delay }, transition));
    animations2.push(animation);
  }
  return Promise.all(animations2).then(function() {
    transitionEnd && setTarget(visualElement2, transitionEnd);
  });
}
function animateChildren(visualElement2, variant, delayChildren, staggerChildren, staggerDirection, options) {
  if (delayChildren === void 0) {
    delayChildren = 0;
  }
  if (staggerChildren === void 0) {
    staggerChildren = 0;
  }
  if (staggerDirection === void 0) {
    staggerDirection = 1;
  }
  var animations2 = [];
  var maxStaggerDuration = (visualElement2.variantChildren.size - 1) * staggerChildren;
  var generateStaggerDuration = staggerDirection === 1 ? function(i) {
    if (i === void 0) {
      i = 0;
    }
    return i * staggerChildren;
  } : function(i) {
    if (i === void 0) {
      i = 0;
    }
    return maxStaggerDuration - i * staggerChildren;
  };
  Array.from(visualElement2.variantChildren).sort(sortByTreeOrder).forEach(function(child, i) {
    animations2.push(animateVariant(child, variant, __assign(__assign({}, options), { delay: delayChildren + generateStaggerDuration(i) })).then(function() {
      return child.notifyAnimationComplete(variant);
    }));
  });
  return Promise.all(animations2);
}
function sortByTreeOrder(a, b) {
  return a.sortNodePosition(b);
}
function shouldBlockAnimation(_a, key) {
  var protectedKeys = _a.protectedKeys, needsAnimating = _a.needsAnimating;
  var shouldBlock = protectedKeys.hasOwnProperty(key) && needsAnimating[key] !== true;
  needsAnimating[key] = false;
  return shouldBlock;
}

// node_modules/svelte-motion/src/render/utils/animation-state.js
var variantPriorityOrder = [
  AnimationType.Animate,
  AnimationType.Hover,
  AnimationType.Tap,
  AnimationType.Drag,
  AnimationType.Focus,
  AnimationType.Exit
];
var reversePriorityOrder = __spreadArray([], __read(variantPriorityOrder)).reverse();
var numAnimationTypes = variantPriorityOrder.length;
function animateList(visualElement2) {
  return function(animations2) {
    return Promise.all(animations2.map(function(_a) {
      var animation = _a.animation, options = _a.options;
      return animateVisualElement(visualElement2, animation, options);
    }));
  };
}
function createAnimationState(visualElement2) {
  var animate = animateList(visualElement2);
  var state = createState();
  var allAnimatedKeys = {};
  var isInitialRender = true;
  var buildResolvedTypeValues = function(acc, definition) {
    var resolved = resolveVariant(visualElement2, definition);
    if (resolved) {
      resolved.transition;
      var transitionEnd = resolved.transitionEnd, target = __rest(resolved, ["transition", "transitionEnd"]);
      acc = __assign(__assign(__assign({}, acc), target), transitionEnd);
    }
    return acc;
  };
  function isAnimated(key) {
    return allAnimatedKeys[key] !== void 0;
  }
  function setAnimateFunction(makeAnimator) {
    animate = makeAnimator(visualElement2);
  }
  function animateChanges(options, changedActiveType) {
    var _a;
    var props = visualElement2.getProps();
    var context = visualElement2.getVariantContext(true) || {};
    var animations2 = [];
    var removedKeys = /* @__PURE__ */ new Set();
    var encounteredKeys = {};
    var removedVariantIndex = Infinity;
    var _loop_1 = function(i2) {
      var type = reversePriorityOrder[i2];
      var typeState = state[type];
      var prop = (_a = props[type]) !== null && _a !== void 0 ? _a : context[type];
      var propIsVariant = isVariantLabel(prop);
      var activeDelta = type === changedActiveType ? typeState.isActive : null;
      if (activeDelta === false)
        removedVariantIndex = i2;
      var isInherited = prop === context[type] && prop !== props[type] && propIsVariant;
      if (isInherited && isInitialRender && visualElement2.manuallyAnimateOnMount) {
        isInherited = false;
      }
      typeState.protectedKeys = __assign({}, encounteredKeys);
      if (
        // If it isn't active and hasn't *just* been set as inactive
        !typeState.isActive && activeDelta === null || // If we didn't and don't have any defined prop for this animation type
        !prop && !typeState.prevProp || // Or if the prop doesn't define an animation
        isAnimationControls(prop) || typeof prop === "boolean"
      ) {
        return "continue";
      }
      var shouldAnimateType = variantsHaveChanged(typeState.prevProp, prop) || // If we're making this variant active, we want to always make it active
      type === changedActiveType && typeState.isActive && !isInherited && propIsVariant || // If we removed a higher-priority variant (i is in reverse order)
      i2 > removedVariantIndex && propIsVariant;
      var definitionList = Array.isArray(prop) ? prop : [prop];
      var resolvedValues = definitionList.reduce(buildResolvedTypeValues, {});
      if (activeDelta === false)
        resolvedValues = {};
      var _b = typeState.prevResolvedValues, prevResolvedValues = _b === void 0 ? {} : _b;
      var allKeys = __assign(__assign({}, prevResolvedValues), resolvedValues);
      var markToAnimate = function(key2) {
        shouldAnimateType = true;
        removedKeys.delete(key2);
        typeState.needsAnimating[key2] = true;
      };
      for (var key in allKeys) {
        var next = resolvedValues[key];
        var prev = prevResolvedValues[key];
        if (encounteredKeys.hasOwnProperty(key))
          continue;
        if (next !== prev) {
          if (isKeyframesTarget(next) && isKeyframesTarget(prev)) {
            if (!shallowCompare(next, prev)) {
              markToAnimate(key);
            } else {
              typeState.protectedKeys[key] = true;
            }
          } else if (next !== void 0) {
            markToAnimate(key);
          } else {
            removedKeys.add(key);
          }
        } else if (next !== void 0 && removedKeys.has(key)) {
          markToAnimate(key);
        } else {
          typeState.protectedKeys[key] = true;
        }
      }
      typeState.prevProp = prop;
      typeState.prevResolvedValues = resolvedValues;
      if (typeState.isActive) {
        encounteredKeys = __assign(__assign({}, encounteredKeys), resolvedValues);
      }
      if (isInitialRender && visualElement2.blockInitialAnimation) {
        shouldAnimateType = false;
      }
      if (shouldAnimateType && !isInherited) {
        animations2.push.apply(animations2, __spreadArray([], __read(definitionList.map(function(animation) {
          return {
            animation,
            options: __assign({ type }, options)
          };
        }))));
      }
    };
    for (var i = 0; i < numAnimationTypes; i++) {
      _loop_1(i);
    }
    allAnimatedKeys = __assign({}, encounteredKeys);
    if (removedKeys.size) {
      var fallbackAnimation_1 = {};
      removedKeys.forEach(function(key) {
        var fallbackTarget = visualElement2.getBaseTarget(key);
        if (fallbackTarget !== void 0) {
          fallbackAnimation_1[key] = fallbackTarget;
        }
      });
      animations2.push({ animation: fallbackAnimation_1 });
    }
    var shouldAnimate = Boolean(animations2.length);
    if (isInitialRender && props.initial === false && !visualElement2.manuallyAnimateOnMount) {
      shouldAnimate = false;
    }
    isInitialRender = false;
    return shouldAnimate ? animate(animations2) : Promise.resolve();
  }
  function setActive(type, isActive, options) {
    var _a;
    if (state[type].isActive === isActive)
      return Promise.resolve();
    (_a = visualElement2.variantChildren) === null || _a === void 0 ? void 0 : _a.forEach(function(child) {
      var _a2;
      return (_a2 = child.animationState) === null || _a2 === void 0 ? void 0 : _a2.setActive(type, isActive);
    });
    state[type].isActive = isActive;
    return animateChanges(options, type);
  }
  return {
    isAnimated,
    animateChanges,
    setActive,
    setAnimateFunction,
    getState: function() {
      return state;
    }
  };
}
function variantsHaveChanged(prev, next) {
  if (typeof next === "string") {
    return next !== prev;
  } else if (isVariantLabels(next)) {
    return !shallowCompare(next, prev);
  }
  return false;
}
function createTypeState(isActive) {
  if (isActive === void 0) {
    isActive = false;
  }
  return {
    isActive,
    protectedKeys: {},
    needsAnimating: {},
    prevResolvedValues: {}
  };
}
function createState() {
  var _a;
  return _a = {}, _a[AnimationType.Animate] = createTypeState(true), _a[AnimationType.Hover] = createTypeState(), _a[AnimationType.Tap] = createTypeState(), _a[AnimationType.Drag] = createTypeState(), _a[AnimationType.Focus] = createTypeState(), _a[AnimationType.Exit] = createTypeState(), _a;
}

// node_modules/svelte-motion/src/render/utils/lifecycles.js
var names = [
  "LayoutMeasure",
  "BeforeLayoutMeasure",
  "LayoutUpdate",
  "ViewportBoxUpdate",
  "Update",
  "Render",
  "AnimationComplete",
  "LayoutAnimationComplete",
  "AnimationStart",
  "SetAxisTarget",
  "Unmount"
];
function createLifecycles() {
  var managers = names.map(function() {
    return new SubscriptionManager();
  });
  var propSubscriptions = {};
  var lifecycles = {
    clearAllListeners: function() {
      return managers.forEach(function(manager) {
        return manager.clear();
      });
    },
    updatePropListeners: function(props) {
      return names.forEach(function(name) {
        var _a;
        (_a = propSubscriptions[name]) === null || _a === void 0 ? void 0 : _a.call(propSubscriptions);
        var on = "on" + name;
        var propListener = props[on];
        if (propListener) {
          propSubscriptions[name] = lifecycles[on](propListener);
        }
      });
    }
  };
  managers.forEach(function(manager, i) {
    lifecycles["on" + names[i]] = function(handler) {
      return manager.add(handler);
    };
    lifecycles["notify" + names[i]] = function() {
      var args = [];
      for (var _i = 0; _i < arguments.length; _i++) {
        args[_i] = arguments[_i];
      }
      return manager.notify.apply(manager, __spreadArray([], __read(args)));
    };
  });
  return lifecycles;
}

// node_modules/svelte-motion/src/render/utils/motion-values.js
function updateMotionValuesFromProps(element, next, prev) {
  var _a;
  for (var key in next) {
    var nextValue = next[key];
    var prevValue = prev[key];
    if (isMotionValue(nextValue)) {
      element.addValue(key, nextValue);
    } else if (isMotionValue(prevValue)) {
      element.addValue(key, motionValue(nextValue));
    } else if (prevValue !== nextValue) {
      if (element.hasValue(key)) {
        var existingValue = element.getValue(key);
        !existingValue.hasAnimated && existingValue.set(nextValue);
      } else {
        element.addValue(key, motionValue((_a = element.getStaticValue(key)) !== null && _a !== void 0 ? _a : nextValue));
      }
    }
  }
  for (var key in prev) {
    if (next[key] === void 0)
      element.removeValue(key);
  }
  return next;
}

// node_modules/svelte-motion/src/render/utils/projection.js
function updateLayoutDeltas(_a, _b, treePath, transformOrigin) {
  var delta2 = _a.delta, layout = _a.layout, layoutCorrected = _a.layoutCorrected, treeScale = _a.treeScale;
  var target = _b.target;
  resetBox(layoutCorrected, layout);
  applyTreeDeltas(layoutCorrected, treeScale, treePath);
  updateBoxDelta(delta2, layoutCorrected, target, transformOrigin);
}

// node_modules/svelte-motion/src/render/utils/flat-tree.js
var FlatTree = (
  /** @class */
  function() {
    function FlatTree2() {
      this.children = [];
      this.isDirty = false;
    }
    FlatTree2.prototype.add = function(child) {
      addUniqueItem(this.children, child);
      this.isDirty = true;
    };
    FlatTree2.prototype.remove = function(child) {
      removeItem(this.children, child);
      this.isDirty = true;
    };
    FlatTree2.prototype.forEach = function(callback) {
      this.isDirty && this.children.sort(compareByDepth);
      var numChildren = this.children.length;
      for (var i = 0; i < numChildren; i++) {
        callback(this.children[i]);
      }
    };
    return FlatTree2;
  }()
);

// node_modules/svelte-motion/src/render/dom/projection/relative-set.js
function setCurrentViewportBox(visualElement2) {
  var projectionParent = visualElement2.getProjectionParent();
  if (!projectionParent) {
    visualElement2.rebaseProjectionTarget();
    return;
  }
  var relativeOffset = calcRelativeOffset(projectionParent.getLayoutState().layout, visualElement2.getLayoutState().layout);
  eachAxis(function(axis) {
    visualElement2.setProjectionTargetAxis(axis, relativeOffset[axis].min, relativeOffset[axis].max, true);
  });
}

// node_modules/svelte-motion/src/render/index.js
var visualElement = function(_a) {
  var _b = _a.treeType, treeType = _b === void 0 ? "" : _b, build = _a.build, getBaseTarget = _a.getBaseTarget, makeTargetAnimatable = _a.makeTargetAnimatable, measureViewportBox = _a.measureViewportBox, renderInstance = _a.render, readValueFromInstance = _a.readValueFromInstance, resetTransform = _a.resetTransform, restoreTransform = _a.restoreTransform, removeValueFromRenderState = _a.removeValueFromRenderState, sortNodePosition = _a.sortNodePosition, scrapeMotionValuesFromProps3 = _a.scrapeMotionValuesFromProps;
  return function(_a2, options) {
    var parent = _a2.parent, props = _a2.props, presenceId = _a2.presenceId, blockInitialAnimation = _a2.blockInitialAnimation, visualState = _a2.visualState;
    if (options === void 0) {
      options = {};
    }
    var latestValues = visualState.latestValues, renderState = visualState.renderState;
    var instance23;
    var lifecycles = createLifecycles();
    var projection = createProjectionState();
    var projectionParent;
    var leadProjection = projection;
    var leadLatestValues = latestValues;
    var unsubscribeFromLeadVisualElement;
    var layoutState = createLayoutState();
    var crossfader;
    var hasViewportBoxUpdated = false;
    var values = /* @__PURE__ */ new Map();
    var valueSubscriptions = /* @__PURE__ */ new Map();
    var prevMotionValues = {};
    var projectionTargetProgress;
    var baseTarget = __assign({}, latestValues);
    var removeFromVariantTree;
    function render() {
      if (!instance23)
        return;
      if (element.isProjectionReady()) {
        applyBoxTransforms(leadProjection.targetFinal, leadProjection.target, leadLatestValues);
        updateBoxDelta(layoutState.deltaFinal, layoutState.layoutCorrected, leadProjection.targetFinal, latestValues);
      }
      triggerBuild();
      renderInstance(instance23, renderState);
    }
    function triggerBuild() {
      var valuesToRender = latestValues;
      if (crossfader && crossfader.isActive()) {
        var crossfadedValues = crossfader.getCrossfadeState(element);
        if (crossfadedValues)
          valuesToRender = crossfadedValues;
      }
      build(element, renderState, valuesToRender, leadProjection, layoutState, options, props);
    }
    function update() {
      lifecycles.notifyUpdate(latestValues);
    }
    function updateLayoutProjection() {
      if (!element.isProjectionReady())
        return;
      var delta2 = layoutState.delta, treeScale = layoutState.treeScale;
      var prevTreeScaleX = treeScale.x;
      var prevTreeScaleY = treeScale.y;
      var prevDeltaTransform = layoutState.deltaTransform;
      updateLayoutDeltas(layoutState, leadProjection, element.path, latestValues);
      hasViewportBoxUpdated && element.notifyViewportBoxUpdate(leadProjection.target, delta2);
      hasViewportBoxUpdated = false;
      var deltaTransform = buildLayoutProjectionTransform(delta2, treeScale);
      if (deltaTransform !== prevDeltaTransform || // Also compare calculated treeScale, for values that rely on this only for scale correction
      prevTreeScaleX !== treeScale.x || prevTreeScaleY !== treeScale.y) {
        element.scheduleRender();
      }
      layoutState.deltaTransform = deltaTransform;
    }
    function updateTreeLayoutProjection() {
      element.layoutTree.forEach(fireUpdateLayoutProjection);
    }
    function bindToMotionValue(key2, value2) {
      var removeOnChange = value2.onChange(function(latestValue) {
        latestValues[key2] = latestValue;
        props.onUpdate && es_default.update(update, false, true);
      });
      var removeOnRenderRequest = value2.onRenderRequest(element.scheduleRender);
      valueSubscriptions.set(key2, function() {
        removeOnChange();
        removeOnRenderRequest();
      });
    }
    var initialMotionValues = scrapeMotionValuesFromProps3(props);
    for (var key in initialMotionValues) {
      var value = initialMotionValues[key];
      if (latestValues[key] !== void 0 && isMotionValue(value)) {
        value.set(latestValues[key], false);
      }
    }
    var isControllingVariants = checkIfControllingVariants(props);
    var isVariantNode = checkIfVariantNode(props);
    var element = __assign(__assign({
      treeType,
      /**
       * This is a mirror of the internal instance prop, which keeps
       * VisualElement type-compatible with React's RefObject.
       */
      current: null,
      /**
       * The depth of this visual element within the visual element tree.
       */
      depth: parent ? parent.depth + 1 : 0,
      parent,
      children: /* @__PURE__ */ new Set(),
      /**
       * An ancestor path back to the root visual element. This is used
       * by layout projection to quickly recurse back up the tree.
       */
      path: parent ? __spreadArray(__spreadArray([], __read(parent.path)), [parent]) : [],
      layoutTree: parent ? parent.layoutTree : new FlatTree(),
      /**
       *
       */
      presenceId,
      projection,
      /**
       * If this component is part of the variant tree, it should track
       * any children that are also part of the tree. This is essentially
       * a shadow tree to simplify logic around how to stagger over children.
       */
      variantChildren: isVariantNode ? /* @__PURE__ */ new Set() : void 0,
      /**
       * Whether this instance is visible. This can be changed imperatively
       * by AnimateSharedLayout, is analogous to CSS's visibility in that
       * hidden elements should take up layout, and needs enacting by the configured
       * render function.
       */
      isVisible: void 0,
      /**
       * Normally, if a component is controlled by a parent's variants, it can
       * rely on that ancestor to trigger animations further down the tree.
       * However, if a component is created after its parent is mounted, the parent
       * won't trigger that mount animation so the child needs to.
       *
       * TODO: This might be better replaced with a method isParentMounted
       */
      manuallyAnimateOnMount: Boolean(parent === null || parent === void 0 ? void 0 : parent.isMounted()),
      /**
       * This can be set by AnimatePresence to force components that mount
       * at the same time as it to mount as if they have initial={false} set.
       */
      blockInitialAnimation,
      /**
       * Determine whether this component has mounted yet. This is mostly used
       * by variant children to determine whether they need to trigger their
       * own animations on mount.
       */
      isMounted: function() {
        return Boolean(instance23);
      },
      mount: function(newInstance) {
        instance23 = element.current = newInstance;
        element.pointTo(element);
        if (isVariantNode && parent && !isControllingVariants) {
          removeFromVariantTree = parent === null || parent === void 0 ? void 0 : parent.addVariantChild(element);
        }
        parent === null || parent === void 0 ? void 0 : parent.children.add(element);
      },
      /**
       *
       */
      unmount: function() {
        cancelSync.update(update);
        cancelSync.render(render);
        cancelSync.preRender(element.updateLayoutProjection);
        valueSubscriptions.forEach(function(remove) {
          return remove();
        });
        element.stopLayoutAnimation();
        element.layoutTree.remove(element);
        removeFromVariantTree === null || removeFromVariantTree === void 0 ? void 0 : removeFromVariantTree();
        parent === null || parent === void 0 ? void 0 : parent.children.delete(element);
        unsubscribeFromLeadVisualElement === null || unsubscribeFromLeadVisualElement === void 0 ? void 0 : unsubscribeFromLeadVisualElement();
        lifecycles.clearAllListeners();
      },
      /**
       * Add a child visual element to our set of children.
       */
      addVariantChild: function(child) {
        var _a3;
        var closestVariantNode = element.getClosestVariantNode();
        if (closestVariantNode) {
          (_a3 = closestVariantNode.variantChildren) === null || _a3 === void 0 ? void 0 : _a3.add(child);
          return function() {
            return closestVariantNode.variantChildren.delete(child);
          };
        }
      },
      sortNodePosition: function(other) {
        if (!sortNodePosition || treeType !== other.treeType)
          return 0;
        return sortNodePosition(element.getInstance(), other.getInstance());
      },
      /**
       * Returns the closest variant node in the tree starting from
       * this visual element.
       */
      getClosestVariantNode: function() {
        return isVariantNode ? element : parent === null || parent === void 0 ? void 0 : parent.getClosestVariantNode();
      },
      /**
       * A method that schedules an update to layout projections throughout
       * the tree. We inherit from the parent so there's only ever one
       * job scheduled on the next frame - that of the root visual element.
       */
      scheduleUpdateLayoutProjection: parent ? parent.scheduleUpdateLayoutProjection : function() {
        return es_default.preRender(element.updateTreeLayoutProjection, false, true);
      },
      /**
       * Expose the latest layoutId prop.
       */
      getLayoutId: function() {
        return props.layoutId;
      },
      /**
       * Returns the current instance.
       */
      getInstance: function() {
        return instance23;
      },
      /**
       * Get/set the latest static values.
       */
      getStaticValue: function(key2) {
        return latestValues[key2];
      },
      setStaticValue: function(key2, value2) {
        return latestValues[key2] = value2;
      },
      /**
       * Returns the latest motion value state. Currently only used to take
       * a snapshot of the visual element - perhaps this can return the whole
       * visual state
       */
      getLatestValues: function() {
        return latestValues;
      },
      /**
       * Set the visiblity of the visual element. If it's changed, schedule
       * a render to reflect these changes.
       */
      setVisibility: function(visibility) {
        if (element.isVisible === visibility)
          return;
        element.isVisible = visibility;
        element.scheduleRender();
      },
      /**
       * Make a target animatable by Popmotion. For instance, if we're
       * trying to animate width from 100px to 100vw we need to measure 100vw
       * in pixels to determine what we really need to animate to. This is also
       * pluggable to support Framer's custom value types like Color,
       * and CSS variables.
       */
      makeTargetAnimatable: function(target, canMutate) {
        if (canMutate === void 0) {
          canMutate = true;
        }
        return makeTargetAnimatable(element, target, props, canMutate);
      },
      // Motion values ========================
      /**
       * Add a motion value and bind it to this visual element.
       */
      addValue: function(key2, value2) {
        if (element.hasValue(key2))
          element.removeValue(key2);
        values.set(key2, value2);
        latestValues[key2] = value2.get();
        bindToMotionValue(key2, value2);
      },
      /**
       * Remove a motion value and unbind any active subscriptions.
       */
      removeValue: function(key2) {
        var _a3;
        values.delete(key2);
        (_a3 = valueSubscriptions.get(key2)) === null || _a3 === void 0 ? void 0 : _a3();
        valueSubscriptions.delete(key2);
        delete latestValues[key2];
        removeValueFromRenderState(key2, renderState);
      },
      /**
       * Check whether we have a motion value for this key
       */
      hasValue: function(key2) {
        return values.has(key2);
      },
      /**
       * Get a motion value for this key. If called with a default
       * value, we'll create one if none exists.
       */
      getValue: function(key2, defaultValue) {
        var value2 = values.get(key2);
        if (value2 === void 0 && defaultValue !== void 0) {
          value2 = motionValue(defaultValue);
          element.addValue(key2, value2);
        }
        return value2;
      },
      /**
       * Iterate over our motion values.
       */
      forEachValue: function(callback) {
        return values.forEach(callback);
      },
      /**
       * If we're trying to animate to a previously unencountered value,
       * we need to check for it in our state and as a last resort read it
       * directly from the instance (which might have performance implications).
       */
      readValue: function(key2) {
        var _a3;
        return (_a3 = latestValues[key2]) !== null && _a3 !== void 0 ? _a3 : readValueFromInstance(instance23, key2, options);
      },
      /**
       * Set the base target to later animate back to. This is currently
       * only hydrated on creation and when we first read a value.
       */
      setBaseTarget: function(key2, value2) {
        baseTarget[key2] = value2;
      },
      /**
       * Find the base target for a value thats been removed from all animation
       * props.
       */
      getBaseTarget: function(key2) {
        if (getBaseTarget) {
          var target = getBaseTarget(props, key2);
          if (target !== void 0 && !isMotionValue(target))
            return target;
        }
        return baseTarget[key2];
      }
    }, lifecycles), {
      /**
       * Build the renderer state based on the latest visual state.
       */
      build: function() {
        triggerBuild();
        return renderState;
      },
      /**
       * Schedule a render on the next animation frame.
       */
      scheduleRender: function() {
        es_default.render(render, false, true);
      },
      /**
       * Synchronously fire render. It's prefered that we batch renders but
       * in many circumstances, like layout measurement, we need to run this
       * synchronously. However in those instances other measures should be taken
       * to batch reads/writes.
       */
      syncRender: render,
      /**
       * Update the provided props. Ensure any newly-added motion values are
       * added to our map, old ones removed, and listeners updated.
       */
      setProps: function(newProps) {
        props = newProps;
        lifecycles.updatePropListeners(newProps);
        prevMotionValues = updateMotionValuesFromProps(element, scrapeMotionValuesFromProps3(props), prevMotionValues);
      },
      getProps: function() {
        return props;
      },
      // Variants ==============================
      /**
       * Returns the variant definition with a given name.
       */
      getVariant: function(name) {
        var _a3;
        return (_a3 = props.variants) === null || _a3 === void 0 ? void 0 : _a3[name];
      },
      /**
       * Returns the defined default transition on this component.
       */
      getDefaultTransition: function() {
        return props.transition;
      },
      /**
       * Used by child variant nodes to get the closest ancestor variant props.
       */
      getVariantContext: function(startAtParent) {
        if (startAtParent === void 0) {
          startAtParent = false;
        }
        if (startAtParent)
          return parent === null || parent === void 0 ? void 0 : parent.getVariantContext();
        if (!isControllingVariants) {
          var context_1 = (parent === null || parent === void 0 ? void 0 : parent.getVariantContext()) || {};
          if (props.initial !== void 0) {
            context_1.initial = props.initial;
          }
          return context_1;
        }
        var context = {};
        for (var i = 0; i < numVariantProps; i++) {
          var name_1 = variantProps[i];
          var prop = props[name_1];
          if (isVariantLabel(prop) || prop === false) {
            context[name_1] = prop;
          }
        }
        return context;
      },
      // Layout projection ==============================
      /**
       * Enable layout projection for this visual element. Won't actually
       * occur until we also have hydrated layout measurements.
       */
      enableLayoutProjection: function() {
        projection.isEnabled = true;
        element.layoutTree.add(element);
      },
      /**
       * Lock the projection target, for instance when dragging, so
       * nothing else can try and animate it.
       */
      lockProjectionTarget: function() {
        projection.isTargetLocked = true;
      },
      unlockProjectionTarget: function() {
        element.stopLayoutAnimation();
        projection.isTargetLocked = false;
      },
      getLayoutState: function() {
        return layoutState;
      },
      setCrossfader: function(newCrossfader) {
        crossfader = newCrossfader;
      },
      isProjectionReady: function() {
        return projection.isEnabled && projection.isHydrated && layoutState.isHydrated;
      },
      /**
       * Start a layout animation on a given axis.
       */
      startLayoutAnimation: function(axis, transition, isRelative) {
        if (isRelative === void 0) {
          isRelative = false;
        }
        var progress = element.getProjectionAnimationProgress()[axis];
        var _a3 = isRelative ? projection.relativeTarget[axis] : projection.target[axis], min = _a3.min, max = _a3.max;
        var length = max - min;
        progress.clearListeners();
        progress.set(min);
        progress.set(min);
        progress.onChange(function(v) {
          element.setProjectionTargetAxis(axis, v, v + length, isRelative);
        });
        return element.animateMotionValue(axis, progress, 0, transition);
      },
      /**
       * Stop layout animations.
       */
      stopLayoutAnimation: function() {
        eachAxis(function(axis) {
          return element.getProjectionAnimationProgress()[axis].stop();
        });
      },
      /**
       * Measure the current viewport box with or without transforms.
       * Only measures axis-aligned boxes, rotate and skew must be manually
       * removed with a re-render to work.
       */
      measureViewportBox: function(withTransform) {
        if (withTransform === void 0) {
          withTransform = true;
        }
        var viewportBox = measureViewportBox(instance23, options);
        if (!withTransform)
          removeBoxTransforms(viewportBox, latestValues);
        return viewportBox;
      },
      /**
       * Get the motion values tracking the layout animations on each
       * axis. Lazy init if not already created.
       */
      getProjectionAnimationProgress: function() {
        projectionTargetProgress || (projectionTargetProgress = {
          x: motionValue(0),
          y: motionValue(0)
        });
        return projectionTargetProgress;
      },
      /**
       * Update the projection of a single axis. Schedule an update to
       * the tree layout projection.
       */
      setProjectionTargetAxis: function(axis, min, max, isRelative) {
        if (isRelative === void 0) {
          isRelative = false;
        }
        var target;
        if (isRelative) {
          if (!projection.relativeTarget) {
            projection.relativeTarget = axisBox();
          }
          target = projection.relativeTarget[axis];
        } else {
          projection.relativeTarget = void 0;
          target = projection.target[axis];
        }
        projection.isHydrated = true;
        target.min = min;
        target.max = max;
        hasViewportBoxUpdated = true;
        lifecycles.notifySetAxisTarget();
      },
      /**
       * Rebase the projection target on top of the provided viewport box
       * or the measured layout. This ensures that non-animating elements
       * don't fall out of sync differences in measurements vs projections
       * after a page scroll or other relayout.
       */
      rebaseProjectionTarget: function(force, box) {
        if (box === void 0) {
          box = layoutState.layout;
        }
        var _a3 = element.getProjectionAnimationProgress(), x = _a3.x, y = _a3.y;
        var shouldRebase = !projection.relativeTarget && !projection.isTargetLocked && !x.isAnimating() && !y.isAnimating();
        if (force || shouldRebase) {
          eachAxis(function(axis) {
            var _a4 = box[axis], min = _a4.min, max = _a4.max;
            element.setProjectionTargetAxis(axis, min, max);
          });
        }
      },
      /**
       * Notify the visual element that its layout is up-to-date.
       * Currently Animate.tsx uses this to check whether a layout animation
       * needs to be performed.
       */
      notifyLayoutReady: function(config) {
        setCurrentViewportBox(element);
        element.notifyLayoutUpdate(layoutState.layout, element.prevViewportBox || layoutState.layout, config);
      },
      /**
       * Temporarily reset the transform of the instance.
       */
      resetTransform: function() {
        return resetTransform(element, instance23, props);
      },
      restoreTransform: function() {
        return restoreTransform(instance23, renderState);
      },
      updateLayoutProjection,
      updateTreeLayoutProjection: function() {
        element.layoutTree.forEach(fireResolveRelativeTargetBox);
        es_default.preRender(updateTreeLayoutProjection, false, true);
      },
      getProjectionParent: function() {
        if (projectionParent === void 0) {
          var foundParent = false;
          for (var i = element.path.length - 1; i >= 0; i--) {
            var ancestor = element.path[i];
            if (ancestor.projection.isEnabled) {
              foundParent = ancestor;
              break;
            }
          }
          projectionParent = foundParent;
        }
        return projectionParent;
      },
      resolveRelativeTargetBox: function() {
        var relativeParent = element.getProjectionParent();
        if (!projection.relativeTarget || !relativeParent)
          return;
        calcRelativeBox(projection, relativeParent.projection);
        if (isDraggable(relativeParent)) {
          var target = projection.target;
          applyBoxTransforms(target, target, relativeParent.getLatestValues());
        }
      },
      shouldResetTransform: function() {
        return Boolean(props._layoutResetTransform);
      },
      /**
       *
       */
      pointTo: function(newLead) {
        leadProjection = newLead.projection;
        leadLatestValues = newLead.getLatestValues();
        unsubscribeFromLeadVisualElement === null || unsubscribeFromLeadVisualElement === void 0 ? void 0 : unsubscribeFromLeadVisualElement();
        unsubscribeFromLeadVisualElement = pipe(newLead.onSetAxisTarget(element.scheduleUpdateLayoutProjection), newLead.onLayoutAnimationComplete(function() {
          var _a3;
          if (element.isPresent) {
            element.presence = Presence.Present;
          } else {
            (_a3 = element.layoutSafeToRemove) === null || _a3 === void 0 ? void 0 : _a3.call(element);
          }
        }));
      },
      // TODO: Clean this up
      isPresent: true,
      presence: Presence.Entering
    });
    return element;
  };
};
function fireResolveRelativeTargetBox(child) {
  child.resolveRelativeTargetBox();
}
function fireUpdateLayoutProjection(child) {
  child.updateLayoutProjection();
}
var variantProps = __spreadArray(["initial"], __read(variantPriorityOrder));
var numVariantProps = variantProps.length;

// node_modules/svelte-motion/src/render/dom/utils/css-variables-conversion.js
function isCSSVariable2(value) {
  return typeof value === "string" && value.startsWith("var(--");
}
var cssVariableRegex = /var\((--[a-zA-Z0-9-_]+),? ?([a-zA-Z0-9 ()%#.,-]+)?\)/;
function parseCSSVariable(current) {
  var match = cssVariableRegex.exec(current);
  if (!match)
    return [,];
  var _a = __read(match, 3), token = _a[1], fallback = _a[2];
  return [token, fallback];
}
function getVariableValue(current, element, depth) {
  if (depth === void 0) {
    depth = 1;
  }
  var _a = __read(parseCSSVariable(current), 2), token = _a[0], fallback = _a[1];
  if (!token)
    return;
  var resolved = window.getComputedStyle(element).getPropertyValue(token);
  if (resolved) {
    return resolved.trim();
  } else if (isCSSVariable2(fallback)) {
    return getVariableValue(fallback, element, depth + 1);
  } else {
    return fallback;
  }
}
function resolveCSSVariables(visualElement2, _a, transitionEnd) {
  var _b;
  var target = __rest(_a, []);
  var element = visualElement2.getInstance();
  if (!(element instanceof HTMLElement))
    return { target, transitionEnd };
  if (transitionEnd) {
    transitionEnd = __assign({}, transitionEnd);
  }
  visualElement2.forEachValue(function(value) {
    var current2 = value.get();
    if (!isCSSVariable2(current2))
      return;
    var resolved2 = getVariableValue(current2, element);
    if (resolved2)
      value.set(resolved2);
  });
  for (var key in target) {
    var current = target[key];
    if (!isCSSVariable2(current))
      continue;
    var resolved = getVariableValue(current, element);
    if (!resolved)
      continue;
    target[key] = resolved;
    if (transitionEnd)
      (_b = transitionEnd[key]) !== null && _b !== void 0 ? _b : transitionEnd[key] = current;
  }
  return { target, transitionEnd };
}

// node_modules/svelte-motion/src/render/dom/utils/unit-conversion.js
var positionalKeys = /* @__PURE__ */ new Set([
  "width",
  "height",
  "top",
  "left",
  "right",
  "bottom",
  "x",
  "y"
]);
var isPositionalKey = function(key) {
  return positionalKeys.has(key);
};
var hasPositionalKey = function(target) {
  return Object.keys(target).some(isPositionalKey);
};
var setAndResetVelocity = function(value, to) {
  value.set(to, false);
  value.set(to);
};
var isNumOrPxType = function(v) {
  return v === number || v === px;
};
var BoundingBoxDimension;
(function(BoundingBoxDimension2) {
  BoundingBoxDimension2["width"] = "width";
  BoundingBoxDimension2["height"] = "height";
  BoundingBoxDimension2["left"] = "left";
  BoundingBoxDimension2["right"] = "right";
  BoundingBoxDimension2["top"] = "top";
  BoundingBoxDimension2["bottom"] = "bottom";
})(BoundingBoxDimension || (BoundingBoxDimension = {}));
var getPosFromMatrix = function(matrix, pos) {
  return parseFloat(matrix.split(", ")[pos]);
};
var getTranslateFromMatrix = function(pos2, pos3) {
  return function(_bbox, _a) {
    var transform = _a.transform;
    if (transform === "none" || !transform)
      return 0;
    var matrix3d = transform.match(/^matrix3d\((.+)\)$/);
    if (matrix3d) {
      return getPosFromMatrix(matrix3d[1], pos3);
    } else {
      var matrix = transform.match(/^matrix\((.+)\)$/);
      if (matrix) {
        return getPosFromMatrix(matrix[1], pos2);
      } else {
        return 0;
      }
    }
  };
};
var transformKeys = /* @__PURE__ */ new Set(["x", "y", "z"]);
var nonTranslationalTransformKeys = transformProps.filter(function(key) {
  return !transformKeys.has(key);
});
function removeNonTranslationalTransform(visualElement2) {
  var removedTransforms = [];
  nonTranslationalTransformKeys.forEach(function(key) {
    var value = visualElement2.getValue(key);
    if (value !== void 0) {
      removedTransforms.push([key, value.get()]);
      value.set(key.startsWith("scale") ? 1 : 0);
    }
  });
  if (removedTransforms.length)
    visualElement2.syncRender();
  return removedTransforms;
}
var positionalValues = {
  // Dimensions
  width: function(_a) {
    var x = _a.x;
    return x.max - x.min;
  },
  height: function(_a) {
    var y = _a.y;
    return y.max - y.min;
  },
  top: function(_bbox, _a) {
    var top = _a.top;
    return parseFloat(top);
  },
  left: function(_bbox, _a) {
    var left = _a.left;
    return parseFloat(left);
  },
  bottom: function(_a, _b) {
    var y = _a.y;
    var top = _b.top;
    return parseFloat(top) + (y.max - y.min);
  },
  right: function(_a, _b) {
    var x = _a.x;
    var left = _b.left;
    return parseFloat(left) + (x.max - x.min);
  },
  // Transform
  x: getTranslateFromMatrix(4, 13),
  y: getTranslateFromMatrix(5, 14)
};
var convertChangedValueTypes = function(target, visualElement2, changedKeys) {
  var originBbox = visualElement2.measureViewportBox();
  var element = visualElement2.getInstance();
  var elementComputedStyle = getComputedStyle(element);
  var display = elementComputedStyle.display, top = elementComputedStyle.top, left = elementComputedStyle.left, bottom = elementComputedStyle.bottom, right = elementComputedStyle.right, transform = elementComputedStyle.transform;
  var originComputedStyle = { top, left, bottom, right, transform };
  if (display === "none") {
    visualElement2.setStaticValue("display", target.display || "block");
  }
  visualElement2.syncRender();
  var targetBbox = visualElement2.measureViewportBox();
  changedKeys.forEach(function(key) {
    var value = visualElement2.getValue(key);
    setAndResetVelocity(value, positionalValues[key](originBbox, originComputedStyle));
    target[key] = positionalValues[key](targetBbox, elementComputedStyle);
  });
  return target;
};
var checkAndConvertChangedValueTypes = function(visualElement2, target, origin, transitionEnd) {
  if (origin === void 0) {
    origin = {};
  }
  if (transitionEnd === void 0) {
    transitionEnd = {};
  }
  target = __assign({}, target);
  transitionEnd = __assign({}, transitionEnd);
  var targetPositionalKeys = Object.keys(target).filter(isPositionalKey);
  var removedTransformValues = [];
  var hasAttemptedToRemoveTransformValues = false;
  var changedValueTypeKeys = [];
  targetPositionalKeys.forEach(function(key) {
    var value = visualElement2.getValue(key);
    if (!visualElement2.hasValue(key))
      return;
    var from = origin[key];
    var to = target[key];
    var fromType = findDimensionValueType(from);
    var toType;
    if (isKeyframesTarget(to)) {
      var numKeyframes = to.length;
      for (var i = to[0] === null ? 1 : 0; i < numKeyframes; i++) {
        if (!toType) {
          toType = findDimensionValueType(to[i]);
        }
      }
    } else {
      toType = findDimensionValueType(to);
    }
    if (fromType !== toType) {
      if (isNumOrPxType(fromType) && isNumOrPxType(toType)) {
        var current = value.get();
        if (typeof current === "string") {
          value.set(parseFloat(current));
        }
        if (typeof to === "string") {
          target[key] = parseFloat(to);
        } else if (Array.isArray(to) && toType === px) {
          target[key] = to.map(parseFloat);
        }
      } else if ((fromType === null || fromType === void 0 ? void 0 : fromType.transform) && (toType === null || toType === void 0 ? void 0 : toType.transform) && (from === 0 || to === 0)) {
        if (from === 0) {
          value.set(toType.transform(from));
        } else {
          target[key] = fromType.transform(to);
        }
      } else {
        if (!hasAttemptedToRemoveTransformValues) {
          removedTransformValues = removeNonTranslationalTransform(visualElement2);
          hasAttemptedToRemoveTransformValues = true;
        }
        changedValueTypeKeys.push(key);
        transitionEnd[key] = transitionEnd[key] !== void 0 ? transitionEnd[key] : target[key];
        setAndResetVelocity(value, to);
      }
    }
  });
  if (changedValueTypeKeys.length) {
    var convertedTarget = convertChangedValueTypes(target, visualElement2, changedValueTypeKeys);
    if (removedTransformValues.length) {
      removedTransformValues.forEach(function(_a) {
        var _b = __read(_a, 2), key = _b[0], value = _b[1];
        visualElement2.getValue(key).set(value);
      });
    }
    visualElement2.syncRender();
    return { target: convertedTarget, transitionEnd };
  } else {
    return { target, transitionEnd };
  }
};
function unitConversion(visualElement2, target, origin, transitionEnd) {
  return hasPositionalKey(target) ? checkAndConvertChangedValueTypes(visualElement2, target, origin, transitionEnd) : { target, transitionEnd };
}

// node_modules/svelte-motion/src/render/dom/utils/parse-dom-variant.js
var parseDomVariant = function(visualElement2, target, origin, transitionEnd) {
  var resolved = resolveCSSVariables(visualElement2, target, transitionEnd);
  target = resolved.target;
  transitionEnd = resolved.transitionEnd;
  return unitConversion(visualElement2, target, origin, transitionEnd);
};

// node_modules/svelte-motion/src/render/html/utils/scrape-motion-values.js
function scrapeMotionValuesFromProps(props) {
  var style = props.style;
  var newValues = {};
  for (var key in style) {
    if (isMotionValue(style[key]) || isForcedMotionValue(key, props)) {
      newValues[key] = style[key];
    }
  }
  return newValues;
}

// node_modules/svelte-motion/src/render/html/utils/render.js
function renderHTML(element, _a) {
  var style = _a.style, vars = _a.vars;
  Object.assign(element.style, style);
  for (var key in vars) {
    element.style.setProperty(key, vars[key]);
  }
}

// node_modules/svelte-motion/src/render/html/visual-element.js
function getComputedStyle2(element) {
  return window.getComputedStyle(element);
}
var htmlConfig = {
  treeType: "dom",
  readValueFromInstance: function(domElement, key) {
    if (isTransformProp(key)) {
      var defaultType = getDefaultValueType(key);
      return defaultType ? defaultType.default || 0 : 0;
    } else {
      var computedStyle = getComputedStyle2(domElement);
      return (isCSSVariable(key) ? computedStyle.getPropertyValue(key) : computedStyle[key]) || 0;
    }
  },
  sortNodePosition: function(a, b) {
    return a.compareDocumentPosition(b) & 2 ? 1 : -1;
  },
  getBaseTarget: function(props, key) {
    var _a;
    return (_a = props.style) === null || _a === void 0 ? void 0 : _a[key];
  },
  measureViewportBox: function(element, _a) {
    var transformPagePoint = _a.transformPagePoint;
    return getBoundingBox(element, transformPagePoint);
  },
  /**
   * Reset the transform on the current Element. This is called as part
   * of a batched process across the entire layout tree. To remove this write
   * cycle it'd be interesting to see if it's possible to "undo" all the current
   * layout transforms up the tree in the same way this.getBoundingBoxWithoutTransforms
   * works
   */
  resetTransform: function(element, domElement, props) {
    var transformTemplate = props.transformTemplate;
    domElement.style.transform = transformTemplate ? transformTemplate({}, "") : "none";
    element.scheduleRender();
  },
  restoreTransform: function(instance23, mutableState) {
    instance23.style.transform = mutableState.style.transform;
  },
  removeValueFromRenderState: function(key, _a) {
    var vars = _a.vars, style = _a.style;
    delete vars[key];
    delete style[key];
  },
  /**
   * Ensure that HTML and Framer-specific value types like `px`->`%` and `Color`
   * can be animated by Motion.
   */
  makeTargetAnimatable: function(element, _a, _b, isMounted) {
    var transformValues = _b.transformValues;
    if (isMounted === void 0) {
      isMounted = true;
    }
    var transition = _a.transition, transitionEnd = _a.transitionEnd, target = __rest(_a, ["transition", "transitionEnd"]);
    var origin = getOrigin(target, transition || {}, element);
    if (transformValues) {
      if (transitionEnd)
        transitionEnd = transformValues(transitionEnd);
      if (target)
        target = transformValues(target);
      if (origin)
        origin = transformValues(origin);
    }
    if (isMounted) {
      checkTargetForNewValues(element, target, origin);
      var parsed = parseDomVariant(element, target, origin, transitionEnd);
      transitionEnd = parsed.transitionEnd;
      target = parsed.target;
    }
    return __assign({
      transition,
      transitionEnd
    }, target);
  },
  scrapeMotionValuesFromProps,
  build: function(element, renderState, latestValues, projection, layoutState, options, props) {
    if (element.isVisible !== void 0) {
      renderState.style.visibility = element.isVisible ? "visible" : "hidden";
    }
    var isProjectionTranform = projection.isEnabled && layoutState.isHydrated;
    buildHTMLStyles(renderState, latestValues, projection, layoutState, options, props.transformTemplate, isProjectionTranform ? buildLayoutProjectionTransform : void 0, isProjectionTranform ? buildLayoutProjectionTransformOrigin : void 0);
  },
  render: renderHTML
};
var htmlVisualElement = visualElement(htmlConfig);

// node_modules/svelte-motion/src/render/svg/utils/scrape-motion-values.js
function scrapeMotionValuesFromProps2(props) {
  var newValues = scrapeMotionValuesFromProps(props);
  for (var key in props) {
    if (isMotionValue(props[key])) {
      var targetKey = key === "x" || key === "y" ? "attr" + key.toUpperCase() : key;
      newValues[targetKey] = props[key];
    }
  }
  return newValues;
}

// node_modules/svelte-motion/src/render/dom/utils/camel-to-dash.js
var CAMEL_CASE_PATTERN = /([a-z])([A-Z])/g;
var REPLACE_TEMPLATE = "$1-$2";
var camelToDash = function(str) {
  return str.replace(CAMEL_CASE_PATTERN, REPLACE_TEMPLATE).toLowerCase();
};

// node_modules/svelte-motion/src/render/svg/utils/camel-case-attrs.js
var camelCaseAttributes = /* @__PURE__ */ new Set([
  "baseFrequency",
  "diffuseConstant",
  "kernelMatrix",
  "kernelUnitLength",
  "keySplines",
  "keyTimes",
  "limitingConeAngle",
  "markerHeight",
  "markerWidth",
  "numOctaves",
  "targetX",
  "targetY",
  "surfaceScale",
  "specularConstant",
  "specularExponent",
  "stdDeviation",
  "tableValues",
  "viewBox"
]);

// node_modules/svelte-motion/src/render/svg/utils/render.js
function renderSVG(element, renderState) {
  renderHTML(element, renderState);
  for (var key in renderState.attrs) {
    element.setAttribute(!camelCaseAttributes.has(key) ? camelToDash(key) : key, renderState.attrs[key]);
  }
}

// node_modules/svelte-motion/src/render/svg/visual-element.js
var svgVisualElement = visualElement(__assign(__assign({}, htmlConfig), {
  getBaseTarget: function(props, key) {
    return props[key];
  },
  readValueFromInstance: function(domElement, key) {
    var _a;
    if (isTransformProp(key)) {
      return ((_a = getDefaultValueType(key)) === null || _a === void 0 ? void 0 : _a.default) || 0;
    }
    key = !camelCaseAttributes.has(key) ? camelToDash(key) : key;
    return domElement.getAttribute(key);
  },
  scrapeMotionValuesFromProps: scrapeMotionValuesFromProps2,
  build: function(_element, renderState, latestValues, projection, layoutState, options, props) {
    var isProjectionTranform = projection.isEnabled && layoutState.isHydrated;
    buildSVGAttrs(renderState, latestValues, projection, layoutState, options, props.transformTemplate, isProjectionTranform ? buildLayoutProjectionTransform : void 0, isProjectionTranform ? buildLayoutProjectionTransformOrigin : void 0);
  },
  render: renderSVG
}));

// node_modules/svelte-motion/src/render/dom/create-visual-element.js
var createDomVisualElement = function(Component, options) {
  return Component === "SVG" ? svgVisualElement(options, { enableHardwareAcceleration: false }) : htmlVisualElement(options, { enableHardwareAcceleration: true });
};

// node_modules/svelte-motion/src/render/svg/config-motion.js
var svgMotionConfig = {
  scrapeMotionValuesFromProps: scrapeMotionValuesFromProps2,
  createRenderState: createSvgRenderState,
  onMount: function(props, instance23, _a) {
    var renderState = _a.renderState, latestValues = _a.latestValues;
    try {
      renderState.dimensions = typeof instance23.getBBox === "function" ? instance23.getBBox() : instance23.getBoundingClientRect();
    } catch (e) {
      renderState.dimensions = {
        x: 0,
        y: 0,
        width: 0,
        height: 0
      };
    }
    if (isPath(instance23)) {
      renderState.totalPathLength = instance23.getTotalLength();
    }
    buildSVGAttrs(renderState, latestValues, void 0, void 0, { enableHardwareAcceleration: false }, props.transformTemplate);
    renderSVG(instance23, renderState);
  }
};
function isPath(element) {
  return element.tagName === "path";
}

// node_modules/svelte-motion/src/render/html/config-motion.js
var htmlMotionConfig = {
  scrapeMotionValuesFromProps,
  createRenderState: createHtmlRenderState
};

// node_modules/svelte-motion/src/context/MotionContext/utils.js
function getCurrentTreeVariants(props, context) {
  if (checkIfControllingVariants(props)) {
    var initial = props.initial, animate = props.animate;
    return {
      initial: initial === false || isVariantLabel(initial) ? initial : void 0,
      animate: isVariantLabel(animate) ? animate : void 0
    };
  }
  return props.inherit !== false ? context || {} : {};
}

// node_modules/svelte-motion/src/context/MotionContext/UseCreateMotionContext.svelte
var get_default_slot_changes8 = (dirty) => ({ value: dirty & /*value*/
1 });
var get_default_slot_context8 = (ctx) => ({ value: (
  /*value*/
  ctx[0]
) });
function create_fragment9(ctx) {
  let current;
  const default_slot_template = (
    /*#slots*/
    ctx[9].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[8],
    get_default_slot_context8
  );
  const block = {
    c: function create() {
      if (default_slot)
        default_slot.c();
    },
    l: function claim(nodes) {
      if (default_slot)
        default_slot.l(nodes);
    },
    m: function mount(target, anchor) {
      if (default_slot) {
        default_slot.m(target, anchor);
      }
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope, value*/
        257)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[8],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[8]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[8],
              dirty,
              get_default_slot_changes8
            ),
            get_default_slot_context8
          );
        }
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(default_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (default_slot)
        default_slot.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment9.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance9($$self, $$props, $$invalidate) {
  let $mc;
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("UseCreateMotionContext", slots, ["default"]);
  let { props, isStatic, isCustom } = $$props;
  let mc = getContext(MotionContext) || MotionContext(isCustom);
  validate_store(mc, "mc");
  component_subscribe($$self, mc, (value2) => $$invalidate(7, $mc = value2));
  let { initial, animate } = getCurrentTreeVariants(props, get_store_value(mc));
  const variantLabelsAsDependency = (prop) => {
    return Array.isArray(prop) ? prop.join(" ") : prop;
  };
  const memo = () => {
    return { initial, animate };
  };
  let value = memo();
  $$self.$$.on_mount.push(function() {
    if (props === void 0 && !("props" in $$props || $$self.$$.bound[$$self.$$.props["props"]])) {
      console.warn("<UseCreateMotionContext> was created without expected prop 'props'");
    }
    if (isStatic === void 0 && !("isStatic" in $$props || $$self.$$.bound[$$self.$$.props["isStatic"]])) {
      console.warn("<UseCreateMotionContext> was created without expected prop 'isStatic'");
    }
    if (isCustom === void 0 && !("isCustom" in $$props || $$self.$$.bound[$$self.$$.props["isCustom"]])) {
      console.warn("<UseCreateMotionContext> was created without expected prop 'isCustom'");
    }
  });
  const writable_props = ["props", "isStatic", "isCustom"];
  Object.keys($$props).forEach((key) => {
    if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$" && key !== "slot")
      console.warn(`<UseCreateMotionContext> was created with unknown prop '${key}'`);
  });
  $$self.$$set = ($$props2) => {
    if ("props" in $$props2)
      $$invalidate(2, props = $$props2.props);
    if ("isStatic" in $$props2)
      $$invalidate(3, isStatic = $$props2.isStatic);
    if ("isCustom" in $$props2)
      $$invalidate(4, isCustom = $$props2.isCustom);
    if ("$$scope" in $$props2)
      $$invalidate(8, $$scope = $$props2.$$scope);
  };
  $$self.$capture_state = () => ({
    getContext,
    get: get_store_value,
    MotionContext,
    getCurrentTreeVariants,
    props,
    isStatic,
    isCustom,
    mc,
    initial,
    animate,
    variantLabelsAsDependency,
    memo,
    value,
    $mc
  });
  $$self.$inject_state = ($$props2) => {
    if ("props" in $$props2)
      $$invalidate(2, props = $$props2.props);
    if ("isStatic" in $$props2)
      $$invalidate(3, isStatic = $$props2.isStatic);
    if ("isCustom" in $$props2)
      $$invalidate(4, isCustom = $$props2.isCustom);
    if ("mc" in $$props2)
      $$invalidate(1, mc = $$props2.mc);
    if ("initial" in $$props2)
      $$invalidate(5, initial = $$props2.initial);
    if ("animate" in $$props2)
      $$invalidate(6, animate = $$props2.animate);
    if ("value" in $$props2)
      $$invalidate(0, value = $$props2.value);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$self.$$.update = () => {
    if ($$self.$$.dirty & /*props, $mc*/
    132) {
      $:
        $$invalidate(5, { initial, animate } = getCurrentTreeVariants(props, $mc), initial, ($$invalidate(6, animate), $$invalidate(2, props), $$invalidate(7, $mc)));
    }
    if ($$self.$$.dirty & /*isStatic, initial, animate*/
    104) {
      $:
        if (isStatic) {
          $$invalidate(0, value = memo(variantLabelsAsDependency(initial), variantLabelsAsDependency(animate)));
        }
    }
  };
  return [value, mc, props, isStatic, isCustom, initial, animate, $mc, $$scope, slots];
}
var UseCreateMotionContext = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance9, create_fragment9, safe_not_equal, { props: 2, isStatic: 3, isCustom: 4 });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "UseCreateMotionContext",
      options,
      id: create_fragment9.name
    });
  }
  get props() {
    throw new Error("<UseCreateMotionContext>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set props(value) {
    throw new Error("<UseCreateMotionContext>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get isStatic() {
    throw new Error("<UseCreateMotionContext>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set isStatic(value) {
    throw new Error("<UseCreateMotionContext>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get isCustom() {
    throw new Error("<UseCreateMotionContext>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set isCustom(value) {
    throw new Error("<UseCreateMotionContext>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var UseCreateMotionContext_default = UseCreateMotionContext;

// node_modules/svelte-motion/src/value/utils/resolve-motion-value.js
function resolveMotionValue(value) {
  var unwrappedValue = isMotionValue(value) ? value.get() : value;
  return isCustomValue(unwrappedValue) ? unwrappedValue.toValue() : unwrappedValue;
}

// node_modules/svelte-motion/src/motion/utils/UseVisualState.svelte
var get_default_slot_changes9 = (dirty) => ({ state: dirty & /*state*/
1 });
var get_default_slot_context9 = (ctx) => ({ state: (
  /*state*/
  ctx[0]
) });
function create_fragment10(ctx) {
  let current;
  const default_slot_template = (
    /*#slots*/
    ctx[10].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[9],
    get_default_slot_context9
  );
  const block = {
    c: function create() {
      if (default_slot)
        default_slot.c();
    },
    l: function claim(nodes) {
      if (default_slot)
        default_slot.l(nodes);
    },
    m: function mount(target, anchor) {
      if (default_slot) {
        default_slot.m(target, anchor);
      }
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope, state*/
        513)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[9],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[9]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[9],
              dirty,
              get_default_slot_changes9
            ),
            get_default_slot_context9
          );
        }
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(default_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (default_slot)
        default_slot.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment10.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
var makeState = ({ scrapeMotionValuesFromProps: scrapeMotionValuesFromProps3, createRenderState, onMount: onMount2 }, props, context, presenceContext) => {
  const state = {
    latestValues: makeLatestValues(props, context, presenceContext, scrapeMotionValuesFromProps3),
    renderState: createRenderState()
  };
  if (onMount2) {
    state.mount = (instance23) => onMount2(props, instance23, state);
  }
  return state;
};
function makeLatestValues(props, context, presenceContext, scrapeMotionValues) {
  const values = {};
  const blockInitialAnimation = (presenceContext == null ? void 0 : presenceContext.initial) === false;
  const motionValues = scrapeMotionValues(props);
  for (const key in motionValues) {
    values[key] = resolveMotionValue(motionValues[key]);
  }
  let { initial, animate } = props;
  const isControllingVariants = checkIfControllingVariants(props);
  const isVariantNode = checkIfVariantNode(props);
  if (context && isVariantNode && !isControllingVariants && props.inherit !== false) {
    initial !== null && initial !== void 0 ? initial : initial = context.initial;
    animate !== null && animate !== void 0 ? animate : animate = context.animate;
  }
  const variantToSet = blockInitialAnimation || initial === false ? animate : initial;
  if (variantToSet && typeof variantToSet !== "boolean" && !isAnimationControls(variantToSet)) {
    const list = Array.isArray(variantToSet) ? variantToSet : [variantToSet];
    list.forEach((definition) => {
      const resolved = resolveVariantFromProps(props, definition);
      if (!resolved)
        return;
      const { transitionEnd, transition, ...target } = resolved;
      for (const key in target)
        values[key] = target[key];
      for (const key in transitionEnd)
        values[key] = transitionEnd[key];
    });
  }
  return values;
}
function instance10($$self, $$props, $$invalidate) {
  let $presenceContext;
  let $context;
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("UseVisualState", slots, ["default"]);
  let { config, props, isStatic, isCustom } = $$props;
  const context = getContext(MotionContext) || MotionContext(isCustom);
  validate_store(context, "context");
  component_subscribe($$self, context, (value) => $$invalidate(8, $context = value));
  const presenceContext = getContext(PresenceContext) || PresenceContext(isCustom);
  validate_store(presenceContext, "presenceContext");
  component_subscribe($$self, presenceContext, (value) => $$invalidate(7, $presenceContext = value));
  let state = makeState(config, props, get_store_value(context), get_store_value(presenceContext));
  const ms = makeState;
  $$self.$$.on_mount.push(function() {
    if (config === void 0 && !("config" in $$props || $$self.$$.bound[$$self.$$.props["config"]])) {
      console.warn("<UseVisualState> was created without expected prop 'config'");
    }
    if (props === void 0 && !("props" in $$props || $$self.$$.bound[$$self.$$.props["props"]])) {
      console.warn("<UseVisualState> was created without expected prop 'props'");
    }
    if (isStatic === void 0 && !("isStatic" in $$props || $$self.$$.bound[$$self.$$.props["isStatic"]])) {
      console.warn("<UseVisualState> was created without expected prop 'isStatic'");
    }
    if (isCustom === void 0 && !("isCustom" in $$props || $$self.$$.bound[$$self.$$.props["isCustom"]])) {
      console.warn("<UseVisualState> was created without expected prop 'isCustom'");
    }
  });
  const writable_props = ["config", "props", "isStatic", "isCustom"];
  Object.keys($$props).forEach((key) => {
    if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$" && key !== "slot")
      console.warn(`<UseVisualState> was created with unknown prop '${key}'`);
  });
  $$self.$$set = ($$props2) => {
    if ("config" in $$props2)
      $$invalidate(3, config = $$props2.config);
    if ("props" in $$props2)
      $$invalidate(4, props = $$props2.props);
    if ("isStatic" in $$props2)
      $$invalidate(5, isStatic = $$props2.isStatic);
    if ("isCustom" in $$props2)
      $$invalidate(6, isCustom = $$props2.isCustom);
    if ("$$scope" in $$props2)
      $$invalidate(9, $$scope = $$props2.$$scope);
  };
  $$self.$capture_state = () => ({
    resolveMotionValue,
    checkIfControllingVariants,
    checkIfVariantNode,
    resolveVariantFromProps,
    isAnimationControls,
    makeState,
    makeLatestValues,
    getContext,
    get: get_store_value,
    PresenceContext,
    MotionContext,
    config,
    props,
    isStatic,
    isCustom,
    context,
    presenceContext,
    state,
    ms,
    $presenceContext,
    $context
  });
  $$self.$inject_state = ($$props2) => {
    if ("config" in $$props2)
      $$invalidate(3, config = $$props2.config);
    if ("props" in $$props2)
      $$invalidate(4, props = $$props2.props);
    if ("isStatic" in $$props2)
      $$invalidate(5, isStatic = $$props2.isStatic);
    if ("isCustom" in $$props2)
      $$invalidate(6, isCustom = $$props2.isCustom);
    if ("state" in $$props2)
      $$invalidate(0, state = $$props2.state);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$self.$$.update = () => {
    if ($$self.$$.dirty & /*isStatic, config, props, $context, $presenceContext*/
    440) {
      $:
        if (isStatic) {
          $$invalidate(0, state = ms(config, props, $context, $presenceContext));
        }
    }
  };
  return [
    state,
    context,
    presenceContext,
    config,
    props,
    isStatic,
    isCustom,
    $presenceContext,
    $context,
    $$scope,
    slots
  ];
}
var UseVisualState = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance10, create_fragment10, safe_not_equal, {
      config: 3,
      props: 4,
      isStatic: 5,
      isCustom: 6
    });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "UseVisualState",
      options,
      id: create_fragment10.name
    });
  }
  get config() {
    throw new Error("<UseVisualState>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set config(value) {
    throw new Error("<UseVisualState>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get props() {
    throw new Error("<UseVisualState>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set props(value) {
    throw new Error("<UseVisualState>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get isStatic() {
    throw new Error("<UseVisualState>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set isStatic(value) {
    throw new Error("<UseVisualState>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get isCustom() {
    throw new Error("<UseVisualState>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set isCustom(value) {
    throw new Error("<UseVisualState>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var UseVisualState_default = UseVisualState;

// node_modules/svelte-motion/src/motion/utils/use-motion-ref.js
function useMotionRef(visualState, visualElement2, externalRef) {
  return function(instance23) {
    var _a;
    instance23 && ((_a = visualState.mount) === null || _a === void 0 ? void 0 : _a.call(visualState, instance23));
    if (visualElement2) {
      instance23 ? visualElement2.mount(instance23) : visualElement2.unmount();
    }
    if (externalRef) {
      if (typeof externalRef === "function") {
        externalRef(instance23);
      } else if (isRefObject(externalRef)) {
        externalRef.current = instance23;
      }
    }
  };
}

// node_modules/svelte-motion/src/gestures/UseFocusGesture.svelte
function create_default_slot_1(ctx) {
  let current;
  const default_slot_template = (
    /*#slots*/
    ctx[5].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[6],
    null
  );
  const block = {
    c: function create() {
      if (default_slot)
        default_slot.c();
    },
    l: function claim(nodes) {
      if (default_slot)
        default_slot.l(nodes);
    },
    m: function mount(target, anchor) {
      if (default_slot) {
        default_slot.m(target, anchor);
      }
      current = true;
    },
    p: function update(ctx2, dirty) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope*/
        64)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[6],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[6]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[6],
              dirty,
              null
            ),
            null
          );
        }
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(default_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (default_slot)
        default_slot.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot_1.name,
    type: "slot",
    source: '(22:4) <UseDomEvent ref={visualElement} eventName=\\"blur\\" handler={whileFocus ? onBlur : undefined}>',
    ctx
  });
  return block;
}
function create_default_slot4(ctx) {
  let usedomevent;
  let current;
  usedomevent = new UseDomEvent_default({
    props: {
      ref: (
        /*visualElement*/
        ctx[0]
      ),
      eventName: "blur",
      handler: (
        /*whileFocus*/
        ctx[1] ? (
          /*onBlur*/
          ctx[3]
        ) : void 0
      ),
      $$slots: { default: [create_default_slot_1] },
      $$scope: { ctx }
    },
    $$inline: true
  });
  const block = {
    c: function create() {
      create_component(usedomevent.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(usedomevent.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(usedomevent, target, anchor);
      current = true;
    },
    p: function update(ctx2, dirty) {
      const usedomevent_changes = {};
      if (dirty & /*visualElement*/
      1)
        usedomevent_changes.ref = /*visualElement*/
        ctx2[0];
      if (dirty & /*whileFocus*/
      2)
        usedomevent_changes.handler = /*whileFocus*/
        ctx2[1] ? (
          /*onBlur*/
          ctx2[3]
        ) : void 0;
      if (dirty & /*$$scope*/
      64) {
        usedomevent_changes.$$scope = { dirty, ctx: ctx2 };
      }
      usedomevent.$set(usedomevent_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(usedomevent.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(usedomevent.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(usedomevent, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot4.name,
    type: "slot",
    source: '(21:0) <UseDomEvent ref={visualElement} eventName=\\"focus\\" handler={whileFocus ? onFocus : undefined}>',
    ctx
  });
  return block;
}
function create_fragment11(ctx) {
  let usedomevent;
  let current;
  usedomevent = new UseDomEvent_default({
    props: {
      ref: (
        /*visualElement*/
        ctx[0]
      ),
      eventName: "focus",
      handler: (
        /*whileFocus*/
        ctx[1] ? (
          /*onFocus*/
          ctx[2]
        ) : void 0
      ),
      $$slots: { default: [create_default_slot4] },
      $$scope: { ctx }
    },
    $$inline: true
  });
  const block = {
    c: function create() {
      create_component(usedomevent.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(usedomevent.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(usedomevent, target, anchor);
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      const usedomevent_changes = {};
      if (dirty & /*visualElement*/
      1)
        usedomevent_changes.ref = /*visualElement*/
        ctx2[0];
      if (dirty & /*whileFocus*/
      2)
        usedomevent_changes.handler = /*whileFocus*/
        ctx2[1] ? (
          /*onFocus*/
          ctx2[2]
        ) : void 0;
      if (dirty & /*$$scope, visualElement, whileFocus*/
      67) {
        usedomevent_changes.$$scope = { dirty, ctx: ctx2 };
      }
      usedomevent.$set(usedomevent_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(usedomevent.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(usedomevent.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(usedomevent, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment11.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance11($$self, $$props, $$invalidate) {
  let whileFocus;
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("UseFocusGesture", slots, ["default"]);
  let { props, visualElement: visualElement2 } = $$props;
  const onFocus = () => {
    var _a;
    (_a = visualElement2.animationState) == null ? void 0 : _a.setActive(AnimationType.Focus, true);
  };
  const onBlur = () => {
    var _a;
    (_a = visualElement2.animationState) == null ? void 0 : _a.setActive(AnimationType.Focus, false);
  };
  $$self.$$.on_mount.push(function() {
    if (props === void 0 && !("props" in $$props || $$self.$$.bound[$$self.$$.props["props"]])) {
      console.warn("<UseFocusGesture> was created without expected prop 'props'");
    }
    if (visualElement2 === void 0 && !("visualElement" in $$props || $$self.$$.bound[$$self.$$.props["visualElement"]])) {
      console.warn("<UseFocusGesture> was created without expected prop 'visualElement'");
    }
  });
  const writable_props = ["props", "visualElement"];
  Object.keys($$props).forEach((key) => {
    if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$" && key !== "slot")
      console.warn(`<UseFocusGesture> was created with unknown prop '${key}'`);
  });
  $$self.$$set = ($$props2) => {
    if ("props" in $$props2)
      $$invalidate(4, props = $$props2.props);
    if ("visualElement" in $$props2)
      $$invalidate(0, visualElement2 = $$props2.visualElement);
    if ("$$scope" in $$props2)
      $$invalidate(6, $$scope = $$props2.$$scope);
  };
  $$self.$capture_state = () => ({
    UseDomEvent: UseDomEvent_default,
    AnimationType,
    props,
    visualElement: visualElement2,
    onFocus,
    onBlur,
    whileFocus
  });
  $$self.$inject_state = ($$props2) => {
    if ("props" in $$props2)
      $$invalidate(4, props = $$props2.props);
    if ("visualElement" in $$props2)
      $$invalidate(0, visualElement2 = $$props2.visualElement);
    if ("whileFocus" in $$props2)
      $$invalidate(1, whileFocus = $$props2.whileFocus);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$self.$$.update = () => {
    if ($$self.$$.dirty & /*props*/
    16) {
      $:
        $$invalidate(1, { whileFocus } = props, whileFocus);
    }
  };
  return [visualElement2, whileFocus, onFocus, onBlur, props, slots, $$scope];
}
var UseFocusGesture = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance11, create_fragment11, safe_not_equal, { props: 4, visualElement: 0 });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "UseFocusGesture",
      options,
      id: create_fragment11.name
    });
  }
  get props() {
    throw new Error("<UseFocusGesture>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set props(value) {
    throw new Error("<UseFocusGesture>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get visualElement() {
    throw new Error("<UseFocusGesture>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set visualElement(value) {
    throw new Error("<UseFocusGesture>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var UseFocusGesture_default = UseFocusGesture;

// node_modules/svelte-motion/src/gestures/UseHoverGesture.svelte
function create_fragment12(ctx) {
  let usepointerevent0;
  let t0;
  let usepointerevent1;
  let t1;
  let current;
  usepointerevent0 = new UsePointerEvent_default({
    props: {
      ref: (
        /*visualElement*/
        ctx[0]
      ),
      eventName: "pointerenter",
      handler: (
        /*onHoverStart*/
        ctx[1] || /*whileHover*/
        ctx[3] ? createHoverEvent(
          /*visualElement*/
          ctx[0],
          true,
          /*onHoverStart*/
          ctx[1]
        ) : void 0
      )
    },
    $$inline: true
  });
  usepointerevent1 = new UsePointerEvent_default({
    props: {
      ref: (
        /*visualElement*/
        ctx[0]
      ),
      eventName: "pointerleave",
      handler: (
        /*onHoverEnd*/
        ctx[2] || /*whileHover*/
        ctx[3] ? createHoverEvent(
          /*visualElement*/
          ctx[0],
          false,
          /*onHoverEnd*/
          ctx[2]
        ) : void 0
      )
    },
    $$inline: true
  });
  const default_slot_template = (
    /*#slots*/
    ctx[6].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[5],
    null
  );
  const block = {
    c: function create() {
      create_component(usepointerevent0.$$.fragment);
      t0 = space();
      create_component(usepointerevent1.$$.fragment);
      t1 = space();
      if (default_slot)
        default_slot.c();
    },
    l: function claim(nodes) {
      claim_component(usepointerevent0.$$.fragment, nodes);
      t0 = claim_space(nodes);
      claim_component(usepointerevent1.$$.fragment, nodes);
      t1 = claim_space(nodes);
      if (default_slot)
        default_slot.l(nodes);
    },
    m: function mount(target, anchor) {
      mount_component(usepointerevent0, target, anchor);
      insert_hydration_dev(target, t0, anchor);
      mount_component(usepointerevent1, target, anchor);
      insert_hydration_dev(target, t1, anchor);
      if (default_slot) {
        default_slot.m(target, anchor);
      }
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      const usepointerevent0_changes = {};
      if (dirty & /*visualElement*/
      1)
        usepointerevent0_changes.ref = /*visualElement*/
        ctx2[0];
      if (dirty & /*onHoverStart, whileHover, visualElement*/
      11)
        usepointerevent0_changes.handler = /*onHoverStart*/
        ctx2[1] || /*whileHover*/
        ctx2[3] ? createHoverEvent(
          /*visualElement*/
          ctx2[0],
          true,
          /*onHoverStart*/
          ctx2[1]
        ) : void 0;
      usepointerevent0.$set(usepointerevent0_changes);
      const usepointerevent1_changes = {};
      if (dirty & /*visualElement*/
      1)
        usepointerevent1_changes.ref = /*visualElement*/
        ctx2[0];
      if (dirty & /*onHoverEnd, whileHover, visualElement*/
      13)
        usepointerevent1_changes.handler = /*onHoverEnd*/
        ctx2[2] || /*whileHover*/
        ctx2[3] ? createHoverEvent(
          /*visualElement*/
          ctx2[0],
          false,
          /*onHoverEnd*/
          ctx2[2]
        ) : void 0;
      usepointerevent1.$set(usepointerevent1_changes);
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope*/
        32)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[5],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[5]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[5],
              dirty,
              null
            ),
            null
          );
        }
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(usepointerevent0.$$.fragment, local);
      transition_in(usepointerevent1.$$.fragment, local);
      transition_in(default_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(usepointerevent0.$$.fragment, local);
      transition_out(usepointerevent1.$$.fragment, local);
      transition_out(default_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(t0);
        detach_dev(t1);
      }
      destroy_component(usepointerevent0, detaching);
      destroy_component(usepointerevent1, detaching);
      if (default_slot)
        default_slot.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment12.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function createHoverEvent(visualElement2, isActive, callback) {
  return (event, info) => {
    var _a;
    if (!isMouseEvent(event) || isDragActive())
      return;
    callback == null ? void 0 : callback(event, info);
    (_a = visualElement2.animationState) == null ? void 0 : _a.setActive(AnimationType.Hover, isActive);
  };
}
function instance12($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("UseHoverGesture", slots, ["default"]);
  let { props, visualElement: visualElement2 } = $$props;
  let { onHoverStart, onHoverEnd, whileHover } = props;
  $$self.$$.on_mount.push(function() {
    if (props === void 0 && !("props" in $$props || $$self.$$.bound[$$self.$$.props["props"]])) {
      console.warn("<UseHoverGesture> was created without expected prop 'props'");
    }
    if (visualElement2 === void 0 && !("visualElement" in $$props || $$self.$$.bound[$$self.$$.props["visualElement"]])) {
      console.warn("<UseHoverGesture> was created without expected prop 'visualElement'");
    }
  });
  const writable_props = ["props", "visualElement"];
  Object.keys($$props).forEach((key) => {
    if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$" && key !== "slot")
      console.warn(`<UseHoverGesture> was created with unknown prop '${key}'`);
  });
  $$self.$$set = ($$props2) => {
    if ("props" in $$props2)
      $$invalidate(4, props = $$props2.props);
    if ("visualElement" in $$props2)
      $$invalidate(0, visualElement2 = $$props2.visualElement);
    if ("$$scope" in $$props2)
      $$invalidate(5, $$scope = $$props2.$$scope);
  };
  $$self.$capture_state = () => ({
    isDragActive,
    createHoverEvent,
    UsePointerEvent: UsePointerEvent_default,
    AnimationType,
    isMouseEvent,
    props,
    visualElement: visualElement2,
    onHoverStart,
    onHoverEnd,
    whileHover
  });
  $$self.$inject_state = ($$props2) => {
    if ("props" in $$props2)
      $$invalidate(4, props = $$props2.props);
    if ("visualElement" in $$props2)
      $$invalidate(0, visualElement2 = $$props2.visualElement);
    if ("onHoverStart" in $$props2)
      $$invalidate(1, onHoverStart = $$props2.onHoverStart);
    if ("onHoverEnd" in $$props2)
      $$invalidate(2, onHoverEnd = $$props2.onHoverEnd);
    if ("whileHover" in $$props2)
      $$invalidate(3, whileHover = $$props2.whileHover);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$self.$$.update = () => {
    if ($$self.$$.dirty & /*props*/
    16) {
      $:
        $$invalidate(1, { onHoverStart, onHoverEnd, whileHover } = props, onHoverStart, ($$invalidate(2, onHoverEnd), $$invalidate(4, props)), ($$invalidate(3, whileHover), $$invalidate(4, props)));
    }
  };
  return [visualElement2, onHoverStart, onHoverEnd, whileHover, props, $$scope, slots];
}
var UseHoverGesture = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance12, create_fragment12, safe_not_equal, { props: 4, visualElement: 0 });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "UseHoverGesture",
      options,
      id: create_fragment12.name
    });
  }
  get props() {
    throw new Error("<UseHoverGesture>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set props(value) {
    throw new Error("<UseHoverGesture>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get visualElement() {
    throw new Error("<UseHoverGesture>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set visualElement(value) {
    throw new Error("<UseHoverGesture>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var UseHoverGesture_default = UseHoverGesture;

// node_modules/svelte-motion/src/gestures/utils/is-node-or-child.js
var isNodeOrChild = function(parent, child) {
  if (!child) {
    return false;
  } else if (parent === child) {
    return true;
  } else {
    return isNodeOrChild(parent, child.parentElement);
  }
};

// node_modules/svelte-motion/src/gestures/UseTapGesture.svelte
function create_default_slot5(ctx) {
  let current;
  const default_slot_template = (
    /*#slots*/
    ctx[8].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[9],
    null
  );
  const block = {
    c: function create() {
      if (default_slot)
        default_slot.c();
    },
    l: function claim(nodes) {
      if (default_slot)
        default_slot.l(nodes);
    },
    m: function mount(target, anchor) {
      if (default_slot) {
        default_slot.m(target, anchor);
      }
      current = true;
    },
    p: function update(ctx2, dirty) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope*/
        512)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[9],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[9]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[9],
              dirty,
              null
            ),
            null
          );
        }
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(default_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (default_slot)
        default_slot.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot5.name,
    type: "slot",
    source: '(73:0) <UsePointerEvent     ref={visualElement}     eventName=\\"pointerdown\\"     handler={hasPressListeners ? onPointerDown : undefined}>',
    ctx
  });
  return block;
}
function create_fragment13(ctx) {
  let usepointerevent;
  let current;
  usepointerevent = new UsePointerEvent_default({
    props: {
      ref: (
        /*visualElement*/
        ctx[0]
      ),
      eventName: "pointerdown",
      handler: (
        /*hasPressListeners*/
        ctx[1] ? (
          /*onPointerDown*/
          ctx[2]
        ) : void 0
      ),
      $$slots: { default: [create_default_slot5] },
      $$scope: { ctx }
    },
    $$inline: true
  });
  const block = {
    c: function create() {
      create_component(usepointerevent.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(usepointerevent.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(usepointerevent, target, anchor);
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      const usepointerevent_changes = {};
      if (dirty & /*visualElement*/
      1)
        usepointerevent_changes.ref = /*visualElement*/
        ctx2[0];
      if (dirty & /*hasPressListeners*/
      2)
        usepointerevent_changes.handler = /*hasPressListeners*/
        ctx2[1] ? (
          /*onPointerDown*/
          ctx2[2]
        ) : void 0;
      if (dirty & /*$$scope*/
      512) {
        usepointerevent_changes.$$scope = { dirty, ctx: ctx2 };
      }
      usepointerevent.$set(usepointerevent_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(usepointerevent.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(usepointerevent.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(usepointerevent, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment13.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance13($$self, $$props, $$invalidate) {
  let onTap;
  let onTapStart;
  let onTapCancel;
  let whileTap;
  let hasPressListeners;
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("UseTapGesture", slots, ["default"]);
  let { props, visualElement: visualElement2 } = $$props;
  let isPressing = false;
  let cancelPointerEndListeners = null;
  function removePointerEndListener() {
    cancelPointerEndListeners == null ? void 0 : cancelPointerEndListeners();
    cancelPointerEndListeners = null;
  }
  function checkPointerEnd() {
    var _a;
    removePointerEndListener();
    isPressing = false;
    (_a = visualElement2.animationState) == null ? void 0 : _a.setActive(AnimationType.Tap, false);
    return !isDragActive();
  }
  function onPointerUp(event, info) {
    if (!checkPointerEnd())
      return;
    !isNodeOrChild(visualElement2.getInstance(), event.target) ? onTapCancel == null ? void 0 : onTapCancel(event, info) : onTap == null ? void 0 : onTap(event, info);
  }
  function onPointerCancel(event, info) {
    if (!checkPointerEnd())
      return;
    onTapCancel == null ? void 0 : onTapCancel(event, info);
  }
  function onPointerDown(event, info) {
    var _a;
    if (isPressing)
      return;
    removePointerEndListener();
    isPressing = true;
    cancelPointerEndListeners = pipe(addPointerEvent(window, "pointerup", onPointerUp), addPointerEvent(window, "pointercancel", onPointerCancel));
    onTapStart == null ? void 0 : onTapStart(event, info);
    (_a = visualElement2.animationState) == null ? void 0 : _a.setActive(AnimationType.Tap, true);
  }
  onDestroy(removePointerEndListener);
  $$self.$$.on_mount.push(function() {
    if (props === void 0 && !("props" in $$props || $$self.$$.bound[$$self.$$.props["props"]])) {
      console.warn("<UseTapGesture> was created without expected prop 'props'");
    }
    if (visualElement2 === void 0 && !("visualElement" in $$props || $$self.$$.bound[$$self.$$.props["visualElement"]])) {
      console.warn("<UseTapGesture> was created without expected prop 'visualElement'");
    }
  });
  const writable_props = ["props", "visualElement"];
  Object.keys($$props).forEach((key) => {
    if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$" && key !== "slot")
      console.warn(`<UseTapGesture> was created with unknown prop '${key}'`);
  });
  $$self.$$set = ($$props2) => {
    if ("props" in $$props2)
      $$invalidate(3, props = $$props2.props);
    if ("visualElement" in $$props2)
      $$invalidate(0, visualElement2 = $$props2.visualElement);
    if ("$$scope" in $$props2)
      $$invalidate(9, $$scope = $$props2.$$scope);
  };
  $$self.$capture_state = () => ({
    fixed,
    isNodeOrChild,
    pipe,
    isDragActive,
    onDestroy,
    UsePointerEvent: UsePointerEvent_default,
    addPointerEvent,
    AnimationType,
    props,
    visualElement: visualElement2,
    isPressing,
    cancelPointerEndListeners,
    removePointerEndListener,
    checkPointerEnd,
    onPointerUp,
    onPointerCancel,
    onPointerDown,
    onTapStart,
    onTapCancel,
    onTap,
    whileTap,
    hasPressListeners
  });
  $$self.$inject_state = ($$props2) => {
    if ("props" in $$props2)
      $$invalidate(3, props = $$props2.props);
    if ("visualElement" in $$props2)
      $$invalidate(0, visualElement2 = $$props2.visualElement);
    if ("isPressing" in $$props2)
      isPressing = $$props2.isPressing;
    if ("cancelPointerEndListeners" in $$props2)
      cancelPointerEndListeners = $$props2.cancelPointerEndListeners;
    if ("onTapStart" in $$props2)
      $$invalidate(4, onTapStart = $$props2.onTapStart);
    if ("onTapCancel" in $$props2)
      $$invalidate(5, onTapCancel = $$props2.onTapCancel);
    if ("onTap" in $$props2)
      $$invalidate(6, onTap = $$props2.onTap);
    if ("whileTap" in $$props2)
      $$invalidate(7, whileTap = $$props2.whileTap);
    if ("hasPressListeners" in $$props2)
      $$invalidate(1, hasPressListeners = $$props2.hasPressListeners);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$self.$$.update = () => {
    if ($$self.$$.dirty & /*props*/
    8) {
      $:
        $$invalidate(6, { onTap, onTapStart, onTapCancel, whileTap } = props, onTap, ($$invalidate(4, onTapStart), $$invalidate(3, props)), ($$invalidate(5, onTapCancel), $$invalidate(3, props)), ($$invalidate(7, whileTap), $$invalidate(3, props)));
    }
    if ($$self.$$.dirty & /*onTap, onTapStart, onTapCancel, whileTap*/
    240) {
      $:
        $$invalidate(1, hasPressListeners = onTap || onTapStart || onTapCancel || whileTap);
    }
  };
  return [
    visualElement2,
    hasPressListeners,
    onPointerDown,
    props,
    onTapStart,
    onTapCancel,
    onTap,
    whileTap,
    slots,
    $$scope
  ];
}
var UseTapGesture = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance13, create_fragment13, safe_not_equal, { props: 3, visualElement: 0 });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "UseTapGesture",
      options,
      id: create_fragment13.name
    });
  }
  get props() {
    throw new Error("<UseTapGesture>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set props(value) {
    throw new Error("<UseTapGesture>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get visualElement() {
    throw new Error("<UseTapGesture>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set visualElement(value) {
    throw new Error("<UseTapGesture>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var UseTapGesture_default = UseTapGesture;

// node_modules/svelte-motion/src/motion/features/gestures.js
var gestureAnimations = {
  tap: UseTapGesture_default,
  focus: UseFocusGesture_default,
  hover: UseHoverGesture_default
};

// node_modules/svelte-motion/src/gestures/UsePanGesture.svelte
function create_default_slot6(ctx) {
  let current;
  const default_slot_template = (
    /*#slots*/
    ctx[11].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[12],
    null
  );
  const block = {
    c: function create() {
      if (default_slot)
        default_slot.c();
    },
    l: function claim(nodes) {
      if (default_slot)
        default_slot.l(nodes);
    },
    m: function mount(target, anchor) {
      if (default_slot) {
        default_slot.m(target, anchor);
      }
      current = true;
    },
    p: function update(ctx2, dirty) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope*/
        4096)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[12],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[12]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[12],
              dirty,
              null
            ),
            null
          );
        }
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(default_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (default_slot)
        default_slot.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot6.name,
    type: "slot",
    source: '(61:0) <UsePointerEvent ref={visualElement} eventName=\\"pointerdown\\" handler={hasPanEvents && onPointerDown}>',
    ctx
  });
  return block;
}
function create_fragment14(ctx) {
  let usepointerevent;
  let current;
  usepointerevent = new UsePointerEvent_default({
    props: {
      ref: (
        /*visualElement*/
        ctx[0]
      ),
      eventName: "pointerdown",
      handler: (
        /*hasPanEvents*/
        ctx[1] && /*onPointerDown*/
        ctx[3]
      ),
      $$slots: { default: [create_default_slot6] },
      $$scope: { ctx }
    },
    $$inline: true
  });
  const block = {
    c: function create() {
      create_component(usepointerevent.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(usepointerevent.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(usepointerevent, target, anchor);
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      const usepointerevent_changes = {};
      if (dirty & /*visualElement*/
      1)
        usepointerevent_changes.ref = /*visualElement*/
        ctx2[0];
      if (dirty & /*hasPanEvents*/
      2)
        usepointerevent_changes.handler = /*hasPanEvents*/
        ctx2[1] && /*onPointerDown*/
        ctx2[3];
      if (dirty & /*$$scope*/
      4096) {
        usepointerevent_changes.$$scope = { dirty, ctx: ctx2 };
      }
      usepointerevent.$set(usepointerevent_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(usepointerevent.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(usepointerevent.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(usepointerevent, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment14.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance14($$self, $$props, $$invalidate) {
  let hasPanEvents;
  let $mcc;
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("UsePanGesture", slots, ["default"]);
  let { props, visualElement: visualElement2, isCustom } = $$props;
  let { onPan, onPanStart, onPanEnd, onPanSessionStart } = props;
  let panSession = null;
  const mcc = getContext(MotionConfigContext) || MotionConfigContext(isCustom);
  validate_store(mcc, "mcc");
  component_subscribe($$self, mcc, (value) => $$invalidate(10, $mcc = value));
  let { transformPagePoint } = get_store_value(mcc);
  let handlers = {
    onSessionStart: onPanSessionStart,
    onStart: onPanStart,
    onMove: onPan,
    onEnd: (event, info) => {
      panSession = null;
      onPanEnd && onPanEnd(event, info);
    }
  };
  function onPointerDown(event) {
    panSession = new PanSession(event, handlers, { transformPagePoint });
  }
  afterUpdate(() => {
    if (panSession !== null) {
      panSession.updateHandlers(handlers);
    }
  });
  onDestroy(() => panSession && panSession.end());
  $$self.$$.on_mount.push(function() {
    if (props === void 0 && !("props" in $$props || $$self.$$.bound[$$self.$$.props["props"]])) {
      console.warn("<UsePanGesture> was created without expected prop 'props'");
    }
    if (visualElement2 === void 0 && !("visualElement" in $$props || $$self.$$.bound[$$self.$$.props["visualElement"]])) {
      console.warn("<UsePanGesture> was created without expected prop 'visualElement'");
    }
    if (isCustom === void 0 && !("isCustom" in $$props || $$self.$$.bound[$$self.$$.props["isCustom"]])) {
      console.warn("<UsePanGesture> was created without expected prop 'isCustom'");
    }
  });
  const writable_props = ["props", "visualElement", "isCustom"];
  Object.keys($$props).forEach((key) => {
    if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$" && key !== "slot")
      console.warn(`<UsePanGesture> was created with unknown prop '${key}'`);
  });
  $$self.$$set = ($$props2) => {
    if ("props" in $$props2)
      $$invalidate(4, props = $$props2.props);
    if ("visualElement" in $$props2)
      $$invalidate(0, visualElement2 = $$props2.visualElement);
    if ("isCustom" in $$props2)
      $$invalidate(5, isCustom = $$props2.isCustom);
    if ("$$scope" in $$props2)
      $$invalidate(12, $$scope = $$props2.$$scope);
  };
  $$self.$capture_state = () => ({
    MotionConfigContext,
    PanSession,
    afterUpdate,
    getContext,
    onDestroy,
    UsePointerEvent: UsePointerEvent_default,
    get: get_store_value,
    props,
    visualElement: visualElement2,
    isCustom,
    onPan,
    onPanStart,
    onPanEnd,
    onPanSessionStart,
    panSession,
    mcc,
    transformPagePoint,
    handlers,
    onPointerDown,
    hasPanEvents,
    $mcc
  });
  $$self.$inject_state = ($$props2) => {
    if ("props" in $$props2)
      $$invalidate(4, props = $$props2.props);
    if ("visualElement" in $$props2)
      $$invalidate(0, visualElement2 = $$props2.visualElement);
    if ("isCustom" in $$props2)
      $$invalidate(5, isCustom = $$props2.isCustom);
    if ("onPan" in $$props2)
      $$invalidate(6, onPan = $$props2.onPan);
    if ("onPanStart" in $$props2)
      $$invalidate(7, onPanStart = $$props2.onPanStart);
    if ("onPanEnd" in $$props2)
      $$invalidate(8, onPanEnd = $$props2.onPanEnd);
    if ("onPanSessionStart" in $$props2)
      $$invalidate(9, onPanSessionStart = $$props2.onPanSessionStart);
    if ("panSession" in $$props2)
      panSession = $$props2.panSession;
    if ("transformPagePoint" in $$props2)
      transformPagePoint = $$props2.transformPagePoint;
    if ("handlers" in $$props2)
      handlers = $$props2.handlers;
    if ("hasPanEvents" in $$props2)
      $$invalidate(1, hasPanEvents = $$props2.hasPanEvents);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$self.$$.update = () => {
    if ($$self.$$.dirty & /*props*/
    16) {
      $:
        $$invalidate(6, { onPan, onPanStart, onPanEnd, onPanSessionStart } = props, onPan, ($$invalidate(7, onPanStart), $$invalidate(4, props)), ($$invalidate(8, onPanEnd), $$invalidate(4, props)), ($$invalidate(9, onPanSessionStart), $$invalidate(4, props)));
    }
    if ($$self.$$.dirty & /*onPan, onPanStart, onPanEnd, onPanSessionStart*/
    960) {
      $:
        $$invalidate(1, hasPanEvents = onPan || onPanStart || onPanEnd || onPanSessionStart);
    }
    if ($$self.$$.dirty & /*$mcc*/
    1024) {
      $:
        ({ transformPagePoint } = $mcc);
    }
    if ($$self.$$.dirty & /*onPanSessionStart, onPanStart, onPan, onPanEnd*/
    960) {
      $:
        handlers = {
          onSessionStart: onPanSessionStart,
          onStart: onPanStart,
          onMove: onPan,
          onEnd: (event, info) => {
            panSession = null;
            onPanEnd && onPanEnd(event, info);
          }
        };
    }
  };
  return [
    visualElement2,
    hasPanEvents,
    mcc,
    onPointerDown,
    props,
    isCustom,
    onPan,
    onPanStart,
    onPanEnd,
    onPanSessionStart,
    $mcc,
    slots,
    $$scope
  ];
}
var UsePanGesture = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance14, create_fragment14, safe_not_equal, { props: 4, visualElement: 0, isCustom: 5 });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "UsePanGesture",
      options,
      id: create_fragment14.name
    });
  }
  get props() {
    throw new Error("<UsePanGesture>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set props(value) {
    throw new Error("<UsePanGesture>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get visualElement() {
    throw new Error("<UsePanGesture>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set visualElement(value) {
    throw new Error("<UsePanGesture>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get isCustom() {
    throw new Error("<UsePanGesture>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set isCustom(value) {
    throw new Error("<UsePanGesture>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var UsePanGesture_default = UsePanGesture;

// node_modules/svelte-motion/src/gestures/drag/UseDrag.svelte
function create_fragment15(ctx) {
  let current;
  const default_slot_template = (
    /*#slots*/
    ctx[7].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[6],
    null
  );
  const block = {
    c: function create() {
      if (default_slot)
        default_slot.c();
    },
    l: function claim(nodes) {
      if (default_slot)
        default_slot.l(nodes);
    },
    m: function mount(target, anchor) {
      if (default_slot) {
        default_slot.m(target, anchor);
      }
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope*/
        64)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[6],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[6]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[6],
              dirty,
              null
            ),
            null
          );
        }
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(default_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (default_slot)
        default_slot.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment15.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance15($$self, $$props, $$invalidate) {
  let $mcc;
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("UseDrag", slots, ["default"]);
  let { visualElement: visualElement2, props, isCustom } = $$props;
  const mcc = getContext(MotionConfigContext) || MotionConfigContext(isCustom);
  validate_store(mcc, "mcc");
  component_subscribe($$self, mcc, (value) => $$invalidate(5, $mcc = value));
  let dragControls = new VisualElementDragControls({ visualElement: visualElement2 });
  let cleanup;
  const dragEffect = () => {
    if (cleanup) {
      cleanup();
    }
    if (groupDragControls) {
      cleanup = groupDragControls.subscribe(dragControls);
    }
  };
  let { dragControls: groupDragControls } = props;
  let { transformPagePoint } = get_store_value(mcc);
  dragControls.setProps({ ...props, transformPagePoint });
  onDestroy(() => {
    if (cleanup) {
      cleanup();
    }
  });
  onMount(() => dragControls.mount(visualElement2));
  $$self.$$.on_mount.push(function() {
    if (visualElement2 === void 0 && !("visualElement" in $$props || $$self.$$.bound[$$self.$$.props["visualElement"]])) {
      console.warn("<UseDrag> was created without expected prop 'visualElement'");
    }
    if (props === void 0 && !("props" in $$props || $$self.$$.bound[$$self.$$.props["props"]])) {
      console.warn("<UseDrag> was created without expected prop 'props'");
    }
    if (isCustom === void 0 && !("isCustom" in $$props || $$self.$$.bound[$$self.$$.props["isCustom"]])) {
      console.warn("<UseDrag> was created without expected prop 'isCustom'");
    }
  });
  const writable_props = ["visualElement", "props", "isCustom"];
  Object.keys($$props).forEach((key) => {
    if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$" && key !== "slot")
      console.warn(`<UseDrag> was created with unknown prop '${key}'`);
  });
  $$self.$$set = ($$props2) => {
    if ("visualElement" in $$props2)
      $$invalidate(1, visualElement2 = $$props2.visualElement);
    if ("props" in $$props2)
      $$invalidate(2, props = $$props2.props);
    if ("isCustom" in $$props2)
      $$invalidate(3, isCustom = $$props2.isCustom);
    if ("$$scope" in $$props2)
      $$invalidate(6, $$scope = $$props2.$$scope);
  };
  $$self.$capture_state = () => ({
    MotionConfigContext,
    VisualElementDragControls,
    getContext,
    onDestroy,
    onMount,
    get: get_store_value,
    visualElement: visualElement2,
    props,
    isCustom,
    mcc,
    dragControls,
    cleanup,
    dragEffect,
    groupDragControls,
    transformPagePoint,
    $mcc
  });
  $$self.$inject_state = ($$props2) => {
    if ("visualElement" in $$props2)
      $$invalidate(1, visualElement2 = $$props2.visualElement);
    if ("props" in $$props2)
      $$invalidate(2, props = $$props2.props);
    if ("isCustom" in $$props2)
      $$invalidate(3, isCustom = $$props2.isCustom);
    if ("dragControls" in $$props2)
      $$invalidate(10, dragControls = $$props2.dragControls);
    if ("cleanup" in $$props2)
      cleanup = $$props2.cleanup;
    if ("groupDragControls" in $$props2)
      groupDragControls = $$props2.groupDragControls;
    if ("transformPagePoint" in $$props2)
      $$invalidate(4, transformPagePoint = $$props2.transformPagePoint);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$self.$$.update = () => {
    if ($$self.$$.dirty & /*props*/
    4) {
      $:
        ({ dragControls: groupDragControls } = props);
    }
    if ($$self.$$.dirty & /*$mcc*/
    32) {
      $:
        $$invalidate(4, { transformPagePoint } = $mcc, transformPagePoint);
    }
    if ($$self.$$.dirty & /*props, transformPagePoint*/
    20) {
      $:
        dragControls.setProps({ ...props, transformPagePoint });
    }
  };
  $:
    dragEffect(dragControls);
  return [mcc, visualElement2, props, isCustom, transformPagePoint, $mcc, $$scope, slots];
}
var UseDrag = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance15, create_fragment15, safe_not_equal, { visualElement: 1, props: 2, isCustom: 3 });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "UseDrag",
      options,
      id: create_fragment15.name
    });
  }
  get visualElement() {
    throw new Error("<UseDrag>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set visualElement(value) {
    throw new Error("<UseDrag>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get props() {
    throw new Error("<UseDrag>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set props(value) {
    throw new Error("<UseDrag>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get isCustom() {
    throw new Error("<UseDrag>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set isCustom(value) {
    throw new Error("<UseDrag>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var UseDrag_default = UseDrag;

// node_modules/svelte-motion/src/motion/features/drag.js
var drag = {
  pan: UsePanGesture_default,
  drag: UseDrag_default
};

// node_modules/svelte-motion/src/render/dom/projection/default-scale-correctors.js
function pixelsToPercent(pixels, axis) {
  return pixels / (axis.max - axis.min) * 100;
}
function correctBorderRadius(latest, _layoutState, _a) {
  var target = _a.target;
  if (typeof latest === "string") {
    if (px.test(latest)) {
      latest = parseFloat(latest);
    } else {
      return latest;
    }
  }
  var x = pixelsToPercent(latest, target.x);
  var y = pixelsToPercent(latest, target.y);
  return x + "% " + y + "%";
}
var varToken = "_$css";
function correctBoxShadow(latest, _a) {
  var delta2 = _a.delta, treeScale = _a.treeScale;
  var original = latest;
  var containsCSSVariables = latest.includes("var(");
  var cssVariables = [];
  if (containsCSSVariables) {
    latest = latest.replace(cssVariableRegex, function(match) {
      cssVariables.push(match);
      return varToken;
    });
  }
  var shadow = complex.parse(latest);
  if (shadow.length > 5)
    return original;
  var template = complex.createTransformer(latest);
  var offset = typeof shadow[0] !== "number" ? 1 : 0;
  var xScale = delta2.x.scale * treeScale.x;
  var yScale = delta2.y.scale * treeScale.y;
  shadow[0 + offset] /= xScale;
  shadow[1 + offset] /= yScale;
  var averageScale = mix(xScale, yScale, 0.5);
  if (typeof shadow[2 + offset] === "number")
    shadow[2 + offset] /= averageScale;
  if (typeof shadow[3 + offset] === "number")
    shadow[3 + offset] /= averageScale;
  var output = template(shadow);
  if (containsCSSVariables) {
    var i_1 = 0;
    output = output.replace(varToken, function() {
      var cssVariable = cssVariables[i_1];
      i_1++;
      return cssVariable;
    });
  }
  return output;
}
var borderCorrectionDefinition = {
  process: correctBorderRadius
};
var defaultScaleCorrectors = {
  borderRadius: __assign(__assign({}, borderCorrectionDefinition), { applyTo: [
    "borderTopLeftRadius",
    "borderTopRightRadius",
    "borderBottomLeftRadius",
    "borderBottomRightRadius"
  ] }),
  borderTopLeftRadius: borderCorrectionDefinition,
  borderTopRightRadius: borderCorrectionDefinition,
  borderBottomLeftRadius: borderCorrectionDefinition,
  borderBottomRightRadius: borderCorrectionDefinition,
  boxShadow: {
    process: correctBoxShadow
  }
};

// node_modules/svelte-motion/src/motion/features/layout/Animate.svelte
function create_fragment16(ctx) {
  const block = {
    c: noop,
    l: noop,
    m: noop,
    p: noop,
    i: noop,
    o: noop,
    d: noop
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment16.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
var progressTarget = 1e3;
function hasMoved(a, b) {
  return !isZeroBox(a) && !isZeroBox(b) && (!axisIsEqual(a.x, b.x) || !axisIsEqual(a.y, b.y));
}
var zeroAxis = { min: 0, max: 0 };
function isZeroBox(a) {
  return axisIsEqual(a.x, zeroAxis) && axisIsEqual(a.y, zeroAxis);
}
function axisIsEqual(a, b) {
  return a.min === b.min && a.max === b.max;
}
var defaultLayoutTransition = { duration: 0.45, ease: [0.4, 0, 0.1, 1] };
function instance16($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("Animate", slots, []);
  let { visualElement: visualElement2, layout = void 0, safeToRemove } = $$props;
  let frameTarget = axisBox();
  let currentAnimationTarget = axisBox();
  let isAnimating = { x: false, y: false };
  let stopAxisAnimation = { x: void 0, y: void 0 };
  let unsubLayoutReady;
  let isAnimatingTree = false;
  onMount(() => {
    $$invalidate(0, visualElement2.animateMotionValue = startAnimation, visualElement2);
    visualElement2.enableLayoutProjection();
    unsubLayoutReady = visualElement2.onLayoutUpdate(animateF);
    $$invalidate(
      0,
      visualElement2.layoutSafeToRemove = function() {
        safeToRemove();
      },
      visualElement2
    );
    addScaleCorrection(defaultScaleCorrectors);
  });
  onDestroy(() => {
    unsubLayoutReady();
    eachAxis((axis) => {
      var _a;
      return (_a = stopAxisAnimation[axis]) == null ? void 0 : _a.call(stopAxisAnimation);
    });
  });
  const animateF = (target, origin, { originBox, targetBox, visibilityAction, shouldStackAnimate, onComplete, ...config } = {}) => {
    if (shouldStackAnimate === false) {
      isAnimatingTree = false;
      return safeToRemove();
    }
    if (isAnimatingTree && shouldStackAnimate !== true) {
      return;
    } else if (shouldStackAnimate) {
      isAnimatingTree = true;
    }
    origin = originBox || origin;
    target = targetBox || target;
    const boxHasMoved = hasMoved(origin, target);
    const animations2 = eachAxis((axis) => {
      if (layout === "position") {
        const targetLength = target[axis].max - target[axis].min;
        origin[axis].max = origin[axis].min + targetLength;
      }
      if (visualElement2.projection.isTargetLocked) {
        return;
      } else if (visibilityAction !== void 0) {
        visualElement2.setVisibility(visibilityAction === VisibilityAction.Show);
      } else if (boxHasMoved) {
        return animateAxis(axis, target[axis], origin[axis], config);
      } else {
        return visualElement2.setProjectionTargetAxis(axis, target[axis].min, target[axis].max);
      }
    });
    visualElement2.syncRender();
    return Promise.all(animations2).then(() => {
      isAnimatingTree = false;
      onComplete && onComplete();
      visualElement2.notifyLayoutAnimationComplete();
    });
  };
  const animateAxis = (axis, target, origin, { transition: _transition } = {}) => {
    var _a, _b;
    (_a = stopAxisAnimation[axis]) == null ? void 0 : _a.call(stopAxisAnimation);
    if (isAnimating[axis] && axisIsEqual(target, currentAnimationTarget[axis])) {
      return;
    }
    (_b = stopAxisAnimation[axis]) == null ? void 0 : _b.call(stopAxisAnimation);
    isAnimating[axis] = true;
    const _frameTarget = frameTarget[axis];
    const layoutProgress = visualElement2.getProjectionAnimationProgress()[axis];
    layoutProgress.clearListeners();
    layoutProgress.set(0);
    layoutProgress.set(0);
    const frame = () => {
      const p = layoutProgress.get() / progressTarget;
      tweenAxis(_frameTarget, origin, target, p);
      visualElement2.setProjectionTargetAxis(axis, _frameTarget.min, _frameTarget.max);
    };
    frame();
    const unsubscribeProgress = layoutProgress.onChange(frame);
    stopAxisAnimation[axis] = () => {
      isAnimating[axis] = false;
      layoutProgress.stop();
      unsubscribeProgress();
    };
    currentAnimationTarget[axis] = target;
    const layoutTransition = _transition || visualElement2.getDefaultTransition() || defaultLayoutTransition;
    const animation = startAnimation(axis === "x" ? "layoutX" : "layoutY", layoutProgress, progressTarget, layoutTransition && getValueTransition(layoutTransition, "layout")).then(stopAxisAnimation[axis]);
    return animation;
  };
  $$self.$$.on_mount.push(function() {
    if (visualElement2 === void 0 && !("visualElement" in $$props || $$self.$$.bound[$$self.$$.props["visualElement"]])) {
      console.warn("<Animate> was created without expected prop 'visualElement'");
    }
    if (safeToRemove === void 0 && !("safeToRemove" in $$props || $$self.$$.bound[$$self.$$.props["safeToRemove"]])) {
      console.warn("<Animate> was created without expected prop 'safeToRemove'");
    }
  });
  const writable_props = ["visualElement", "layout", "safeToRemove"];
  Object.keys($$props).forEach((key) => {
    if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$" && key !== "slot")
      console.warn(`<Animate> was created with unknown prop '${key}'`);
  });
  $$self.$$set = ($$props2) => {
    if ("visualElement" in $$props2)
      $$invalidate(0, visualElement2 = $$props2.visualElement);
    if ("layout" in $$props2)
      $$invalidate(1, layout = $$props2.layout);
    if ("safeToRemove" in $$props2)
      $$invalidate(2, safeToRemove = $$props2.safeToRemove);
  };
  $$self.$capture_state = () => ({
    progressTarget,
    hasMoved,
    zeroAxis,
    isZeroBox,
    axisIsEqual,
    defaultLayoutTransition,
    onDestroy,
    onMount,
    axisBox,
    eachAxis,
    startAnimation,
    getValueTransition,
    tweenAxis,
    addScaleCorrection,
    defaultScaleCorrectors,
    visualElement: visualElement2,
    layout,
    safeToRemove,
    frameTarget,
    currentAnimationTarget,
    isAnimating,
    stopAxisAnimation,
    unsubLayoutReady,
    isAnimatingTree,
    animateF,
    animateAxis
  });
  $$self.$inject_state = ($$props2) => {
    if ("visualElement" in $$props2)
      $$invalidate(0, visualElement2 = $$props2.visualElement);
    if ("layout" in $$props2)
      $$invalidate(1, layout = $$props2.layout);
    if ("safeToRemove" in $$props2)
      $$invalidate(2, safeToRemove = $$props2.safeToRemove);
    if ("frameTarget" in $$props2)
      frameTarget = $$props2.frameTarget;
    if ("currentAnimationTarget" in $$props2)
      currentAnimationTarget = $$props2.currentAnimationTarget;
    if ("isAnimating" in $$props2)
      isAnimating = $$props2.isAnimating;
    if ("stopAxisAnimation" in $$props2)
      stopAxisAnimation = $$props2.stopAxisAnimation;
    if ("unsubLayoutReady" in $$props2)
      unsubLayoutReady = $$props2.unsubLayoutReady;
    if ("isAnimatingTree" in $$props2)
      isAnimatingTree = $$props2.isAnimatingTree;
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  return [visualElement2, layout, safeToRemove];
}
var Animate = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance16, create_fragment16, safe_not_equal, {
      visualElement: 0,
      layout: 1,
      safeToRemove: 2
    });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "Animate",
      options,
      id: create_fragment16.name
    });
  }
  get visualElement() {
    throw new Error("<Animate>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set visualElement(value) {
    throw new Error("<Animate>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get layout() {
    throw new Error("<Animate>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set layout(value) {
    throw new Error("<Animate>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get safeToRemove() {
    throw new Error("<Animate>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set safeToRemove(value) {
    throw new Error("<Animate>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var Animate_default = Animate;

// node_modules/svelte-motion/src/motion/features/layout/AnimateLayoutContextProvider.svelte
function create_fragment17(ctx) {
  let animate;
  let current;
  animate = new Animate_default({
    props: {
      visualElement: (
        /*visualElement*/
        ctx[0]
      ),
      layout: (
        /*layout*/
        ctx[1]
      ),
      safeToRemove: (
        /*$presence*/
        ctx[2][1]
      )
    },
    $$inline: true
  });
  const block = {
    c: function create() {
      create_component(animate.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(animate.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(animate, target, anchor);
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      const animate_changes = {};
      if (dirty & /*visualElement*/
      1)
        animate_changes.visualElement = /*visualElement*/
        ctx2[0];
      if (dirty & /*layout*/
      2)
        animate_changes.layout = /*layout*/
        ctx2[1];
      if (dirty & /*$presence*/
      4)
        animate_changes.safeToRemove = /*$presence*/
        ctx2[2][1];
      animate.$set(animate_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(animate.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(animate.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(animate, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment17.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance17($$self, $$props, $$invalidate) {
  let $presence;
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("AnimateLayoutContextProvider", slots, []);
  let { visualElement: visualElement2, props, isCustom } = $$props;
  let { layout } = props;
  const presence = usePresence(isCustom);
  validate_store(presence, "presence");
  component_subscribe($$self, presence, (value) => $$invalidate(2, $presence = value));
  $$self.$$.on_mount.push(function() {
    if (visualElement2 === void 0 && !("visualElement" in $$props || $$self.$$.bound[$$self.$$.props["visualElement"]])) {
      console.warn("<AnimateLayoutContextProvider> was created without expected prop 'visualElement'");
    }
    if (props === void 0 && !("props" in $$props || $$self.$$.bound[$$self.$$.props["props"]])) {
      console.warn("<AnimateLayoutContextProvider> was created without expected prop 'props'");
    }
    if (isCustom === void 0 && !("isCustom" in $$props || $$self.$$.bound[$$self.$$.props["isCustom"]])) {
      console.warn("<AnimateLayoutContextProvider> was created without expected prop 'isCustom'");
    }
  });
  const writable_props = ["visualElement", "props", "isCustom"];
  Object.keys($$props).forEach((key) => {
    if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$" && key !== "slot")
      console.warn(`<AnimateLayoutContextProvider> was created with unknown prop '${key}'`);
  });
  $$self.$$set = ($$props2) => {
    if ("visualElement" in $$props2)
      $$invalidate(0, visualElement2 = $$props2.visualElement);
    if ("props" in $$props2)
      $$invalidate(4, props = $$props2.props);
    if ("isCustom" in $$props2)
      $$invalidate(5, isCustom = $$props2.isCustom);
  };
  $$self.$capture_state = () => ({
    usePresence,
    Animate: Animate_default,
    visualElement: visualElement2,
    props,
    isCustom,
    layout,
    presence,
    $presence
  });
  $$self.$inject_state = ($$props2) => {
    if ("visualElement" in $$props2)
      $$invalidate(0, visualElement2 = $$props2.visualElement);
    if ("props" in $$props2)
      $$invalidate(4, props = $$props2.props);
    if ("isCustom" in $$props2)
      $$invalidate(5, isCustom = $$props2.isCustom);
    if ("layout" in $$props2)
      $$invalidate(1, layout = $$props2.layout);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$self.$$.update = () => {
    if ($$self.$$.dirty & /*props*/
    16) {
      $:
        $$invalidate(1, { layout } = props, layout);
    }
  };
  return [visualElement2, layout, $presence, presence, props, isCustom];
}
var AnimateLayoutContextProvider = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance17, create_fragment17, safe_not_equal, { visualElement: 0, props: 4, isCustom: 5 });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "AnimateLayoutContextProvider",
      options,
      id: create_fragment17.name
    });
  }
  get visualElement() {
    throw new Error("<AnimateLayoutContextProvider>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set visualElement(value) {
    throw new Error("<AnimateLayoutContextProvider>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get props() {
    throw new Error("<AnimateLayoutContextProvider>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set props(value) {
    throw new Error("<AnimateLayoutContextProvider>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get isCustom() {
    throw new Error("<AnimateLayoutContextProvider>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set isCustom(value) {
    throw new Error("<AnimateLayoutContextProvider>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var AnimateLayoutContextProvider_default = AnimateLayoutContextProvider;

// node_modules/svelte-motion/src/motion/features/layout/Measure.svelte
function create_fragment18(ctx) {
  const block = {
    c: noop,
    l: noop,
    m: noop,
    p: noop,
    i: noop,
    o: noop,
    d: noop
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment18.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance18($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("Measure", slots, []);
  let { visualElement: visualElement2, syncLayout, framerSyncLayout, update } = $$props;
  const scaleCorrectionContext = getContext(ScaleCorrectionContext);
  const scaleCorrectionParentContext = getContext(ScaleCorrectionParentContext);
  onMount(() => {
    isSharedLayout(syncLayout) && syncLayout.register(visualElement2);
    isSharedLayout(framerSyncLayout) && framerSyncLayout.register(visualElement2);
    visualElement2.onUnmount(() => {
      if (isSharedLayout(syncLayout)) {
        syncLayout.remove(visualElement2);
      }
      if (isSharedLayout(framerSyncLayout)) {
        framerSyncLayout.remove(visualElement2);
      }
    });
  });
  let updated = false;
  const updater = (nc = false) => {
    if (updated) {
      return null;
    }
    updated = true;
    get_store_value(scaleCorrectionContext).forEach((v) => {
      var _a;
      (_a = v.updater) == null ? void 0 : _a.call(v, true);
    });
    if (isSharedLayout(syncLayout)) {
      syncLayout.syncUpdate();
    } else {
      snapshotViewportBox(visualElement2, nc);
      syncLayout.add(visualElement2);
    }
    return null;
  };
  if (update === void 0) {
    beforeUpdate(updater);
  }
  const afterU = (nc = false) => {
    updated = false;
    const scc = get_store_value(scaleCorrectionContext);
    scc.forEach((v, i) => {
      var _a;
      (_a = v.afterU) == null ? void 0 : _a.call(v, true);
    });
    if (!isSharedLayout(syncLayout)) {
      syncLayout.flush();
    }
  };
  scaleCorrectionParentContext.update((v) => v.concat([{ updater, afterU }]));
  afterUpdate(afterU);
  $$self.$$.on_mount.push(function() {
    if (visualElement2 === void 0 && !("visualElement" in $$props || $$self.$$.bound[$$self.$$.props["visualElement"]])) {
      console.warn("<Measure> was created without expected prop 'visualElement'");
    }
    if (syncLayout === void 0 && !("syncLayout" in $$props || $$self.$$.bound[$$self.$$.props["syncLayout"]])) {
      console.warn("<Measure> was created without expected prop 'syncLayout'");
    }
    if (framerSyncLayout === void 0 && !("framerSyncLayout" in $$props || $$self.$$.bound[$$self.$$.props["framerSyncLayout"]])) {
      console.warn("<Measure> was created without expected prop 'framerSyncLayout'");
    }
    if (update === void 0 && !("update" in $$props || $$self.$$.bound[$$self.$$.props["update"]])) {
      console.warn("<Measure> was created without expected prop 'update'");
    }
  });
  const writable_props = ["visualElement", "syncLayout", "framerSyncLayout", "update"];
  Object.keys($$props).forEach((key) => {
    if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$" && key !== "slot")
      console.warn(`<Measure> was created with unknown prop '${key}'`);
  });
  $$self.$$set = ($$props2) => {
    if ("visualElement" in $$props2)
      $$invalidate(0, visualElement2 = $$props2.visualElement);
    if ("syncLayout" in $$props2)
      $$invalidate(1, syncLayout = $$props2.syncLayout);
    if ("framerSyncLayout" in $$props2)
      $$invalidate(2, framerSyncLayout = $$props2.framerSyncLayout);
    if ("update" in $$props2)
      $$invalidate(3, update = $$props2.update);
  };
  $$self.$capture_state = () => ({
    afterUpdate,
    beforeUpdate,
    getContext,
    onMount,
    get: get_store_value,
    ScaleCorrectionContext,
    ScaleCorrectionParentContext,
    isSharedLayout,
    snapshotViewportBox,
    visualElement: visualElement2,
    syncLayout,
    framerSyncLayout,
    update,
    scaleCorrectionContext,
    scaleCorrectionParentContext,
    updated,
    updater,
    afterU
  });
  $$self.$inject_state = ($$props2) => {
    if ("visualElement" in $$props2)
      $$invalidate(0, visualElement2 = $$props2.visualElement);
    if ("syncLayout" in $$props2)
      $$invalidate(1, syncLayout = $$props2.syncLayout);
    if ("framerSyncLayout" in $$props2)
      $$invalidate(2, framerSyncLayout = $$props2.framerSyncLayout);
    if ("update" in $$props2)
      $$invalidate(3, update = $$props2.update);
    if ("updated" in $$props2)
      updated = $$props2.updated;
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$self.$$.update = () => {
    if ($$self.$$.dirty & /*update*/
    8) {
      $:
        update !== void 0 && updater(update);
    }
  };
  return [visualElement2, syncLayout, framerSyncLayout, update];
}
var Measure = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance18, create_fragment18, safe_not_equal, {
      visualElement: 0,
      syncLayout: 1,
      framerSyncLayout: 2,
      update: 3
    });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "Measure",
      options,
      id: create_fragment18.name
    });
  }
  get visualElement() {
    throw new Error("<Measure>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set visualElement(value) {
    throw new Error("<Measure>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get syncLayout() {
    throw new Error("<Measure>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set syncLayout(value) {
    throw new Error("<Measure>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get framerSyncLayout() {
    throw new Error("<Measure>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set framerSyncLayout(value) {
    throw new Error("<Measure>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get update() {
    throw new Error("<Measure>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set update(value) {
    throw new Error("<Measure>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var Measure_default = Measure;

// node_modules/svelte-motion/src/motion/features/layout/MeasureContextProvider.svelte
function create_fragment19(ctx) {
  let measure;
  let current;
  measure = new Measure_default({
    props: {
      syncLayout: (
        /*$syncLayout*/
        ctx[2]
      ),
      framerSyncLayout: (
        /*$framerSyncLayout*/
        ctx[3]
      ),
      visualElement: (
        /*visualElement*/
        ctx[0]
      ),
      update: (
        /*update*/
        ctx[1]
      )
    },
    $$inline: true
  });
  const block = {
    c: function create() {
      create_component(measure.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(measure.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(measure, target, anchor);
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      const measure_changes = {};
      if (dirty & /*$syncLayout*/
      4)
        measure_changes.syncLayout = /*$syncLayout*/
        ctx2[2];
      if (dirty & /*$framerSyncLayout*/
      8)
        measure_changes.framerSyncLayout = /*$framerSyncLayout*/
        ctx2[3];
      if (dirty & /*visualElement*/
      1)
        measure_changes.visualElement = /*visualElement*/
        ctx2[0];
      if (dirty & /*update*/
      2)
        measure_changes.update = /*update*/
        ctx2[1];
      measure.$set(measure_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(measure.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(measure.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(measure, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment19.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance19($$self, $$props, $$invalidate) {
  let update;
  let $syncLayout;
  let $framerSyncLayout;
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("MeasureContextProvider", slots, []);
  let { visualElement: visualElement2, props, isCustom } = $$props;
  const syncLayout = getContext(SharedLayoutContext) || SharedLayoutContext(isCustom);
  validate_store(syncLayout, "syncLayout");
  component_subscribe($$self, syncLayout, (value) => $$invalidate(2, $syncLayout = value));
  const framerSyncLayout = getContext(FramerTreeLayoutContext) || FramerTreeLayoutContext(isCustom);
  validate_store(framerSyncLayout, "framerSyncLayout");
  component_subscribe($$self, framerSyncLayout, (value) => $$invalidate(3, $framerSyncLayout = value));
  $$self.$$.on_mount.push(function() {
    if (visualElement2 === void 0 && !("visualElement" in $$props || $$self.$$.bound[$$self.$$.props["visualElement"]])) {
      console.warn("<MeasureContextProvider> was created without expected prop 'visualElement'");
    }
    if (props === void 0 && !("props" in $$props || $$self.$$.bound[$$self.$$.props["props"]])) {
      console.warn("<MeasureContextProvider> was created without expected prop 'props'");
    }
    if (isCustom === void 0 && !("isCustom" in $$props || $$self.$$.bound[$$self.$$.props["isCustom"]])) {
      console.warn("<MeasureContextProvider> was created without expected prop 'isCustom'");
    }
  });
  const writable_props = ["visualElement", "props", "isCustom"];
  Object.keys($$props).forEach((key) => {
    if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$" && key !== "slot")
      console.warn(`<MeasureContextProvider> was created with unknown prop '${key}'`);
  });
  $$self.$$set = ($$props2) => {
    if ("visualElement" in $$props2)
      $$invalidate(0, visualElement2 = $$props2.visualElement);
    if ("props" in $$props2)
      $$invalidate(6, props = $$props2.props);
    if ("isCustom" in $$props2)
      $$invalidate(7, isCustom = $$props2.isCustom);
  };
  $$self.$capture_state = () => ({
    getContext,
    SharedLayoutContext,
    FramerTreeLayoutContext,
    Measure: Measure_default,
    visualElement: visualElement2,
    props,
    isCustom,
    syncLayout,
    framerSyncLayout,
    update,
    $syncLayout,
    $framerSyncLayout
  });
  $$self.$inject_state = ($$props2) => {
    if ("visualElement" in $$props2)
      $$invalidate(0, visualElement2 = $$props2.visualElement);
    if ("props" in $$props2)
      $$invalidate(6, props = $$props2.props);
    if ("isCustom" in $$props2)
      $$invalidate(7, isCustom = $$props2.isCustom);
    if ("update" in $$props2)
      $$invalidate(1, update = $$props2.update);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$self.$$.update = () => {
    if ($$self.$$.dirty & /*props*/
    64) {
      $:
        $$invalidate(1, { update } = props, update);
    }
  };
  return [
    visualElement2,
    update,
    $syncLayout,
    $framerSyncLayout,
    syncLayout,
    framerSyncLayout,
    props,
    isCustom
  ];
}
var MeasureContextProvider = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance19, create_fragment19, safe_not_equal, { visualElement: 0, props: 6, isCustom: 7 });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "MeasureContextProvider",
      options,
      id: create_fragment19.name
    });
  }
  get visualElement() {
    throw new Error("<MeasureContextProvider>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set visualElement(value) {
    throw new Error("<MeasureContextProvider>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get props() {
    throw new Error("<MeasureContextProvider>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set props(value) {
    throw new Error("<MeasureContextProvider>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get isCustom() {
    throw new Error("<MeasureContextProvider>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set isCustom(value) {
    throw new Error("<MeasureContextProvider>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var MeasureContextProvider_default = MeasureContextProvider;

// node_modules/svelte-motion/src/motion/features/layout/index.js
var layoutAnimations = {
  measureLayout: MeasureContextProvider_default,
  layoutAnimation: AnimateLayoutContextProvider_default
};

// node_modules/svelte-motion/src/motion/features/AnimationState.svelte
function create_fragment20(ctx) {
  const block = {
    c: noop,
    l: noop,
    m: noop,
    p: noop,
    i: noop,
    o: noop,
    d: noop
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment20.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance20($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("AnimationState", slots, []);
  let { visualElement: visualElement2, props } = $$props;
  let { animate } = props;
  $$self.$$.on_mount.push(function() {
    if (visualElement2 === void 0 && !("visualElement" in $$props || $$self.$$.bound[$$self.$$.props["visualElement"]])) {
      console.warn("<AnimationState> was created without expected prop 'visualElement'");
    }
    if (props === void 0 && !("props" in $$props || $$self.$$.bound[$$self.$$.props["props"]])) {
      console.warn("<AnimationState> was created without expected prop 'props'");
    }
  });
  const writable_props = ["visualElement", "props"];
  Object.keys($$props).forEach((key) => {
    if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$" && key !== "slot")
      console.warn(`<AnimationState> was created with unknown prop '${key}'`);
  });
  $$self.$$set = ($$props2) => {
    if ("visualElement" in $$props2)
      $$invalidate(0, visualElement2 = $$props2.visualElement);
    if ("props" in $$props2)
      $$invalidate(1, props = $$props2.props);
  };
  $$self.$capture_state = () => ({
    tick,
    createAnimationState,
    isAnimationControls,
    visualElement: visualElement2,
    props,
    animate
  });
  $$self.$inject_state = ($$props2) => {
    if ("visualElement" in $$props2)
      $$invalidate(0, visualElement2 = $$props2.visualElement);
    if ("props" in $$props2)
      $$invalidate(1, props = $$props2.props);
    if ("animate" in $$props2)
      $$invalidate(2, animate = $$props2.animate);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$self.$$.update = () => {
    if ($$self.$$.dirty & /*props*/
    2) {
      $:
        $$invalidate(2, { animate } = props, animate);
    }
    if ($$self.$$.dirty & /*visualElement*/
    1) {
      $: {
        $$invalidate(0, visualElement2.animationState = visualElement2.animationState || createAnimationState(visualElement2), visualElement2);
      }
    }
    if ($$self.$$.dirty & /*animate, visualElement*/
    5) {
      $:
        if (isAnimationControls(animate)) {
          tick().then(() => animate.subscribe(visualElement2));
        }
    }
  };
  return [visualElement2, props, animate];
}
var AnimationState = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance20, create_fragment20, safe_not_equal, { visualElement: 0, props: 1 });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "AnimationState",
      options,
      id: create_fragment20.name
    });
  }
  get visualElement() {
    throw new Error("<AnimationState>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set visualElement(value) {
    throw new Error("<AnimationState>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get props() {
    throw new Error("<AnimationState>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set props(value) {
    throw new Error("<AnimationState>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var AnimationState_default = AnimationState;

// node_modules/svelte-motion/src/motion/features/Exit.svelte
function create_fragment21(ctx) {
  let current;
  const default_slot_template = (
    /*#slots*/
    ctx[7].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[6],
    null
  );
  const block = {
    c: function create() {
      if (default_slot)
        default_slot.c();
    },
    l: function claim(nodes) {
      if (default_slot)
        default_slot.l(nodes);
    },
    m: function mount(target, anchor) {
      if (default_slot) {
        default_slot.m(target, anchor);
      }
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope*/
        64)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[6],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[6]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[6],
              dirty,
              null
            ),
            null
          );
        }
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(default_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (default_slot)
        default_slot.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment21.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance21($$self, $$props, $$invalidate) {
  let custom;
  let $presence;
  let $presenceContext;
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("Exit", slots, ["default"]);
  let { props, visualElement: visualElement2, isCustom } = $$props;
  const presenceContext = getContext(PresenceContext) || PresenceContext(isCustom);
  validate_store(presenceContext, "presenceContext");
  component_subscribe($$self, presenceContext, (value) => $$invalidate(9, $presenceContext = value));
  const presence = usePresence(isCustom);
  validate_store(presence, "presence");
  component_subscribe($$self, presence, (value) => $$invalidate(5, $presence = value));
  const effect = (pres) => {
    var _a;
    const [isPresent2, onExitComplete] = pres;
    const animation = (_a = visualElement2.animationState) == null ? void 0 : _a.setActive(AnimationType.Exit, !isPresent2, {
      custom: ($presenceContext == null ? void 0 : $presenceContext.custom) ?? custom
    });
    !isPresent2 && (animation == null ? void 0 : animation.then(onExitComplete));
    return "";
  };
  $$self.$$.on_mount.push(function() {
    if (props === void 0 && !("props" in $$props || $$self.$$.bound[$$self.$$.props["props"]])) {
      console.warn("<Exit> was created without expected prop 'props'");
    }
    if (visualElement2 === void 0 && !("visualElement" in $$props || $$self.$$.bound[$$self.$$.props["visualElement"]])) {
      console.warn("<Exit> was created without expected prop 'visualElement'");
    }
    if (isCustom === void 0 && !("isCustom" in $$props || $$self.$$.bound[$$self.$$.props["isCustom"]])) {
      console.warn("<Exit> was created without expected prop 'isCustom'");
    }
  });
  const writable_props = ["props", "visualElement", "isCustom"];
  Object.keys($$props).forEach((key) => {
    if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$" && key !== "slot")
      console.warn(`<Exit> was created with unknown prop '${key}'`);
  });
  $$self.$$set = ($$props2) => {
    if ("props" in $$props2)
      $$invalidate(2, props = $$props2.props);
    if ("visualElement" in $$props2)
      $$invalidate(3, visualElement2 = $$props2.visualElement);
    if ("isCustom" in $$props2)
      $$invalidate(4, isCustom = $$props2.isCustom);
    if ("$$scope" in $$props2)
      $$invalidate(6, $$scope = $$props2.$$scope);
  };
  $$self.$capture_state = () => ({
    usePresence,
    getContext,
    PresenceContext,
    AnimationType,
    props,
    visualElement: visualElement2,
    isCustom,
    presenceContext,
    presence,
    effect,
    custom,
    $presence,
    $presenceContext
  });
  $$self.$inject_state = ($$props2) => {
    if ("props" in $$props2)
      $$invalidate(2, props = $$props2.props);
    if ("visualElement" in $$props2)
      $$invalidate(3, visualElement2 = $$props2.visualElement);
    if ("isCustom" in $$props2)
      $$invalidate(4, isCustom = $$props2.isCustom);
    if ("custom" in $$props2)
      custom = $$props2.custom;
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$self.$$.update = () => {
    if ($$self.$$.dirty & /*props*/
    4) {
      $:
        ({ custom } = props);
    }
    if ($$self.$$.dirty & /*$presence*/
    32) {
      $:
        effect($presence);
    }
  };
  return [
    presenceContext,
    presence,
    props,
    visualElement2,
    isCustom,
    $presence,
    $$scope,
    slots
  ];
}
var Exit = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance21, create_fragment21, safe_not_equal, { props: 2, visualElement: 3, isCustom: 4 });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "Exit",
      options,
      id: create_fragment21.name
    });
  }
  get props() {
    throw new Error("<Exit>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set props(value) {
    throw new Error("<Exit>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get visualElement() {
    throw new Error("<Exit>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set visualElement(value) {
    throw new Error("<Exit>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get isCustom() {
    throw new Error("<Exit>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set isCustom(value) {
    throw new Error("<Exit>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var Exit_default = Exit;

// node_modules/svelte-motion/src/motion/features/animations.js
var animations = {
  animation: AnimationState_default,
  exit: Exit_default
};

// node_modules/svelte-motion/src/render/dom/featureBundle.js
var featureBundle = {
  ...animations,
  ...gestureAnimations,
  ...drag,
  ...layoutAnimations
};

// node_modules/svelte-motion/src/motion/MotionSSR.svelte
function get_each_context(ctx, list, i) {
  const child_ctx = ctx.slice();
  child_ctx[21] = list[i];
  return child_ctx;
}
var get_default_slot_changes10 = (dirty) => ({
  motion: dirty & /*motion*/
  16777216,
  props: dirty & /*renderProps*/
  33554432
});
var get_default_slot_context10 = (ctx) => ({
  motion: (
    /*motion*/
    ctx[24]
  ),
  props: (
    /*renderProps*/
    ctx[25]
  )
});
function create_default_slot_6(ctx) {
  let current;
  const default_slot_template = (
    /*#slots*/
    ctx[14].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[15],
    get_default_slot_context10
  );
  const block = {
    c: function create() {
      if (default_slot)
        default_slot.c();
    },
    l: function claim(nodes) {
      if (default_slot)
        default_slot.l(nodes);
    },
    m: function mount(target, anchor) {
      if (default_slot) {
        default_slot.m(target, anchor);
      }
      current = true;
    },
    p: function update(ctx2, dirty) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope, motion, renderProps*/
        50364416)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[15],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[15]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[15],
              dirty,
              get_default_slot_changes10
            ),
            get_default_slot_context10
          );
        }
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(default_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (default_slot)
        default_slot.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot_6.name,
    type: "slot",
    source: "(205:24) <UseRender                             {Component}                             props={motionProps}                             ref={useMotionRef(                                 visualState,                                 context.visualElement,                                 externalRef                             )}                             {visualState}                             {isStatic}                             {forwardMotionProps}                             let:motion                             let:props={renderProps}                             {targetEl}                         >",
    ctx
  });
  return block;
}
function create_default_slot_5(ctx) {
  let userender;
  let current;
  userender = new UseRender_default({
    props: {
      Component: (
        /*Component*/
        ctx[6]
      ),
      props: (
        /*motionProps*/
        ctx[5]
      ),
      ref: useMotionRef(
        /*visualState*/
        ctx[18],
        /*context*/
        ctx[17].visualElement,
        /*externalRef*/
        ctx[1]
      ),
      visualState: (
        /*visualState*/
        ctx[18]
      ),
      isStatic: (
        /*isStatic*/
        ctx[4]
      ),
      forwardMotionProps: (
        /*forwardMotionProps*/
        ctx[0]
      ),
      targetEl: (
        /*targetEl*/
        ctx[2]
      ),
      $$slots: {
        default: [
          create_default_slot_6,
          ({ motion, props: renderProps }) => ({ 24: motion, 25: renderProps }),
          ({ motion, props: renderProps }) => (motion ? 16777216 : 0) | (renderProps ? 33554432 : 0)
        ]
      },
      $$scope: { ctx }
    },
    $$inline: true
  });
  const block = {
    c: function create() {
      create_component(userender.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(userender.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(userender, target, anchor);
      current = true;
    },
    p: function update(ctx2, dirty) {
      const userender_changes = {};
      if (dirty & /*motionProps*/
      32)
        userender_changes.props = /*motionProps*/
        ctx2[5];
      if (dirty & /*visualState, context, externalRef*/
      393218)
        userender_changes.ref = useMotionRef(
          /*visualState*/
          ctx2[18],
          /*context*/
          ctx2[17].visualElement,
          /*externalRef*/
          ctx2[1]
        );
      if (dirty & /*visualState*/
      262144)
        userender_changes.visualState = /*visualState*/
        ctx2[18];
      if (dirty & /*isStatic*/
      16)
        userender_changes.isStatic = /*isStatic*/
        ctx2[4];
      if (dirty & /*forwardMotionProps*/
      1)
        userender_changes.forwardMotionProps = /*forwardMotionProps*/
        ctx2[0];
      if (dirty & /*targetEl*/
      4)
        userender_changes.targetEl = /*targetEl*/
        ctx2[2];
      if (dirty & /*$$scope, motion, renderProps*/
      50364416) {
        userender_changes.$$scope = { dirty, ctx: ctx2 };
      }
      userender.$set(userender_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(userender.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(userender.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(userender, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot_5.name,
    type: "slot",
    source: "(204:20) <MotionContextProvider value={context} {isCustom}>",
    ctx
  });
  return block;
}
function create_if_block2(ctx) {
  let each_blocks = [];
  let each_1_lookup = /* @__PURE__ */ new Map();
  let each_1_anchor;
  let current;
  let each_value = ensure_array_like_dev(
    /*_features*/
    ctx[20]
  );
  const get_key = (ctx2) => (
    /*feat*/
    ctx2[21].key
  );
  validate_each_keys(ctx, each_value, get_each_context, get_key);
  for (let i = 0; i < each_value.length; i += 1) {
    let child_ctx = get_each_context(ctx, each_value, i);
    let key = get_key(child_ctx);
    each_1_lookup.set(key, each_blocks[i] = create_each_block(key, child_ctx));
  }
  const block = {
    c: function create() {
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].c();
      }
      each_1_anchor = empty();
    },
    l: function claim(nodes) {
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].l(nodes);
      }
      each_1_anchor = empty();
    },
    m: function mount(target, anchor) {
      for (let i = 0; i < each_blocks.length; i += 1) {
        if (each_blocks[i]) {
          each_blocks[i].m(target, anchor);
        }
      }
      insert_hydration_dev(target, each_1_anchor, anchor);
      current = true;
    },
    p: function update(ctx2, dirty) {
      if (dirty & /*_features, isCustom*/
      1048704) {
        each_value = ensure_array_like_dev(
          /*_features*/
          ctx2[20]
        );
        group_outros();
        validate_each_keys(ctx2, each_value, get_each_context, get_key);
        each_blocks = update_keyed_each(each_blocks, dirty, get_key, 1, ctx2, each_value, each_1_lookup, each_1_anchor.parentNode, outro_and_destroy_block, create_each_block, each_1_anchor, get_each_context);
        check_outros();
      }
    },
    i: function intro(local) {
      if (current)
        return;
      for (let i = 0; i < each_value.length; i += 1) {
        transition_in(each_blocks[i]);
      }
      current = true;
    },
    o: function outro(local) {
      for (let i = 0; i < each_blocks.length; i += 1) {
        transition_out(each_blocks[i]);
      }
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(each_1_anchor);
      }
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].d(detaching);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block2.name,
    type: "if",
    source: "(224:20) {#if mounted}",
    ctx
  });
  return block;
}
function create_each_block(key_1, ctx) {
  let first;
  let switch_instance;
  let switch_instance_anchor;
  let current;
  var switch_value = (
    /*feat*/
    ctx[21].Component
  );
  function switch_props(ctx2, dirty) {
    return {
      props: {
        props: (
          /*feat*/
          ctx2[21].props
        ),
        visualElement: (
          /*feat*/
          ctx2[21].visualElement
        ),
        isCustom: (
          /*isCustom*/
          ctx2[7]
        )
      },
      $$inline: true
    };
  }
  if (switch_value) {
    switch_instance = construct_svelte_component_dev(switch_value, switch_props(ctx));
  }
  const block = {
    key: key_1,
    first: null,
    c: function create() {
      first = empty();
      if (switch_instance)
        create_component(switch_instance.$$.fragment);
      switch_instance_anchor = empty();
      this.h();
    },
    l: function claim(nodes) {
      first = empty();
      if (switch_instance)
        claim_component(switch_instance.$$.fragment, nodes);
      switch_instance_anchor = empty();
      this.h();
    },
    h: function hydrate() {
      this.first = first;
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, first, anchor);
      if (switch_instance)
        mount_component(switch_instance, target, anchor);
      insert_hydration_dev(target, switch_instance_anchor, anchor);
      current = true;
    },
    p: function update(new_ctx, dirty) {
      ctx = new_ctx;
      if (dirty & /*_features*/
      1048576 && switch_value !== (switch_value = /*feat*/
      ctx[21].Component)) {
        if (switch_instance) {
          group_outros();
          const old_component = switch_instance;
          transition_out(old_component.$$.fragment, 1, 0, () => {
            destroy_component(old_component, 1);
          });
          check_outros();
        }
        if (switch_value) {
          switch_instance = construct_svelte_component_dev(switch_value, switch_props(ctx, dirty));
          create_component(switch_instance.$$.fragment);
          transition_in(switch_instance.$$.fragment, 1);
          mount_component(switch_instance, switch_instance_anchor.parentNode, switch_instance_anchor);
        } else {
          switch_instance = null;
        }
      } else if (switch_value) {
        const switch_instance_changes = {};
        if (dirty & /*_features*/
        1048576)
          switch_instance_changes.props = /*feat*/
          ctx[21].props;
        if (dirty & /*_features*/
        1048576)
          switch_instance_changes.visualElement = /*feat*/
          ctx[21].visualElement;
        switch_instance.$set(switch_instance_changes);
      }
    },
    i: function intro(local) {
      if (current)
        return;
      if (switch_instance)
        transition_in(switch_instance.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      if (switch_instance)
        transition_out(switch_instance.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(first);
        detach_dev(switch_instance_anchor);
      }
      if (switch_instance)
        destroy_component(switch_instance, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_each_block.name,
    type: "each",
    source: "(225:24) {#each _features as feat (feat.key)}",
    ctx
  });
  return block;
}
function create_default_slot_4(ctx) {
  let motioncontextprovider;
  let t;
  let if_block_anchor;
  let current;
  motioncontextprovider = new MotionContextProvider_default({
    props: {
      value: (
        /*context*/
        ctx[17]
      ),
      isCustom: (
        /*isCustom*/
        ctx[7]
      ),
      $$slots: { default: [create_default_slot_5] },
      $$scope: { ctx }
    },
    $$inline: true
  });
  let if_block = (
    /*mounted*/
    ctx[3] && create_if_block2(ctx)
  );
  const block = {
    c: function create() {
      create_component(motioncontextprovider.$$.fragment);
      t = space();
      if (if_block)
        if_block.c();
      if_block_anchor = empty();
    },
    l: function claim(nodes) {
      claim_component(motioncontextprovider.$$.fragment, nodes);
      t = claim_space(nodes);
      if (if_block)
        if_block.l(nodes);
      if_block_anchor = empty();
    },
    m: function mount(target, anchor) {
      mount_component(motioncontextprovider, target, anchor);
      insert_hydration_dev(target, t, anchor);
      if (if_block)
        if_block.m(target, anchor);
      insert_hydration_dev(target, if_block_anchor, anchor);
      current = true;
    },
    p: function update(ctx2, dirty) {
      const motioncontextprovider_changes = {};
      if (dirty & /*context*/
      131072)
        motioncontextprovider_changes.value = /*context*/
        ctx2[17];
      if (dirty & /*$$scope, motionProps, visualState, context, externalRef, isStatic, forwardMotionProps, targetEl*/
      426039) {
        motioncontextprovider_changes.$$scope = { dirty, ctx: ctx2 };
      }
      motioncontextprovider.$set(motioncontextprovider_changes);
      if (
        /*mounted*/
        ctx2[3]
      ) {
        if (if_block) {
          if_block.p(ctx2, dirty);
          if (dirty & /*mounted*/
          8) {
            transition_in(if_block, 1);
          }
        } else {
          if_block = create_if_block2(ctx2);
          if_block.c();
          transition_in(if_block, 1);
          if_block.m(if_block_anchor.parentNode, if_block_anchor);
        }
      } else if (if_block) {
        group_outros();
        transition_out(if_block, 1, 1, () => {
          if_block = null;
        });
        check_outros();
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(motioncontextprovider.$$.fragment, local);
      transition_in(if_block);
      current = true;
    },
    o: function outro(local) {
      transition_out(motioncontextprovider.$$.fragment, local);
      transition_out(if_block);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(t);
        detach_dev(if_block_anchor);
      }
      destroy_component(motioncontextprovider, detaching);
      if (if_block)
        if_block.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot_4.name,
    type: "slot",
    source: "(199:16) <UseFeatures                     visualElement={setContext(context, visualElement)}                     props={motionProps}                     let:features={_features}                 >",
    ctx
  });
  return block;
}
function create_default_slot_3(ctx) {
  let usefeatures;
  let current;
  usefeatures = new UseFeatures_default({
    props: {
      visualElement: (
        /*setContext*/
        ctx[11](
          /*context*/
          ctx[17],
          /*visualElement*/
          ctx[19]
        )
      ),
      props: (
        /*motionProps*/
        ctx[5]
      ),
      $$slots: {
        default: [
          create_default_slot_4,
          ({ features: _features }) => ({ 20: _features }),
          ({ features: _features }) => _features ? 1048576 : 0
        ]
      },
      $$scope: { ctx }
    },
    $$inline: true
  });
  const block = {
    c: function create() {
      create_component(usefeatures.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(usefeatures.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(usefeatures, target, anchor);
      current = true;
    },
    p: function update(ctx2, dirty) {
      const usefeatures_changes = {};
      if (dirty & /*context, visualElement*/
      655360)
        usefeatures_changes.visualElement = /*setContext*/
        ctx2[11](
          /*context*/
          ctx2[17],
          /*visualElement*/
          ctx2[19]
        );
      if (dirty & /*motionProps*/
      32)
        usefeatures_changes.props = /*motionProps*/
        ctx2[5];
      if (dirty & /*$$scope, _features, mounted, context, motionProps, visualState, externalRef, isStatic, forwardMotionProps, targetEl*/
      1474623) {
        usefeatures_changes.$$scope = { dirty, ctx: ctx2 };
      }
      usefeatures.$set(usefeatures_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(usefeatures.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(usefeatures.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(usefeatures, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot_3.name,
    type: "slot",
    source: "(191:12) <UseVisualElement                 {Component}                 {visualState}                 {createVisualElement}                 props={motionProps}                 {isCustom}                 let:visualElement             >",
    ctx
  });
  return block;
}
function create_default_slot_2(ctx) {
  let usevisualelement;
  let current;
  usevisualelement = new UseVisualElement_default({
    props: {
      Component: (
        /*Component*/
        ctx[6]
      ),
      visualState: (
        /*visualState*/
        ctx[18]
      ),
      createVisualElement: (
        /*createVisualElement*/
        ctx[8]
      ),
      props: (
        /*motionProps*/
        ctx[5]
      ),
      isCustom: (
        /*isCustom*/
        ctx[7]
      ),
      $$slots: {
        default: [
          create_default_slot_3,
          ({ visualElement: visualElement2 }) => ({ 19: visualElement2 }),
          ({ visualElement: visualElement2 }) => visualElement2 ? 524288 : 0
        ]
      },
      $$scope: { ctx }
    },
    $$inline: true
  });
  const block = {
    c: function create() {
      create_component(usevisualelement.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(usevisualelement.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(usevisualelement, target, anchor);
      current = true;
    },
    p: function update(ctx2, dirty) {
      const usevisualelement_changes = {};
      if (dirty & /*visualState*/
      262144)
        usevisualelement_changes.visualState = /*visualState*/
        ctx2[18];
      if (dirty & /*motionProps*/
      32)
        usevisualelement_changes.props = /*motionProps*/
        ctx2[5];
      if (dirty & /*$$scope, context, visualElement, motionProps, mounted, visualState, externalRef, isStatic, forwardMotionProps, targetEl*/
      950335) {
        usevisualelement_changes.$$scope = { dirty, ctx: ctx2 };
      }
      usevisualelement.$set(usevisualelement_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(usevisualelement.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(usevisualelement.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(usevisualelement, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot_2.name,
    type: "slot",
    source: "(184:8) <UseVisualState             config={visualStateConfig}             props={motionProps}             {isStatic}             {isCustom}             let:state={visualState}         >",
    ctx
  });
  return block;
}
function create_default_slot_12(ctx) {
  let usevisualstate;
  let current;
  usevisualstate = new UseVisualState_default({
    props: {
      config: (
        /*visualStateConfig*/
        ctx[9]
      ),
      props: (
        /*motionProps*/
        ctx[5]
      ),
      isStatic: (
        /*isStatic*/
        ctx[4]
      ),
      isCustom: (
        /*isCustom*/
        ctx[7]
      ),
      $$slots: {
        default: [
          create_default_slot_2,
          ({ state: visualState }) => ({ 18: visualState }),
          ({ state: visualState }) => visualState ? 262144 : 0
        ]
      },
      $$scope: { ctx }
    },
    $$inline: true
  });
  const block = {
    c: function create() {
      create_component(usevisualstate.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(usevisualstate.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(usevisualstate, target, anchor);
      current = true;
    },
    p: function update(ctx2, dirty) {
      const usevisualstate_changes = {};
      if (dirty & /*motionProps*/
      32)
        usevisualstate_changes.props = /*motionProps*/
        ctx2[5];
      if (dirty & /*isStatic*/
      16)
        usevisualstate_changes.isStatic = /*isStatic*/
        ctx2[4];
      if (dirty & /*$$scope, visualState, motionProps, context, mounted, externalRef, isStatic, forwardMotionProps, targetEl*/
      426047) {
        usevisualstate_changes.$$scope = { dirty, ctx: ctx2 };
      }
      usevisualstate.$set(usevisualstate_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(usevisualstate.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(usevisualstate.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(usevisualstate, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot_12.name,
    type: "slot",
    source: "(183:4) <UseCreateMotionContext props={motionProps} {isStatic} let:value={context}>",
    ctx
  });
  return block;
}
function create_default_slot7(ctx) {
  let usecreatemotioncontext;
  let current;
  usecreatemotioncontext = new UseCreateMotionContext_default({
    props: {
      props: (
        /*motionProps*/
        ctx[5]
      ),
      isStatic: (
        /*isStatic*/
        ctx[4]
      ),
      $$slots: {
        default: [
          create_default_slot_12,
          ({ value: context }) => ({ 17: context }),
          ({ value: context }) => context ? 131072 : 0
        ]
      },
      $$scope: { ctx }
    },
    $$inline: true
  });
  const block = {
    c: function create() {
      create_component(usecreatemotioncontext.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(usecreatemotioncontext.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(usecreatemotioncontext, target, anchor);
      current = true;
    },
    p: function update(ctx2, dirty) {
      const usecreatemotioncontext_changes = {};
      if (dirty & /*motionProps*/
      32)
        usecreatemotioncontext_changes.props = /*motionProps*/
        ctx2[5];
      if (dirty & /*isStatic*/
      16)
        usecreatemotioncontext_changes.isStatic = /*isStatic*/
        ctx2[4];
      if (dirty & /*$$scope, motionProps, isStatic, context, mounted, externalRef, forwardMotionProps, targetEl*/
      163903) {
        usecreatemotioncontext_changes.$$scope = { dirty, ctx: ctx2 };
      }
      usecreatemotioncontext.$set(usecreatemotioncontext_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(usecreatemotioncontext.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(usecreatemotioncontext.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(usecreatemotioncontext, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot7.name,
    type: "slot",
    source: "(182:0) <ScaleCorrectionProvider {isCustom}>",
    ctx
  });
  return block;
}
function create_fragment22(ctx) {
  let scalecorrectionprovider;
  let current;
  scalecorrectionprovider = new ScaleCorrectionProvider_default({
    props: {
      isCustom: (
        /*isCustom*/
        ctx[7]
      ),
      $$slots: { default: [create_default_slot7] },
      $$scope: { ctx }
    },
    $$inline: true
  });
  const block = {
    c: function create() {
      create_component(scalecorrectionprovider.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(scalecorrectionprovider.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(scalecorrectionprovider, target, anchor);
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      const scalecorrectionprovider_changes = {};
      if (dirty & /*$$scope, motionProps, isStatic, mounted, externalRef, forwardMotionProps, targetEl*/
      32831) {
        scalecorrectionprovider_changes.$$scope = { dirty, ctx: ctx2 };
      }
      scalecorrectionprovider.$set(scalecorrectionprovider_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(scalecorrectionprovider.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(scalecorrectionprovider.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(scalecorrectionprovider, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment22.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance22($$self, $$props, $$invalidate) {
  let motionProps;
  let isStatic;
  const omit_props_names = ["isSVG", "forwardMotionProps", "externalRef", "targetEl"];
  let $$restProps = compute_rest_props($$props, omit_props_names);
  let $a;
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("MotionSSR", slots, ["default"]);
  let { isSVG = false, forwardMotionProps = false, externalRef = void 0, targetEl = void 0 } = $$props;
  loadFeatures(featureBundle);
  let Component = isSVG ? "SVG" : "DOM";
  let isCustom = targetEl || false;
  let createVisualElement = createDomVisualElement;
  let visualStateConfig = isSVG ? svgMotionConfig : htmlMotionConfig;
  const a = getContext(MotionConfigContext) || MotionConfigContext(isCustom);
  validate_store(a, "a");
  component_subscribe($$self, a, (value) => $$invalidate(13, $a = value));
  let mounted = false;
  const setContext2 = (c, v) => {
    c.visualElement = v;
    return v;
  };
  onMount(() => {
    $$invalidate(3, mounted = true);
  });
  $$self.$$set = ($$new_props) => {
    $$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
    $$invalidate(16, $$restProps = compute_rest_props($$props, omit_props_names));
    if ("isSVG" in $$new_props)
      $$invalidate(12, isSVG = $$new_props.isSVG);
    if ("forwardMotionProps" in $$new_props)
      $$invalidate(0, forwardMotionProps = $$new_props.forwardMotionProps);
    if ("externalRef" in $$new_props)
      $$invalidate(1, externalRef = $$new_props.externalRef);
    if ("targetEl" in $$new_props)
      $$invalidate(2, targetEl = $$new_props.targetEl);
    if ("$$scope" in $$new_props)
      $$invalidate(15, $$scope = $$new_props.$$scope);
  };
  $$self.$capture_state = () => ({
    MotionConfigContext,
    UseVisualElement: UseVisualElement_default,
    UseFeatures: UseFeatures_default,
    MotionContextProvider: MotionContextProvider_default,
    getContext,
    onMount,
    UseRender: UseRender_default,
    createDomVisualElement,
    svgMotionConfig,
    htmlMotionConfig,
    UseCreateMotionContext: UseCreateMotionContext_default,
    UseVisualState: UseVisualState_default,
    useMotionRef,
    ScaleCorrectionProvider: ScaleCorrectionProvider_default,
    featureBundle,
    loadFeatures,
    isSVG,
    forwardMotionProps,
    externalRef,
    targetEl,
    Component,
    isCustom,
    createVisualElement,
    visualStateConfig,
    a,
    mounted,
    setContext: setContext2,
    isStatic,
    motionProps,
    $a
  });
  $$self.$inject_state = ($$new_props) => {
    if ("isSVG" in $$props)
      $$invalidate(12, isSVG = $$new_props.isSVG);
    if ("forwardMotionProps" in $$props)
      $$invalidate(0, forwardMotionProps = $$new_props.forwardMotionProps);
    if ("externalRef" in $$props)
      $$invalidate(1, externalRef = $$new_props.externalRef);
    if ("targetEl" in $$props)
      $$invalidate(2, targetEl = $$new_props.targetEl);
    if ("Component" in $$props)
      $$invalidate(6, Component = $$new_props.Component);
    if ("isCustom" in $$props)
      $$invalidate(7, isCustom = $$new_props.isCustom);
    if ("createVisualElement" in $$props)
      $$invalidate(8, createVisualElement = $$new_props.createVisualElement);
    if ("visualStateConfig" in $$props)
      $$invalidate(9, visualStateConfig = $$new_props.visualStateConfig);
    if ("mounted" in $$props)
      $$invalidate(3, mounted = $$new_props.mounted);
    if ("isStatic" in $$props)
      $$invalidate(4, isStatic = $$new_props.isStatic);
    if ("motionProps" in $$props)
      $$invalidate(5, motionProps = $$new_props.motionProps);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$self.$$.update = () => {
    $:
      $$invalidate(5, motionProps = $$restProps);
    if ($$self.$$.dirty & /*$a*/
    8192) {
      $:
        $$invalidate(4, { isStatic } = $a || {}, isStatic);
    }
  };
  return [
    forwardMotionProps,
    externalRef,
    targetEl,
    mounted,
    isStatic,
    motionProps,
    Component,
    isCustom,
    createVisualElement,
    visualStateConfig,
    a,
    setContext2,
    isSVG,
    $a,
    slots,
    $$scope
  ];
}
var MotionSSR = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance22, create_fragment22, safe_not_equal, {
      isSVG: 12,
      forwardMotionProps: 0,
      externalRef: 1,
      targetEl: 2
    });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "MotionSSR",
      options,
      id: create_fragment22.name
    });
  }
  get isSVG() {
    throw new Error("<MotionSSR>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set isSVG(value) {
    throw new Error("<MotionSSR>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get forwardMotionProps() {
    throw new Error("<MotionSSR>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set forwardMotionProps(value) {
    throw new Error("<MotionSSR>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get externalRef() {
    throw new Error("<MotionSSR>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set externalRef(value) {
    throw new Error("<MotionSSR>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get targetEl() {
    throw new Error("<MotionSSR>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set targetEl(value) {
    throw new Error("<MotionSSR>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var MotionSSR_default = MotionSSR;
export {
  MotionSSR_default as default
};
//# sourceMappingURL=svelte-motion_src_motion_MotionSSR__svelte.js.map
